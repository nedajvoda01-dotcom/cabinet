<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Autocontent Spec</title>

  <!-- ========================================================= -->
  <!-- BASE DESIGN v2 (Light + ~15% Brand + stronger gray/black) -->
  <!-- Typography: Inter-like sans + Mono for tech blocks        -->
  <!-- Simplified header: only nav + small actions               -->
  <!-- ========================================================= -->
  <style>
    :root{
      /* base surfaces */
      --bg:#F9F9F9;
      --surface:#FFFFFF;
      --surface-2:#F3F3F3;
      --surface-3:#EDEDED;

      /* text */
      --text:#000000;          /* black */
      --text-soft:#333333;     /* main paragraphs */
      --muted:#646464;         /* secondary */
      --muted-2:#A7A7A7;       /* meta */

      /* brand (~15%) */
      --accent:#E85002;
      --accent-2:#F16001;
      --danger:#C70B01;
      --warning:#DC3A0B;

      /* gradient */
      --grad-1:#000000;
      --grad-2:#C70B01;
      --grad-3:#F16001;
      --grad-4:#DC3A0B;

      --line:#E5E5E5;
      --line-dark:#CFCFCF;
      --radius:14px;

      --sans: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    *{box-sizing:border-box;}
    body{
      margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);
      line-height:1.65;font-size:15px;
    }
    .wrap{max-width:1120px;margin:0 auto;padding:18px 20px;}

    /* simplified header */
    header{
      position:sticky;top:0;z-index:30;
      background:rgba(249,249,249,.97);
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(6px);
    }
    .header-row{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:8px 0;
    }
    .brand{
      display:flex;flex-direction:column;gap:2px;
    }
    .brand-title{
      font-size:20px;font-weight:800;letter-spacing:.2px;color:var(--text);
    }
    .brand-meta{
      font-size:12px;color:var(--muted);
    }
    .hero-line{
      height:4px;border-radius:999px;margin-top:6px;
      background:linear-gradient(90deg,var(--grad-1),var(--grad-2),var(--grad-3),var(--grad-4));
      opacity:.9;
    }
    .actions{display:flex;gap:6px;flex-wrap:wrap;}
    .btn{
      font-size:12px;padding:5px 9px;border-radius:999px;
      background:var(--surface);border:1px solid var(--line);
      color:var(--text);cursor:pointer;
    }
    .btn:hover{border-color:var(--accent);color:var(--accent);}

    /* TOC */
    nav.toc{
      display:flex;flex-wrap:wrap;gap:6px;padding:8px 0 12px;
    }
    nav.toc a{
      display:inline-flex;align-items:center;gap:6px;
      padding:6px 10px;border:1px solid var(--line);
      border-radius:999px;background:var(--surface);
      color:var(--text);text-decoration:none;font-size:13px;
    }
    nav.toc a:hover{border-color:var(--accent-2);color:var(--accent-2);}
    .toc-pill{
      font-size:11px;color:var(--muted);border:1px solid var(--line);
      padding:1px 6px;border-radius:999px;background:var(--surface-2);
    }

    /* sections */
    .section{
      background:var(--surface);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px;
      margin:14px 0;
      box-shadow:0 1px 0 rgba(0,0,0,.02);
    }
    .section-title{
      font-size:24px;margin:0 0 6px;display:flex;gap:8px;align-items:center;
      font-weight:800;
    }
    .part-number{
      font-weight:900;color:var(--accent);
      padding:2px 8px;border-left:5px solid var(--accent);
    }
    .subtitle{
      color:var(--muted);font-size:14px;margin:0 0 10px;
    }
    .level-pill{
      display:inline-block;font-size:12px;color:var(--accent);
      border:1px dashed var(--accent);
      background:rgba(232,80,2,.06);
      padding:2px 8px;border-radius:999px;margin-bottom:12px;
      font-weight:600;
    }

    /* blocks / cards */
    .grid-3{
      display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
      gap:10px;margin:10px 0 14px;
    }
    .grid-2{
      display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));
      gap:10px;margin:10px 0 14px;
    }
    .card{
      background:var(--surface);
      border:1px solid var(--line);
      border-radius:12px;padding:12px;
    }
    .card.gray{
      background:var(--surface-2);
      border-color:var(--line-dark);
    }
    .card.brand{
      border-left:4px solid var(--accent);
      background:
        linear-gradient(180deg, rgba(241,96,1,.07), transparent 65%),
        var(--surface);
    }
    .card h3{
      margin:0 0 6px;font-size:16px;font-weight:800;color:var(--text);
    }
    .card p, .card ul, .card ol{
      margin:0;font-size:14px;color:var(--text-soft);
    }
    .card ul, .card ol{padding-left:18px;}

    .content-block{margin:10px 0 14px;}
    .content-block h3{
      margin:0 0 6px;font-size:17px;font-weight:800;color:var(--text);
    }
    .muted{color:var(--muted);}
    .small{font-size:13px;}

    /* tables */
    .table{
      width:100%;border-collapse:collapse;font-size:14px;margin-top:6px;
    }
    .table th,.table td{
      border-bottom:1px solid var(--line);
      padding:8px 6px;text-align:left;vertical-align:top;
      color:var(--text-soft);
    }
    .table th{
      font-weight:800;color:var(--text);
      background:rgba(0,0,0,.03);
    }

    /* details */
    details{
      background:var(--surface-2);
      border:1px solid var(--line);
      border-radius:10px;padding:8px 10px;margin:8px 0;
    }
    summary{cursor:pointer;font-weight:800;color:var(--text);}

    /* callouts */
    .callout{
      background:var(--surface);
      border:1px solid var(--line);
      border-radius:12px;padding:10px 12px;font-size:14px;margin:8px 0;
      color:var(--text-soft);
    }
    .callout.accepted{
      border-left:5px solid var(--accent);
      background:rgba(232,80,2,.05);
    }
    .callout.open{
      border-left:5px solid var(--warning);
      background:rgba(220,58,11,.06);
    }

    /* pretty pipeline */
    .pipeline{
      position:relative;
      display:grid;
      grid-template-columns:repeat(5,1fr);
      gap:10px;
      margin-top:8px;
    }
    .pipe-node{
      position:relative;
      background:var(--surface-2);
      border:1px solid var(--line-dark);
      border-radius:12px;
      padding:12px;
      min-height:110px;
    }
    .pipe-node.core{background:var(--surface);border-color:var(--line);}
    .pipe-node.brand{
      border-color:var(--accent);
      box-shadow:0 0 0 2px rgba(232,80,2,.08) inset;
      background:
        linear-gradient(180deg, rgba(241,96,1,.06), transparent 60%),
        var(--surface);
    }
    .pipe-title{
      font-weight:900;font-size:14px;color:var(--text);letter-spacing:.2px;
    }
    .pipe-role{
      font-size:11px;color:var(--muted);margin-top:2px;font-weight:700;text-transform:uppercase;
    }
    .pipe-desc{
      margin-top:6px;font-size:13px;color:var(--text-soft);
    }

    /* arrows between nodes */
    .pipe-node:not(:last-child)::after{
      content:"";
      position:absolute;top:50%;right:-10px;transform:translateY(-50%);
      width:10px;height:2px;background:var(--text);
      opacity:.5;
    }
    .pipe-node:not(:last-child)::before{
      content:"";
      position:absolute;top:50%;right:-14px;transform:translateY(-50%) rotate(45deg);
      width:7px;height:7px;border-top:2px solid var(--text);border-right:2px solid var(--text);
      opacity:.5;background:transparent;
    }

    /* lower nodes WS/DLQ */
    .pipeline-footer{
      display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;
    }
    .pipe-sub{
      background:var(--surface-3);
      border:1px dashed var(--line-dark);
      border-radius:12px;padding:10px 12px;
    }
    .pipe-sub-title{
      font-size:12px;font-weight:900;color:var(--text);
      letter-spacing:.3px;text-transform:uppercase;
    }
    .pipe-sub-desc{
      margin-top:4px;font-size:13px;color:var(--text-soft);
    }
    .pipe-sub.ws{border-left:5px solid #111;}
    .pipe-sub.dlq{border-left:5px solid var(--danger);background:rgba(199,11,1,.05);}

    /* links */
    a{color:var(--accent);text-decoration:underline;text-decoration-color:var(--accent);}
    a:hover{color:var(--accent-2);text-decoration-color:var(--accent-2);}

    @media (max-width:900px){
      .pipeline{grid-template-columns:1fr 1fr; }
      .pipe-node:not(:last-child)::after,
      .pipe-node:not(:last-child)::before{display:none;}
    }
  /* TOC groups/capsules (added) */
header nav.toc .toc-groups{
  display:flex;
  flex-direction:column;
  gap:12px;
}
header nav.toc .toc-group__title{
  font-size:12px;
  font-weight:600;
  opacity:.6;
  margin:0 0 6px 6px;
  letter-spacing:.02em;
}
header nav.toc .toc-caps{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}
header nav.toc .toc-caps a{
  display:inline-block;
  padding:6px 10px;
  border:1px solid rgba(0,0,0,.08);
  border-radius:999px;
  font-size:12px;
  line-height:1;
  text-decoration:none;
  background:#fff;
  transition:background .15s ease, transform .15s ease, border-color .15s ease;
}
header nav.toc .toc-caps a:hover{ transform:translateY(-1px); border-color:rgba(0,0,0,.18); }
header nav.toc{ overflow:hidden; }

/* scroll-to-top button */
#scrollTopBtn{
  position:fixed;
  right:18px;
  bottom:18px;
  z-index:9999;
  padding:8px 12px;
  border-radius:999px;
  border:1px solid rgba(0,0,0,.12);
  background:#fff;
  box-shadow:0 2px 10px rgba(0,0,0,.06);
  font-size:12px;
  cursor:pointer;
  opacity:.9;
}
#scrollTopBtn:hover{ opacity:1; }

/* give some spacing so TOC doesn't overlap content */
header .brand{ margin-bottom: 8px; }

/* Fixed top header (minimal) */
header.fixed-header{
  position: fixed;
  top: 0; left: 0; right: 0;
  z-index: 2000;
  background: #fff;
  border-bottom: 1px solid rgba(0,0,0,.06);
}
body{
  /* offset for fixed header height */
  padding-top: 110px;
}
main{padding-top:8px;}

/* TOC as first content block */
.toc-firstblock{
  margin: 12px auto 20px;
  padding: 12px 0;
}
.toc-firstblock nav.toc{
  position: static;
  transform: none;
  opacity: 1;
  max-height: none;
}

/* prevent fixed header covering anchors */
section[id] { scroll-margin-top: 120px; }

</style>
</head>

<body class="toc-expanded">
  <div id="top-sentinel" style="position:absolute;top:0;height:1px;width:1px;"></div>
<header class="fixed-header">
  <div class="wrap">
    <div class="header-row">
      <div class="brand">
        <div class="brand-title">Autocontent Spec</div>
        <div class="brand-meta">v1 • структура и смысл системы</div>
        <div class="hero-line"></div>
      </div>
      <div class="actions">
        <button id="scrollTopBtn"  class="btn" id="toTop" type="button" type="button">Вверх</button>
      </div>
    </div>

    
  </div>
</header>

<main class="wrap">
<section class="toc-firstblock" id="toc">
      <h2 class="section-title">Содержание</h2>
      <nav class="toc">
<div class="toc-groups">
  <div class="toc-group">
    <div class="toc-group__title">Parts</div>
    <div class="toc-caps toc-caps--parts">
      <a href="#p1">Part 1. Введение / функционал программы</a> <a href="#p2">Part 2. Пользователи, роли и уровни фронтенда</a> <a href="#p3">Part 3. End-to-End сценарий (полный цикл)</a> <a href="#p4">Part 4. Архитектура системы и модули</a> <a href="#p5">Part 5. Данные, сущности и хранилища</a> <a href="#p6">Part 6. Очереди, воркеры и надежность pipeline</a> <a href="#p7">Part 7. Интеграции и контракты внешних сервисов</a> <a href="#p8">Part 8. API ядра и WebSocket события</a> <a href="#p9">Part 9. Контракты, схемы и версии данных</a> <a href="#p10">Part 10. State Machine карточки и переходы pipeline</a> <a href="#p11">Part 11. Reliability, SLA и эксплуатационные правила</a> <a href="#p12">Part 12. RBAC, права доступа и feature flags</a> <a href="#p13">Part 13. Схема БД, индексация и миграции</a> <a href="#p14">Part 14. Архитектура фронтенда (слои, apps, features)</a> <a href="#p15">Part 15. Правила фасада UI и дизайн-система продукта</a> <a href="#p16">Part 16. Operator UI — ключевые экраны и логика</a> <a href="#p17">Part 17. Admin UI — ключевые экраны и логика</a> <a href="#p18">Part 18. Инфраструктура, деплой и окружения</a> <a href="#p19">Part 19. Monitoring, бэкапы и Disaster Recovery</a> <a href="#p20">Part 20. Тестирование, CI/CD и контроль качества</a> <a href="#p21">Part 21. MVP-объем, roadmap и порядок реализации</a> <a href="#p22">Part 22. Глоссарий, термины и правила нейминга</a> <a href="#p23">Part 23. Правила работы с репозиторием (CONTRIBUTING)</a> <a href="#p24">Part 24. API фасад, эндпоинты и правила совместимости</a> <a href="#p25">Part 25. WS события и real-time протокол</a> <a href="#p26">Part 26. Contracts-first подход и версионирование</a> <a href="#p27">Part 27. Безопасность, приватность и compliance</a> <a href="#p28">Part 28. Производительность и масштабирование</a> <a href="#p29">Part 29. Риски, допущения и открытые решения</a> <a href="#p30">Part 30. Финальная фиксация архитектуры и резюме</a> </div>
  </div>
  <div class="toc-group">
    <div class="toc-group__title">Appendix</div>
    <div class="toc-caps toc-caps--appendix">
      <a href="#p31">Part 31. Appendix A — Сквозной сценарий (happy path) в псевдокоде</a> <a href="#p32">Part 32. Appendix B — Чек-листы запуска и приемки</a> <a href="#p33">Part 33. Appendix C — Шаблоны экранов и UI-паттерны</a> <a href="#p34">Part 34. Appendix D — Модель данных (ERD текстом)</a> <a href="#p35">Part 35. Appendix E — Таблица State Machine</a> <a href="#p36">Part 36. Appendix F — Примеры конфигов и feature flags</a> <a href="#p37">Part 37. Appendix G — Каталог ошибок и retry-политика</a> <a href="#p38">Part 38. Appendix H — Инструкции для Codex/агента</a> <a href="#p39">Part 39. Appendix I — Quick Start для новых разработчиков</a> <a href="#p40">Part 40. Appendix J — Топология деплоя и окружения</a> <a href="#p41">Part 41. Appendix K — Метрики, SLA и дашборды</a> <a href="#p42">Part 42. Appendix L — Релизы, миграции и rollback</a> <a href="#p43">Part 43. Appendix M — Phase 2: план развития и точки расширения</a> <a href="#p44">Part 44. Appendix N — Глоссарий терминов Autocontent</a> <a href="#p45">Part 45. Appendix O — Регламенты ролей и ответственности</a>
    </div>
  </div>
</div>
</nav>
    </section>


  <!-- ========================================================= -->
  <!-- Part 1 (L1): Введение / функционал программы               -->
  <!-- Наглядная геометрия + больше gray/black блоков             -->
  <!-- ========================================================= -->
  <section id="p1" class="section">
    <h2 class="section-title">
      <span class="part-number">Part 1.</span>
      Введение / функционал программы
    </h2>
    <p class="subtitle">
      Что такое Autocontent, кому он нужен и как выглядит итоговый результат конвейера.
    </p>
    <div class="level-pill">L1 — общее понимание</div>

    <!-- Definition -->
    <div class="card brand" style="margin-bottom:12px;">
      <h3>Определение</h3>
      <p>
        Autocontent — это управляемая система-конвейер, которая автоматически получает объявления
        из Auto.ru (через auto-parser.ru), нормализует их в карточки, обрабатывает фотографии
        (маскировка номеров), формирует экспортные пакеты и публикует объявления на Avito
        через внутреннего робота (Dolphin Anty → Avito).
      </p>
    </div>

    <!-- Goals / Automation / Output -->
    <div class="grid-3">
      <div class="card gray">
        <h3>Цель для отдела</h3>
        <ul>
          <li>Сократить ручной труд в подготовке объявлений.</li>
          <li>Ускорить выпуск на площадку без потери качества.</li>
          <li>Уменьшить число ошибок за счёт статусов и проверок.</li>
          <li>Сделать поток наблюдаемым и управляемым.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Что автоматизируем</h3>
        <ul>
          <li>Получение и нормализацию данных объявлений.</li>
          <li>Фото-пайплайн: маскирование и сортировка фото.</li>
          <li>Сбор экспортных пакетов (Excel/JSON).</li>
          <li>Публикацию и контроль статусов робота.</li>
          <li>Retry и DLQ для ошибок интеграций.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Что считаем результатом</h3>
        <ul>
          <li>Опубликованные объявления на Avito.</li>
          <li>Экспортные пакеты для выгрузки.</li>
          <li>История статусов/ошибок по карточкам.</li>
          <li>Админ-контроль очередей и DLQ.</li>
        </ul>
      </div>
    </div>

    <!-- Pipeline -->
    <div class="content-block">
      <h3>Конвейер</h3>

      <div class="pipeline">
        <div class="pipe-node brand">
          <div class="pipe-title">Parser</div>
          <div class="pipe-role">Вход</div>
          <div class="pipe-desc">
            Получаем JSON объявлений и raw-фото с Auto.ru через auto-parser.ru API.
          </div>
        </div>

        <div class="pipe-node core">
          <div class="pipe-title">Cards</div>
          <div class="pipe-role">Ядро / нормализация</div>
          <div class="pipe-desc">
            Создаём карточку, приводим данные к единому формату, назначаем статусы pipeline.
          </div>
        </div>

        <div class="pipe-node">
          <div class="pipe-title">Photos</div>
          <div class="pipe-role">Очередь / обработка</div>
          <div class="pipe-desc">
            Отправляем фото в Photo API, получаем masked-версии, фиксируем порядок.
          </div>
        </div>

        <div class="pipe-node">
          <div class="pipe-title">Export</div>
          <div class="pipe-role">Очередь / пакеты</div>
          <div class="pipe-desc">
            Собираем экспортные файлы из готовых карточек, сохраняем историю экспортов.
          </div>
        </div>

        <div class="pipe-node brand">
          <div class="pipe-title">Publish</div>
          <div class="pipe-role">Выход / робот</div>
          <div class="pipe-desc">
            Robot публикует на Avito через Dolphin Anty и возвращает статус размещения.
          </div>
        </div>
      </div>

      <div class="pipeline-footer">
        <div class="pipe-sub ws">
          <div class="pipe-sub-title">WS статусы</div>
          <div class="pipe-sub-desc">
            Все изменения в pipeline транслируются в UI в реальном времени
            (прогресс фото, экспортов и публикации).
          </div>
        </div>
        <div class="pipe-sub dlq">
          <div class="pipe-sub-title">DLQ ошибки</div>
          <div class="pipe-sub-desc">
            Фатальные сбои не теряются: задача попадает в DLQ, видна администратору,
            доступен ручной retry.
          </div>
        </div>
      </div>
    </div>

    <!-- Boundaries -->
    <div class="content-block">
      <h3>Границы продукта</h3>
      <div class="grid-2">
        <div class="card">
          <h3>Что входит в v1 (MVP)</h3>
          <ul>
            <li>Auto.ru через auto-parser.ru API.</li>
            <li>Карточки и жизненный цикл (pipeline-статусы).</li>
            <li>Фото-пайплайн: маскирование номеров → masked-фото.</li>
            <li>Экспорт пакетов.</li>
            <li>Публикация через Robot (Dolphin → Avito).</li>
            <li>Очереди, retry, DLQ, health-контроль.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Что не входит в v1</h3>
          <ul>
            <li>Многоисточниковый парсинг.</li>
            <li>AI-генерация / переписывание описаний.</li>
            <li>CRM / продажи / лид-менеджмент.</li>
            <li>Маркетинговая аналитика площадок.</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Artifacts -->
    <div class="content-block">
      <h3>Артефакты на стадиях</h3>
      <table class="table">
        <thead>
          <tr>
            <th>Шаг</th>
            <th>Артефакт</th>
            <th>Где лежит</th>
            <th>Зачем фиксируем</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Parser</strong></td>
            <td>CardDraft + raw-фото</td>
            <td>DB.cards + Storage/raw</td>
            <td>Стартовый пакет данных, исходник для карточки.</td>
          </tr>
          <tr>
            <td><strong>Cards</strong></td>
            <td>Card (единая сущность)</td>
            <td>DB.cards (+audit)</td>
            <td>Источник правды по объявлению и статусы pipeline.</td>
          </tr>
          <tr>
            <td><strong>Photos</strong></td>
            <td>Masked-фото + порядок</td>
            <td>DB.photos + Storage/masked</td>
            <td>Готовый медиаконтент без номеров.</td>
          </tr>
          <tr>
            <td><strong>Export</strong></td>
            <td>Export-пакет</td>
            <td>DB.exports + Storage/exports</td>
            <td>Выгрузка для публикации и отчётности.</td>
          </tr>
          <tr>
            <td><strong>Publish</strong></td>
            <td>PublishJob + статусы</td>
            <td>DB.publish_jobs + Avito</td>
            <td>Фиксация результата размещения и ошибок робота.</td>
          </tr>
        </tbody>
      </table>
      <p class="muted small">
        Детальные статусы и переходы фиксируются в Part 10 (State Machine).
      </p>
    </div>

    <!-- MVP checklist -->
    <div class="content-block">
      <h3>Критерии успеха MVP</h3>
      <div class="card gray">
        <ol>
          <li>Карточка создаётся автоматически из входа парсера (draft).</li>
          <li>Фото маскируются и появляются как masked-набор.</li>
          <li>Оператор проверяет/исправляет и ставит “готово к экспорту”.</li>
          <li>Экспортный пакет создаётся и доступен для выгрузки.</li>
          <li>Публикация запускается роботом и возвращает статус.</li>
          <li>Ошибки видны и не теряются: статус + DLQ.</li>
        </ol>
      </div>

      <details>
        <summary>Что появится позже</summary>
        <ul>
          <li>Многоисточниковый парсинг.</li>
          <li>AI-редактор и генерация описаний.</li>
          <li>Аналитика эффективности Avito.</li>
        </ul>
      </details>
    </div>

    <!-- Final callouts -->
    <div class="callout accepted">
      <strong>Утверждено:</strong>
      Autocontent — pipeline-система, автоматизирующая путь
      от Auto.ru до публикаций Avito с прозрачными стадиями и контролем ошибок.
    </div>

    <div class="callout open">
      <strong>Открытые вопросы:</strong>
      формат входа auto-parser.ru и полный набор полей карточки фиксируем в Part 9.
    </div>
  </section>

<!-- ========================================================= -->
<!-- Part 2 (L1): Пользователи, роли и уровни фронтенда         -->
<!-- Продолжаем в том же стиле (light + gray/black structure)   -->
<!-- ========================================================= -->
<section id="p2" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 2.</span>
    Пользователи, роли и уровни фронтенда
  </h2>
  <p class="subtitle">
    Кто работает в системе, какие у них цели, права и как это отражается в двух уровнях UI.
  </p>
  <div class="level-pill">L1 — общее понимание</div>

  <!-- Definition -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Смысл ролевой модели</h3>
    <p>
      Роли определяют доступ к стадиям pipeline и к административным функциям.
      На фронтенде это выражено отдельными приложениями: <strong>Operator UI</strong> (рабочее)
      и <strong>Admin UI</strong> (управление системой). Один пользователь может иметь несколько ролей,
      но интерфейс и доступы формируются по активной роли.
    </p>
  </div>

  <!-- Roles overview -->
  <div class="grid-3">
    <div class="card gray">
      <h3>Operator (Оператор)</h3>
      <ul>
        <li>Работает с карточками и их качеством.</li>
        <li>Запускает/контролирует стадии Photos, Export, Publish.</li>
        <li>Исправляет данные, фото, описания внутри карточки.</li>
        <li>Видит статусы pipeline по своим карточкам.</li>
      </ul>
      <p class="muted small" style="margin-top:6px;">
        Цель: довести карточку до публикации без технических действий “вручную”.
      </p>
    </div>

    <div class="card gray">
      <h3>Admin (Администратор)</h3>
      <ul>
        <li>Управляет очередями, ретраями и DLQ.</li>
        <li>Смотрит логи, метрики, health интеграций.</li>
        <li>Управляет пользователями и ролями.</li>
        <li>Может вручную перекидывать задачи между статусами.</li>
      </ul>
      <p class="muted small" style="margin-top:6px;">
        Цель: стабильность потока и скорость восстановления при сбоях.
      </p>
    </div>

    <div class="card gray">
      <h3>Superadmin / Owner (Руководитель)</h3>
      <ul>
        <li>Имеет полный доступ ко всем разделам.</li>
        <li>Утверждает настройки интеграций и фичефлаги.</li>
        <li>Смотрит отчёты по эффективности pipeline.</li>
      </ul>
      <p class="muted small" style="margin-top:6px;">
        Цель: контроль продукта и его бизнес-эффекта.
      </p>
    </div>
  </div>

  <!-- Frontend levels -->
  <div class="content-block">
    <h3>Два уровня фронтенда</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Operator UI (рабочий контур)</h3>
        <ul>
          <li>Ежедневная работа с карточками.</li>
          <li>Таблица карточек + фильтры + групповые действия.</li>
          <li>Просмотр/правка данных и фото.</li>
          <li>Запуск export/publish, контроль прогресса.</li>
          <li>Получение live-статусов через WS.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Точка входа: <code>frontend/src/apps/operator</code>.
        </p>
      </div>

      <div class="card">
        <h3>Admin UI (системный контур)</h3>
        <ul>
          <li>Очереди: текущее состояние, скорость, ретраи.</li>
          <li>DLQ: список упавших задач, причины, ручной retry.</li>
          <li>Логи и аудит действий.</li>
          <li>Интеграции: статусы Parser / Photo API / Storage / Dolphin.</li>
          <li>Пользователи и роли.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Точка входа: <code>frontend/src/apps/admin</code>.
        </p>
      </div>
    </div>
  </div>

  <!-- Permissions matrix (simple L1) -->
  <div class="content-block">
    <h3>Матрица доступов (L1)</h3>
    <table class="table">
      <thead>
        <tr>
          <th>Секция / действие</th>
          <th>Operator</th>
          <th>Admin</th>
          <th>Superadmin/Owner</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Cards: просмотр и фильтры</strong></td>
          <td>Да</td><td>Да</td><td>Да</td>
        </tr>
        <tr>
          <td><strong>Cards: правка данных/фото</strong></td>
          <td>Да</td><td>Ограниченно*</td><td>Да</td>
        </tr>
        <tr>
          <td><strong>Photos / Export / Publish запуск</strong></td>
          <td>Да</td><td>Да</td><td>Да</td>
        </tr>
        <tr>
          <td><strong>Queues / Retry / DLQ</strong></td>
          <td>Нет</td><td>Да</td><td>Да</td>
        </tr>
        <tr>
          <td><strong>Integrations health/config</strong></td>
          <td>Нет</td><td>Да (health)</td><td>Да (health+config)</td>
        </tr>
        <tr>
          <td><strong>Users / Roles управление</strong></td>
          <td>Нет</td><td>Да</td><td>Да</td>
        </tr>
      </tbody>
    </table>
    <p class="muted small">
      * Admin может корректировать карточку только при разборе аварийных случаев (например, ручное снятие блокировки).
      Подробная матрица прав будет расширена в Part 12 (RBAC).
    </p>
  </div>

  <!-- Role switching -->
  <div class="content-block">
    <h3>Переключение и наследование ролей</h3>
    <div class="card gray">
      <ul>
        <li>Роль назначается пользователю в Admin UI.</li>
        <li>При входе пользователь попадает в интерфейс своей основной роли.</li>
        <li>Если ролей несколько — доступно переключение “режима” (Operator ↔ Admin).</li>
        <li>Сессия и токены общие, но права проверяются на уровне бэкенда и фронта.</li>
      </ul>
    </div>
  </div>

  <!-- Accepted / Open -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    В системе есть минимум три роли (Operator, Admin, Superadmin), а фронтенд разделён на два контура:
    рабочий (Operator UI) и системный (Admin UI).
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    детальная RBAC-матрица и edge-кейсы (например, оператор с ограниченным publish) — Part 12.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 3 (L1): End-to-End сценарий работы системы            -->
<!-- Продолжаем стиль: light + gray/black структура + ~15% бренд -->
<!-- ========================================================= -->
<section id="p3" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 3.</span>
    End-to-End сценарий (полный цикл)
  </h2>
  <p class="subtitle">
    Как одна карточка проходит весь путь: от входа из Auto.ru до публикации на Avito и контроля статусов.
  </p>
  <div class="level-pill">L1 — общий жизненный цикл</div>

  <!-- Scenario overview -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Суть E2E</h3>
    <p>
      End-to-End сценарий описывает “идеальный” поток без ручных обходов:
      система сама создаёт карточку, подготавливает фото, формирует экспорт, публикует,
      а оператор и админ видят прогресс и вмешиваются только при необходимости.
    </p>
  </div>

  <!-- Steps as a readable timeline -->
  <div class="content-block">
    <h3>Этапы цикла</h3>

    <div style="display:grid; gap:8px;">
      <div class="card gray">
        <h3 style="font-size:14px;">0. Триггер парсинга</h3>
        <p>
          Внешний Parser (auto-parser.ru) по расписанию/запросу достаёт объявления Auto.ru
          и пушит их в Autocontent.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Артефакт: входной JSON + raw-фото.
        </p>
      </div>

      <div class="card gray">
        <h3 style="font-size:14px;">1. Создание карточки (Cards.draft)</h3>
        <p>
          Ядро принимает входные данные, нормализует поля и создаёт Card в статусе
          <strong>draft</strong>. Карточка появляется в Operator UI.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Источник правды: DB.cards.
        </p>
      </div>

      <div class="card gray">
        <h3 style="font-size:14px;">2. Запуск фото-пайплайна</h3>
        <p>
          Система кладёт PhotoJob в очередь. Worker забирает задачу, отправляет raw-фото
          в Photo API, получает masked-версии и сохраняет их в Storage.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Статусы фото транслируются в UI через WS.
        </p>
      </div>

      <div class="card gray">
        <h3 style="font-size:14px;">3. Проверка оператором</h3>
        <p>
          Оператор открывает карточку, проверяет корректность данных и фото,
          при необходимости правит, после чего переводит карточку в статус
          <strong>ready_for_export</strong>.
        </p>
        <p class="muted small" style="margin-top:6px;">
          В этот момент карточка считается “готовой к упаковке”.
        </p>
      </div>

      <div class="card gray">
        <h3 style="font-size:14px;">4. Формирование экспортного пакета</h3>
        <p>
          ExportWorker формирует пакет (Excel/JSON) из выбранных карточек,
          сохраняет его в Storage и фиксирует запись в DB.exports.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Карточка получает статус: <strong>exported</strong>.
        </p>
      </div>

      <div class="card gray">
        <h3 style="font-size:14px;">5. Публикация роботом</h3>
        <p>
          PublishWorker создаёт PublishJob и вызывает Robot.
          Robot через Dolphin Anty открывает Avito и размещает объявление,
          возвращая статус выполнения.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Итог: <strong>published</strong> или <strong>publish_failed</strong>.
        </p>
      </div>

      <div class="card gray">
        <h3 style="font-size:14px;">6. Контроль статусов и завершение</h3>
        <p>
          Система продолжает опрашивать Robot/Avito по статусам публикации,
          обновляет карточку и показывает финальное состояние в UI.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Все изменения пишутся в audit-log.
        </p>
      </div>
    </div>
  </div>

  <!-- Happy path vs Fail path -->
  <div class="content-block">
    <h3>Два варианта исхода</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Happy Path</h3>
        <ol>
          <li>Parser → draft.</li>
          <li>Фото обработаны → photos_ready.</li>
          <li>Оператор подтвердил → ready_for_export.</li>
          <li>Export создан → exported.</li>
          <li>Robot опубликовал → published.</li>
        </ol>
      </div>

      <div class="card">
        <h3>Fail Path</h3>
        <ol>
          <li>Ошибка внешнего сервиса / таймаут / невалидные данные.</li>
          <li>Задача ретраится по RetryPolicy.</li>
          <li>Если лимит исчерпан → DLQ.</li>
          <li>Admin видит DLQ, чинит причину, делает retry.</li>
        </ol>
        <p class="muted small" style="margin-top:6px;">
          Важное правило: карточка никогда не “пропадает”, она либо в статусе, либо в DLQ.
        </p>
      </div>
    </div>
  </div>

  <!-- Status progression strip -->
  <div class="content-block">
    <h3>Лента статусов карточки (L1)</h3>
    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      draft
      → photos_processing
      → photos_ready
      → ready_for_export
      → exporting
      → exported
      → publishing
      → published
    </div>
    <p class="muted small" style="margin-top:6px;">
      Точная state machine с переходами, ретраями и guard-условиями — Part 10.
    </p>
  </div>

  <!-- System responsibilities -->
  <div class="content-block">
    <h3>Ответственность системы и людей</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Система делает сама</h3>
        <ul>
          <li>Принимает вход из Parser.</li>
          <li>Создаёт карточку и статусы.</li>
          <li>Гоняет фоновые очереди (Photos/Export/Publish).</li>
          <li>Хранит фото и пакеты.</li>
          <li>Логирует ошибки, ретраит, складывает в DLQ.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Человек делает точечно</h3>
        <ul>
          <li>Оператор проверяет качество карточки и фото.</li>
          <li>Оператор подтверждает готовность к экспорту/публикации.</li>
          <li>Admin вмешивается только при DLQ/сбоях интеграций.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Accepted / Open -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Полный E2E-цикл карточки проходит через Parser → Cards → Photos → Export → Publish
    с live-статусами в UI и DLQ для фатальных ошибок.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    SLA по каждому этапу, лимиты ретраев и форматы ошибок формализуем в Part 11 (Reliability).
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 4 (L1): Архитектура системы и модули                 -->
<!-- Объясняет "из чего состоит" и как связи устроены          -->
<!-- ========================================================= -->
<section id="p4" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 4.</span>
    Архитектура системы и модули
  </h2>
  <p class="subtitle">
    Из каких частей состоит Autocontent, что является ядром, что — внешними сервисами,
    и как они связываются между собой.
  </p>
  <div class="level-pill">L1 — контейнерный уровень</div>

  <!-- Архитектурная идея -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Архитектурная идея</h3>
    <p>
      Autocontent построен как <strong>ядро (backend)</strong> + набор <strong>адаптеров</strong>
      к внешним сервисам. Даже если сервисы физически на нашем сервере (Photo API, Storage),
      логически они считаются внешними: ядро общается с ними только по контрактам.
      Это даёт заменяемость интеграций без переписывания бизнес-логики.
    </p>
  </div>

  <!-- Контейнеры -->
  <div class="content-block">
    <h3>Контейнеры системы</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Backend (ядро)</h3>
        <ul>
          <li>Единая бизнес-логика pipeline.</li>
          <li>Хранилище карточек и статусов (DB).</li>
          <li>Очереди, ретраи, DLQ.</li>
          <li>Адаптеры к интеграциям.</li>
          <li>API для Operator/Admin UI.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Репо: <code>backend/</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Workers (фоновые процессы)</h3>
        <ul>
          <li>ParserWorker — приём/обновление карточек.</li>
          <li>PhotoWorker — обработка фото.</li>
          <li>ExportWorker — сбор пакетов.</li>
          <li>PublishWorker — публикация.</li>
          <li>StatusWorker — синхронизация статусов робота/Avito.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Репо: <code>backend/src/Workers</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Frontend (2 контура)</h3>
        <ul>
          <li>Operator UI — рабочий контур.</li>
          <li>Admin UI — системный контур.</li>
          <li>Shared слой API/Store/Guard’ов.</li>
          <li>Design слой UI-kit.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Репо: <code>frontend/</code>
        </p>
      </div>
    </div>
  </div>

  <!-- Внешние сервисы -->
  <div class="content-block">
    <h3>Внешние сервисы (логически External)</h3>

    <div class="grid-3">
      <div class="card">
        <h3>Parser API</h3>
        <p>
          auto-parser.ru даёт готовый парсинг Auto.ru и отдаёт объявления
          в виде JSON + raw фото.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Адаптер: <code>backend/src/Adapters/ParserAdapter.php</code>
        </p>
      </div>

      <div class="card">
        <h3>Photo API (on-prem)</h3>
        <p>
          Наш сервис маскировки номеров.
          Принимает raw фото → возвращает masked фото.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Адаптер: <code>PhotoApiAdapter.php</code>
        </p>
      </div>

      <div class="card">
        <h3>Storage (on-prem S3)</h3>
        <p>
          S3-совместимое хранилище (MinIO/on-prem).
          Границы: raw/ masked/ exports/.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Адаптер: <code>S3Adapter.php</code>
        </p>
      </div>
    </div>

    <div class="grid-3">
      <div class="card">
        <h3>Dolphin Anty API</h3>
        <p>
          Внешний антибраузер: профили/сессии, через которые Robot
          идёт на Avito.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Адаптер: <code>DolphinAdapter.php</code>
        </p>
      </div>

      <div class="card">
        <h3>Robot Service (внутренний)</h3>
        <p>
          Реализация робота внутри проекта, но спрятана за интерфейсом адаптера.
          Для ядра это “чёрный ящик публикации”.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Адаптер: <code>RobotAdapter.php</code>
        </p>
      </div>

      <div class="card">
        <h3>Avito</h3>
        <p>
          Целевая площадка. Robot публикует карточки и читает статусы.
          Ядро хранит маппинг статусов Avito → pipeline.
        </p>
        <p class="muted small" style="margin-top:6px;">
          Адаптер: <code>AvitoAdapter.php</code>
        </p>
      </div>
    </div>
  </div>

  <!-- Связи и потоки -->
  <div class="content-block">
    <h3>Главные связи между модулями</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      ParserAdapter → CardsModule(draft)
      → Queues(Photos/Export/Publish)
      → Workers
      → PhotoApiAdapter / S3Adapter / RobotAdapter / DolphinAdapter / AvitoAdapter
      → CardsModule(status update)
      → WS → Frontend apps
    </div>

    <p class="muted small" style="margin-top:6px;">
      На L1 важно: ядро не знает деталей внешних сервисов; оно знает только их интерфейсы и контракты.
    </p>
  </div>

  <!-- Модульная структура ядра -->
  <div class="content-block">
    <h3>Модульная структура ядра (backend)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Доменные модули</h3>
        <ul>
          <li><strong>Cards</strong> — центр системы, статусы pipeline.</li>
          <li>Parser — приём и нормализация входа.</li>
          <li>Photos — правила фото-пайплайна.</li>
          <li>Export — генерация пакетов.</li>
          <li>Publish — оркестрация публикаций.</li>
          <li>Robot — внутренняя логика робота.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Системные модули</h3>
        <ul>
          <li>Auth / Users — доступ и роли.</li>
          <li>Queues — очередь, retry, DLQ.</li>
          <li>WS — live-ивенты в UI.</li>
          <li>Admin — health, логи, DLQ-интерфейс.</li>
          <li>Utils — state machine, idempotency, locks.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Архитектура строится вокруг backend-ядра и адаптеров к логически внешним сервисам.
    Frontend разделён на Operator/Admin контуры, а pipeline исполняется через очереди и воркеры.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    детальные контракты интеграций и формат событий WS фиксируем в Part 7 и Part 8.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 5 (L1): Данные, сущности и хранилища                 -->
<!-- Что является "объектами системы", где живёт и как связано -->
<!-- ========================================================= -->
<section id="p5" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 5.</span>
    Данные, сущности и хранилища
  </h2>
  <p class="subtitle">
    Какие основные сущности есть в Autocontent, что они содержат и где физически хранятся.
  </p>
  <div class="level-pill">L1 — модель данных сверху</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Идея модели данных</h3>
    <p>
      Система строится вокруг одной центральной сущности — <strong>Card</strong>.
      Все остальные сущности (Photos, Export, PublishJob, AuditLog) либо
      “принадлежат карточке”, либо описывают её обработку на стадиях pipeline.
    </p>
  </div>

  <!-- Entities overview -->
  <div class="content-block">
    <h3>Сущности системы</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Card</h3>
        <ul>
          <li>Единый объект объявления.</li>
          <li>Нормализованные поля Auto.ru.</li>
          <li>Текущий статус pipeline.</li>
          <li>Ссылки на фото, экспорт, публикации.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Владелец цикла: CardsModule.
        </p>
      </div>

      <div class="card gray">
        <h3>Photo</h3>
        <ul>
          <li>Набор фото одной карточки.</li>
          <li>raw → masked → порядок.</li>
          <li>Статус обработки каждого фото.</li>
          <li>Ошибки/ретраи по фото.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Владелец цикла: PhotosModule.
        </p>
      </div>

      <div class="card gray">
        <h3>Export</h3>
        <ul>
          <li>Пакет выгрузки из N карточек.</li>
          <li>Формат: Excel/JSON.</li>
          <li>Версия/дата/автор.</li>
          <li>Ссылка на файл в Storage.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Владелец цикла: ExportModule.
        </p>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>PublishJob</h3>
        <ul>
          <li>Задача публикации одной карточки.</li>
          <li>Текущий статус робота/Avito.</li>
          <li>Retry/ошибки/история.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Владелец цикла: PublishModule.
        </p>
      </div>

      <div class="card gray">
        <h3>QueueJob (системная)</h3>
        <ul>
          <li>Задача фоновой обработки.</li>
          <li>Тип: photo/export/publish/parser/status.</li>
          <li>RetryPolicy + DLQ-ссылка.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Владелец: Queues subsystem.
        </p>
      </div>

      <div class="card gray">
        <h3>AuditLog (системная)</h3>
        <ul>
          <li>Все изменения карточек и действий пользователей.</li>
          <li>Кто/когда/что изменил.</li>
          <li>Для расследований и отчетов.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Владелец: Logger/AuditLogger.
        </p>
      </div>
    </div>
  </div>

  <!-- Storage -->
  <div class="content-block">
    <h3>Хранилища</h3>
    <div class="grid-2">
      <div class="card">
        <h3>DB (PostgreSQL/MySQL)</h3>
        <ul>
          <li>Cards</li>
          <li>Photos metadata</li>
          <li>Exports metadata</li>
          <li>PublishJobs</li>
          <li>Queues / DLQ</li>
          <li>Users / Roles</li>
          <li>Audit logs</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          DB — источник правды по статусам и истории.
        </p>
      </div>

      <div class="card">
        <h3>S3 Storage (MinIO/on-prem)</h3>
        <ul>
          <li><strong>raw/</strong> — исходные фото из Parser.</li>
          <li><strong>masked/</strong> — фото после Photo API.</li>
          <li><strong>exports/</strong> — экспортные пакеты.</li>
          <li><strong>tmp/</strong> — временные файлы воркеров.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Storage хранит тяжёлые бинарные данные, DB хранит ссылки.
        </p>
      </div>
    </div>
  </div>

  <!-- Relationships -->
  <div class="content-block">
    <h3>Связи сущностей (L1)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Связь</th>
          <th>Тип</th>
          <th>Смысл</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Card → Photos</strong></td>
          <td>1 : N</td>
          <td>У одной карточки множество фото (raw/masked).</td>
        </tr>
        <tr>
          <td><strong>Card → PublishJobs</strong></td>
          <td>1 : N</td>
          <td>Одна карточка может публиковаться несколько раз (повторные попытки/переиздания).</td>
        </tr>
        <tr>
          <td><strong>Export → Cards</strong></td>
          <td>N : N</td>
          <td>Пакет состоит из набора карточек; одна карточка может попасть в несколько экспортов.</td>
        </tr>
        <tr>
          <td><strong>QueueJob → Card/Photo/Export/PublishJob</strong></td>
          <td>N : 1</td>
          <td>Каждая задача очереди ссылается на целевой доменный объект.</td>
        </tr>
        <tr>
          <td><strong>AuditLog → *</strong></td>
          <td>N : 1</td>
          <td>Аудит относится к конкретной сущности и фиксирует её изменение.</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Minimal payload idea -->
  <div class="content-block">
    <h3>Минимальный состав Card (L1)</h3>
    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      Card = {
        id,
        source: "auto_ru",
        source_id,
        status,               // pipeline status
        vehicle: { make, model, year, body, mileage, vin? },
        price: { value, currency },
        location: { city, address?, coords? },
        description,
        photos: [ {id, raw_url, masked_url, order, status} ],
        export_refs: [export_id...],
        publish_refs: [publish_job_id...],
        created_at, updated_at
      }
    </div>
    <p class="muted small" style="margin-top:6px;">
      Полный контракт Card, все поля Auto.ru и правила валидации — Part 9 (Contracts & Schemas).
    </p>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Центральная сущность — Card. Остальные сущности обслуживают её pipeline,
    а тяжёлые файлы живут в S3 Storage, метаданные и статусы — в DB.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точная схема БД и индексация под фильтры Operator UI — Part 13 (DB Schema).
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 6 (L1): Очереди, воркеры и надежность pipeline        -->
<!-- Как выполняются фоновые стадии, ретраи и DLQ               -->
<!-- ========================================================= -->
<section id="p6" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 6.</span>
    Очереди, воркеры и надежность pipeline
  </h2>
  <p class="subtitle">
    Как фоновые стадии выполняются асинхронно, как устроены ретраи и почему карточки не “теряются”.
  </p>
  <div class="level-pill">L1 — уровень исполнения</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Идея надежности</h3>
    <p>
      Все тяжёлые и нестабильные операции (фото, экспорт, публикация, синхронизация статусов)
      выполняются через очередь и воркеры. Это отделяет UI и ядро от задержек и сбоев внешних сервисов,
      а также позволяет масштабировать нужную стадию отдельно.
    </p>
  </div>

  <!-- Why queues -->
  <div class="content-block">
    <h3>Почему всё через очередь</h3>
    <div class="grid-3">
      <div class="card gray">
        <h3>Стабильность</h3>
        <ul>
          <li>Внешние API могут падать или тормозить.</li>
          <li>Очередь сглаживает пики и даёт ретраи.</li>
          <li>UI не блокируется долгими задачами.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Масштабирование</h3>
        <ul>
          <li>Можно добавлять воркеры только для узкого места.</li>
          <li>Например, увеличить PhotoWorker без влияния на Publish.</li>
          <li>Поддержка параллельной обработки.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Прозрачность</h3>
        <ul>
          <li>Каждая задача видна по статусу.</li>
          <li>Есть история, ошибки и попытки.</li>
          <li>DLQ фиксирует фатальные сбои.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Queues types -->
  <div class="content-block">
    <h3>Типы очередей</h3>
    <table class="table">
      <thead>
        <tr>
          <th>Очередь</th>
          <th>Что обрабатывает</th>
          <th>Кто потребляет</th>
          <th>Результат</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>photos</strong></td>
          <td>Маскирование и подготовка фото</td>
          <td>PhotoWorker</td>
          <td>masked-фото + статус photos_ready</td>
        </tr>
        <tr>
          <td><strong>export</strong></td>
          <td>Формирование экспортных пакетов</td>
          <td>ExportWorker</td>
          <td>export-файл + статус exported</td>
        </tr>
        <tr>
          <td><strong>publish</strong></td>
          <td>Публикация карточек</td>
          <td>PublishWorker</td>
          <td>объявление на Avito + статус published/publish_failed</td>
        </tr>
        <tr>
          <td><strong>parser</strong></td>
          <td>Приём входа от Parser API</td>
          <td>ParserWorker</td>
          <td>CardDraft → Card(draft)</td>
        </tr>
        <tr>
          <td><strong>robot_status</strong></td>
          <td>Синхронизация статусов робота/Avito</td>
          <td>RobotStatusWorker</td>
          <td>обновление publish-статусов</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Execution model -->
  <div class="content-block">
    <h3>Модель исполнения задач (L1)</h3>
    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      QueueJob = {
        id,
        type: ["photos" | "export" | "publish" | "parser" | "robot_status"],
        entity_ref: { entity: "card|photo|export|publish_job", id },
        payload,
        attempts,
        next_retry_at,
        status: ["queued" | "processing" | "retrying" | "done" | "dead"],
        last_error?
      }
    </div>
    <p class="muted small" style="margin-top:6px;">
      Реализация очереди: MVP — DB-очередь, прод — Redis/брокер. Интерфейс один и тот же.
    </p>
  </div>

  <!-- Retry & DLQ -->
  <div class="content-block">
    <h3>RetryPolicy и DLQ</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Как работает retry</h3>
        <ol>
          <li>Worker берёт задачу и помечает processing.</li>
          <li>При ошибке задача получает attempts+1.</li>
          <li>Если attempts &lt; лимита — ставится next_retry_at.</li>
          <li>Backoff растущий (например 1м → 5м → 15м → 1ч).</li>
          <li>После успешного выполнения — done.</li>
        </ol>
        <p class="muted small" style="margin-top:6px;">
          Лимиты и backoff фиксируем в Part 11 (Reliability SLA).
        </p>
      </div>

      <div class="card">
        <h3>Когда задача уходит в DLQ</h3>
        <ul>
          <li>Исчерпан лимит attempts.</li>
          <li>Получена фатальная ошибка (невалидный контракт, запрет Avito, etc.).</li>
          <li>Сервис системно недоступен дольше допустимого SLA.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          DLQ доступен в Admin UI: причина, payload, кнопка retry.
        </p>
      </div>
    </div>
  </div>

  <!-- Idempotency -->
  <div class="content-block">
    <h3>Идемпотентность и защита от дублей</h3>
    <div class="card gray">
      <ul>
        <li>Каждая задача привязана к entity_ref и имеет уникальный ключ идемпотентности.</li>
        <li>Worker проверяет ключ перед выполнением.</li>
        <li>Повторное выполнение не создаёт дубли (фото/экспорты/публикации).</li>
      </ul>
    </div>
    <p class="muted small">
      Точные ключи и правила идемпотентности описываем в Part 10 и Part 13.
    </p>
  </div>

  <!-- Observability -->
  <div class="content-block">
    <h3>Наблюдаемость</h3>
    <div class="grid-2">
      <div class="card gray">
        <h3>Operator UI видит</h3>
        <ul>
          <li>Текущий статус карточки.</li>
          <li>Прогресс стадий (photos/export/publish).</li>
          <li>Человекочитаемые ошибки.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Admin UI видит</h3>
        <ul>
          <li>Очереди: глубина, скорость, ошибки.</li>
          <li>DLQ: упавшие задачи и причины.</li>
          <li>Health внешних сервисов.</li>
          <li>Аудит действий пользователей.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Тяжёлые стадии pipeline выполняются через очереди и воркеры с RetryPolicy и DLQ.
    Это обеспечивает масштабирование и гарантирует, что карточки не теряются.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точные SLA каждой очереди, лимиты attempts и backoff — Part 11.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 7 (L1): Интеграции и контракты внешних сервисов       -->
<!-- Что именно интегрируем, по каким правилам и где границы    -->
<!-- ========================================================= -->
<section id="p7" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 7.</span>
    Интеграции и контракты внешних сервисов
  </h2>
  <p class="subtitle">
    Какие сервисы считаются внешними, какие данные они принимают/отдают,
    и как ядро изолируется от их реализаций.
  </p>
  <div class="level-pill">L1 — обзор интеграционного слоя</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип интеграций</h3>
    <p>
      Все интеграции проходят через слой <strong>Adapters</strong>.
      Ядро знает только интерфейс адаптера и контракт данных.
      Это позволяет менять: auto-parser.ru → другой парсер, MinIO → Yandex S3,
      Photo API → другой маскер, Dolphin → другой антибраузер
      без переписывания доменной логики pipeline.
    </p>
  </div>

  <!-- Integrations list -->
  <div class="content-block">
    <h3>Список интеграций</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Parser API</h3>
        <ul>
          <li>Источник: Auto.ru через auto-parser.ru.</li>
          <li>Формат: JSON объявлений + raw фото.</li>
          <li>Режим: push/poll (настройка).</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Adapter: <code>ParserAdapter.php</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Photo API (on-prem)</h3>
        <ul>
          <li>Вход: raw фото + параметры маскировки.</li>
          <li>Выход: masked фото + метаданные.</li>
          <li>Режим: async через очередь photos.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Adapter: <code>PhotoApiAdapter.php</code>
        </p>
      </div>

      <div class="card gray">
        <h3>S3 Storage (on-prem)</h3>
        <ul>
          <li>Пути: raw/ masked/ exports/ tmp/.</li>
          <li>Операции: put/get/presign/list.</li>
          <li>Соглашение по именам файлов.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Adapter: <code>S3Adapter.php</code>
        </p>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>Dolphin Anty API</h3>
        <ul>
          <li>Профили/сессии/браузеры.</li>
          <li>Robot использует как транспорт.</li>
          <li>Ядро видит только статусы и ошибки.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Adapter: <code>DolphinAdapter.php</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Robot Service</h3>
        <ul>
          <li>Внутренняя реализация публикации.</li>
          <li>Вход: Card + ExportPackage.</li>
          <li>Выход: PublishResult + Avito status.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Adapter: <code>RobotAdapter.php</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Avito</h3>
        <ul>
          <li>Площадка размещения.</li>
          <li>Контакты/поля Avito маппятся ядром.</li>
          <li>Статусы Avito нормализуются.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Adapter: <code>AvitoAdapter.php</code>
        </p>
      </div>
    </div>
  </div>

  <!-- Contracts -->
  <div class="content-block">
    <h3>Контракты данных (L1)</h3>
    <table class="table">
      <thead>
        <tr>
          <th>Интеграция</th>
          <th>Вход в ядро</th>
          <th>Выход из ядра</th>
          <th>Где формализуем</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Parser API</strong></td>
          <td>ParserPush: AutoRuAd + photos[]</td>
          <td>ParserAck / ParserPoll</td>
          <td><code>external/parser/contracts</code></td>
        </tr>
        <tr>
          <td><strong>Photo API</strong></td>
          <td>PhotoProcess: raw_url + mask_params</td>
          <td>PhotoResult: masked_url + meta</td>
          <td><code>external/photo-api/contracts</code></td>
        </tr>
        <tr>
          <td><strong>S3 Storage</strong></td>
          <td>S3Put/S3Get/S3Presign</td>
          <td>URLs + keys</td>
          <td><code>external/storage/contracts</code></td>
        </tr>
        <tr>
          <td><strong>Dolphin API</strong></td>
          <td>ProfileStart / ProfileStop</td>
          <td>ProfileStatus</td>
          <td><code>external/dolphin/contracts</code></td>
        </tr>
        <tr>
          <td><strong>Robot</strong></td>
          <td>PublishRequest: Card + media</td>
          <td>PublishResult</td>
          <td><code>backend/src/Modules/Robot</code></td>
        </tr>
        <tr>
          <td><strong>Avito</strong></td>
          <td>robot→avito payload</td>
          <td>AvitoStatus</td>
          <td><code>external/avito/contracts</code></td>
        </tr>
      </tbody>
    </table>
    <p class="muted small" style="margin-top:6px;">
      На L1 фиксируем только направления и типы контрактов. Точные схемы — Part 9.
    </p>
  </div>

  <!-- Error normalization -->
  <div class="content-block">
    <h3>Нормализация ошибок</h3>
    <div class="card gray">
      <ul>
        <li>Каждый адаптер преобразует ошибки внешнего сервиса в общий формат <code>IntegrationError</code>.</li>
        <li>Ядро принимает решения: retry / fail / DLQ независимо от источника ошибки.</li>
        <li>Operator UI показывает человекочитаемое сообщение, Admin UI — техдетали.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Все внешние сервисы изолированы через Adapters и формальные контракты.
    Ошибки приводятся к общему формату, pipeline управляет retry/DLQ независимо от сервиса.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точные JSON-схемы, обязательность полей и версии контрактов — Part 9.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 8 (L1): API ядра и WebSocket события для UI           -->
<!-- Что отдаёт backend фронту и как идут live-статусы          -->
<!-- ========================================================= -->
<section id="p8" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 8.</span>
    API ядра и WebSocket события
  </h2>
  <p class="subtitle">
    Какие интерфейсы предоставляет backend для Operator/Admin UI
    и как UI получает обновления pipeline в реальном времени.
  </p>
  <div class="level-pill">L1 — интерфейсный слой</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип интерфейсов</h3>
    <p>
      Backend отдаёт фронтенду <strong>HTTP API</strong> для действий и запросов
      и <strong>WS</strong> для живых событий pipeline.  
      UI никогда не “угадывает” состояние — он получает его из ядра
      и подписывается на изменения.
    </p>
  </div>

  <!-- HTTP API groups -->
  <div class="content-block">
    <h3>Группы HTTP API (L1)</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Auth / Users</h3>
        <ul>
          <li>login / refresh / logout</li>
          <li>me (профиль)</li>
          <li>users CRUD (admin)</li>
          <li>roles assign (admin)</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Модули: <code>Modules/Auth</code>, <code>Modules/Users</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Cards (центр)</h3>
        <ul>
          <li>cards.list (фильтры/поиск)</li>
          <li>cards.get</li>
          <li>cards.update</li>
          <li>cards.status.set</li>
          <li>cards.bulk</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Модуль: <code>Modules/Cards</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Photos / Export / Publish</h3>
        <ul>
          <li>photos.start / photos.retry</li>
          <li>export.create / export.download</li>
          <li>publish.start / publish.retry</li>
          <li>publish.status</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Модули: <code>Photos</code>, <code>Export</code>, <code>Publish</code>
        </p>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>Admin / System</h3>
        <ul>
          <li>queues.list / queues.pause / queues.resume</li>
          <li>dlq.list / dlq.retry / dlq.drop</li>
          <li>health.integrations</li>
          <li>logs.search</li>
          <li>metrics.basic</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Модуль: <code>Modules/Admin</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Integrations facade</h3>
        <ul>
          <li>integrations.status</li>
          <li>integrations.test</li>
          <li>integrations.config (owner)</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Источник: <code>Adapters/*</code> + <code>Config/endpoints.php</code>
        </p>
      </div>
    </div>
  </div>

  <!-- WS events -->
  <div class="content-block">
    <h3>WebSocket события (L1)</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      WS Event = {
        type,
        entity: "card|photo|export|publish_job|queue_job",
        id,
        status,
        payload?,
        ts
      }
    </div>

    <table class="table">
      <thead>
        <tr>
          <th>Event type</th>
          <th>Кому нужно</th>
          <th>Смысл</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>card.status.updated</strong></td>
          <td>Operator / Admin</td>
          <td>Изменение pipeline-статуса карточки.</td>
        </tr>
        <tr>
          <td><strong>photos.progress</strong></td>
          <td>Operator</td>
          <td>Прогресс/ошибка обработки фото.</td>
        </tr>
        <tr>
          <td><strong>export.created</strong></td>
          <td>Operator / Admin</td>
          <td>Пакет сформирован, доступна ссылка.</td>
        </tr>
        <tr>
          <td><strong>publish.status.updated</strong></td>
          <td>Operator / Admin</td>
          <td>Статус публикации (robot/avito).</td>
        </tr>
        <tr>
          <td><strong>queue.job.failed</strong></td>
          <td>Admin</td>
          <td>Ошибка задачи очереди, возможен retry.</td>
        </tr>
        <tr>
          <td><strong>dlq.job.added</strong></td>
          <td>Admin</td>
          <td>Задача помещена в DLQ (фатальная).</td>
        </tr>
      </tbody>
    </table>

    <p class="muted small" style="margin-top:6px;">
      Полный перечень событий, payload и версии — Part 9 (WS contracts).
    </p>
  </div>

  <!-- UI consumption -->
  <div class="content-block">
    <h3>Как UI использует HTTP + WS</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Operator UI</h3>
        <ul>
          <li>Списки карточек и фильтры — HTTP (polling по необходимости).</li>
          <li>Запуски стадий — HTTP actions.</li>
          <li>Прогресс стадий — WS подписки.</li>
          <li>Ошибки — человекочитаемые из ядра.</li>
        </ul>
      </div>

      <div class="card">
        <h3>Admin UI</h3>
        <ul>
          <li>Очереди/DLQ/логи — HTTP.</li>
          <li>Живые изменения очередей — WS.</li>
          <li>Интеграции health — HTTP + WS on change.</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <p class="small muted" style="margin-bottom:6px;">
        Важное правило:
      </p>
      <ul>
        <li>UI показывает только то состояние, которое пришло из ядра.</li>
        <li>WS — источник live-правды по прогрессу, HTTP — источник действий и снапшотов.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    UI работает через HTTP API для операций и снапшотов и через WS для live-статусов pipeline.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точные эндпоинты OpenAPI и WS-схемы фиксируем в Part 9 (API/WS Schemas).
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 9 (L2): Контракты, схемы и версии данных              -->
<!-- Детализируем вход/выход интеграций + схемы ядра            -->
<!-- ========================================================= -->
<section id="p9" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 9.</span>
    Контракты, схемы и версии данных
  </h2>
  <p class="subtitle">
    Формальные правила: какие поля обязательны, как валидируем вход/выход,
    как версионируем схемы и не ломаем pipeline.
  </p>
  <div class="level-pill">L2 — спецификация данных</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Зачем фиксировать контракты</h3>
    <p>
      Pipeline живёт на пересечении внешних сервисов и внутренней логики.
      Контракты нужны, чтобы:
      <strong>1)</strong> ядро одинаково понимало вход от Parser,
      <strong>2)</strong> внешние сервисы не ломали формат незаметно,
      <strong>3)</strong> любые изменения проходили через версию схемы,
      а не “тихий” рефакторинг в коде.
    </p>
  </div>

  <!-- Contract families -->
  <div class="content-block">
    <h3>Семейства контрактов</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>External → Core</h3>
        <ul>
          <li>Parser Push/Poll</li>
          <li>Photo API Result</li>
          <li>Dolphin Profile Status</li>
          <li>Avito Publish Status</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Смысл: входные данные всегда валидируются до изменения Card.
        </p>
      </div>

      <div class="card gray">
        <h3>Core → External</h3>
        <ul>
          <li>Photo API Process Request</li>
          <li>S3 Put/Get/Presign</li>
          <li>Dolphin Profile Start/Stop</li>
          <li>Robot Publish Request</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Смысл: ядро гарантирует структуру запросов к сервисам.
        </p>
      </div>

      <div class="card gray">
        <h3>Core → UI</h3>
        <ul>
          <li>HTTP DTO (Cards/Photos/Exports/Publish)</li>
          <li>WS Events payload</li>
          <li>Errors (human + tech)</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          UI не содержит логики догадок — только читает контракты.
        </p>
      </div>
    </div>
  </div>

  <!-- Where contracts live -->
  <div class="content-block">
    <h3>Где лежат схемы в репозитории</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>External contracts</h3>
        <ul>
          <li><code>external/parser/contracts/*.json</code></li>
          <li><code>external/photo-api/contracts/*.json</code></li>
          <li><code>external/storage/contracts/*</code></li>
          <li><code>external/dolphin/contracts/*.json</code></li>
          <li><code>external/avito/contracts/*.json</code></li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Core & UI contracts</h3>
        <ul>
          <li><code>backend/src/Modules/*/*Schemas.php</code></li>
          <li><code>docs/api-docs/openapi.yaml</code></li>
          <li><code>docs/api-docs/ws-events.md</code></li>
          <li><code>frontend/src/shared/api/events.ts</code></li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Versioning rules -->
  <div class="content-block">
    <h3>Правила версионирования</h3>

    <div class="card gray">
      <ul>
        <li>Каждая схема имеет поле <code>schema_version</code> (например, <code>1.0</code>).</li>
        <li>Минорная версия (<code>1.1</code>) — добавление необязательных полей.</li>
        <li>Мажорная версия (<code>2.0</code>) — изменение/удаление полей, ломающие совместимость.</li>
        <li>Ядро обязано поддерживать минимум 2 последние минорные версии входа.</li>
      </ul>
    </div>

    <details>
      <summary>Стратегия миграции версии</summary>
      <ul>
        <li>Сначала добавляем поддержку новой схемы на чтение.</li>
        <li>Потом переводим внешнюю систему на новую схему.</li>
        <li>После стабилизации — удаляем старую поддержку.</li>
      </ul>
    </details>
  </div>

  <!-- Validation -->
  <div class="content-block">
    <h3>Валидация и типы ошибок</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Где валидируем</h3>
        <ul>
          <li><strong>Вход External → Core</strong>: на адаптере ещё до доменных модулей.</li>
          <li><strong>Внутренние DTO</strong>: в сервисах модулей (Schemas + Validators).</li>
          <li><strong>Выход Core → External</strong>: перед вызовом адаптера.</li>
        </ul>
      </div>
      <div class="card">
        <h3>Классы ошибок</h3>
        <ul>
          <li><strong>ValidationError</strong> — невалидный контракт (фатальная → DLQ).</li>
          <li><strong>IntegrationError</strong> — сервис недоступен/таймаут (retry).</li>
          <li><strong>BusinessError</strong> — правило pipeline нарушено (user-facing).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Key contracts (L2 minimal shapes) -->
  <div class="content-block">
    <h3>Ключевые контракты (минимальные формы)</h3>

    <div class="grid-2">
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">ParserPush v1</h3>
        ParserPush = {
          schema_version: "1.0",
          source: "auto_ru",
          ads: [
            {
              source_id,
              vehicle: { make, model, year, body, mileage },
              price: { value, currency },
              location: { city, address?, coords? },
              description?,
              photos: [
                { url, order?, meta? }
              ],
              ts
            }
          ]
        }
      </div>

      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">PhotoProcess v1</h3>
        PhotoProcess = {
          schema_version: "1.0",
          card_id,
          photo_id,
          raw_url,
          mask_params: { mode: "blur|plate", strength?, bbox? }
        }
        → PhotoResult = {
          schema_version: "1.0",
          photo_id,
          masked_url,
          status: "ok|error",
          error?
        }
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">PublishRequest v1</h3>
        PublishRequest = {
          schema_version: "1.0",
          publish_job_id,
          card: { id, fields..., photos_masked[] },
          channel: { dolphin_profile_id, avito_account_id },
          options: { dry_run? }
        }
        → PublishResult = {
          schema_version: "1.0",
          publish_job_id,
          avito_item_id?,
          status: "published|failed|in_progress",
          error?
        }
      </div>

      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">WS Event v1</h3>
        WsEvent = {
          schema_version: "1.0",
          type,
          entity,
          id,
          status,
          payload?,
          ts
        }
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Полные JSON-схемы с обязательностью/enum/форматами лежат в <code>external/*/contracts</code>.
    </p>
  </div>

  <!-- Compatibility & tests -->
  <div class="content-block">
    <h3>Совместимость и тесты контрактов</h3>
    <div class="card gray">
      <ul>
        <li>Каждый адаптер имеет unit-тесты на валидные/невалидные payload.</li>
        <li>Fixtures внешних контрактов хранятся рядом со схемами.</li>
        <li>Интеграционные тесты проверяют полные цепочки: parser → card → photos → export → publish.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Контракты фиксируются как JSON-схемы, версии обязательны,
    вход валидируется на адаптерах, ошибки нормализуются в 3 класса.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точный полный список полей Auto.ru и Avito-мэппинг — уточняем при первом реальном payload.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 10 (L2/L3): State Machine карточки и переходы         -->
<!-- Детально: статусы, события, guard-условия, ретраи          -->
<!-- ========================================================= -->
<section id="p10" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 10.</span>
    State Machine карточки и переходы pipeline
  </h2>
  <p class="subtitle">
    Полная логика жизненного цикла Card: какие есть статусы, кто их меняет,
    какие события их переводят и где происходят ретраи/ошибки.
  </p>
  <div class="level-pill">L2/L3 — детальная механика</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Зачем фиксировать State Machine</h3>
    <p>
      State Machine — это единый контракт “как живёт карточка”.
      Он защищает от хаоса в статусах, делает pipeline предсказуемым,
      задаёт правила retry/DLQ и позволяет фронтенду показывать правильные действия
      для каждого состояния.
    </p>
  </div>

  <!-- Status groups -->
  <div class="content-block">
    <h3>Группы статусов</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Core статусы Card</h3>
        <ul>
          <li><strong>draft</strong> — создана из Parser, черновик.</li>
          <li><strong>ready_for_photos</strong> — ожидает фото-пайплайн.</li>
          <li><strong>ready_for_export</strong> — проверена оператором.</li>
          <li><strong>ready_for_publish</strong> — экспорт есть, можно публиковать.</li>
          <li><strong>published</strong> — успешно размещена.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Processing статусы</h3>
        <ul>
          <li><strong>photos_processing</strong></li>
          <li><strong>exporting</strong></li>
          <li><strong>publishing</strong></li>
          <li><strong>syncing_status</strong> — обновление статуса робота/Avito.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Эти статусы выставляет система/воркеры.
        </p>
      </div>

      <div class="card gray">
        <h3>Error/Terminal статусы</h3>
        <ul>
          <li><strong>photos_failed</strong></li>
          <li><strong>export_failed</strong></li>
          <li><strong>publish_failed</strong></li>
          <li><strong>blocked</strong> — ручная блокировка админом.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Ошибка может быть временной (retry) или фатальной (DLQ).
        </p>
      </div>
    </div>
  </div>

  <!-- Main flow diagram -->
  <div class="content-block">
    <h3>Основной поток (Happy Path)</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      draft
      → photos_processing
      → photos_ready
      → ready_for_export
      → exporting
      → exported
      → ready_for_publish
      → publishing
      → published
    </div>

    <p class="muted small" style="margin-top:6px;">
      “photos_ready” и “exported” — промежуточные доменные подтверждения завершения стадий.
    </p>
  </div>

  <!-- Transitions table -->
  <div class="content-block">
    <h3>Таблица переходов Card (L2)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Откуда</th>
          <th>Событие</th>
          <th>Кто инициатор</th>
          <th>Guard-условие</th>
          <th>Куда</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>—</td>
          <td><strong>parser.push.accepted</strong></td>
          <td>ParserWorker</td>
          <td>валидный ParserPush</td>
          <td><strong>draft</strong></td>
        </tr>

        <tr>
          <td>draft</td>
          <td><strong>photos.start</strong></td>
          <td>System / Operator</td>
          <td>есть raw фото</td>
          <td><strong>photos_processing</strong></td>
        </tr>

        <tr>
          <td>photos_processing</td>
          <td><strong>photos.done</strong></td>
          <td>PhotoWorker</td>
          <td>все фото masked ok</td>
          <td><strong>photos_ready</strong></td>
        </tr>

        <tr>
          <td>photos_processing</td>
          <td><strong>photos.failed</strong></td>
          <td>PhotoWorker</td>
          <td>attempts исчерпаны</td>
          <td><strong>photos_failed</strong></td>
        </tr>

        <tr>
          <td>photos_ready</td>
          <td><strong>operator.review.accept</strong></td>
          <td>Operator UI</td>
          <td>валидация карточки ok</td>
          <td><strong>ready_for_export</strong></td>
        </tr>

        <tr>
          <td>ready_for_export</td>
          <td><strong>export.start</strong></td>
          <td>System / Operator</td>
          <td>карточка не заблокирована</td>
          <td><strong>exporting</strong></td>
        </tr>

        <tr>
          <td>exporting</td>
          <td><strong>export.done</strong></td>
          <td>ExportWorker</td>
          <td>пакет создан</td>
          <td><strong>exported</strong></td>
        </tr>

        <tr>
          <td>exporting</td>
          <td><strong>export.failed</strong></td>
          <td>ExportWorker</td>
          <td>attempts исчерпаны</td>
          <td><strong>export_failed</strong></td>
        </tr>

        <tr>
          <td>exported</td>
          <td><strong>publish.prepare</strong></td>
          <td>System</td>
          <td>есть экспортный файл</td>
          <td><strong>ready_for_publish</strong></td>
        </tr>

        <tr>
          <td>ready_for_publish</td>
          <td><strong>publish.start</strong></td>
          <td>System / Operator</td>
          <td>есть dolphin_profile</td>
          <td><strong>publishing</strong></td>
        </tr>

        <tr>
          <td>publishing</td>
          <td><strong>publish.done</strong></td>
          <td>PublishWorker/Robot</td>
          <td>Avito status ok</td>
          <td><strong>published</strong></td>
        </tr>

        <tr>
          <td>publishing</td>
          <td><strong>publish.failed</strong></td>
          <td>PublishWorker/Robot</td>
          <td>attempts исчерпаны</td>
          <td><strong>publish_failed</strong></td>
        </tr>

        <tr>
          <td>*</td>
          <td><strong>admin.block</strong></td>
          <td>Admin UI</td>
          <td>роль admin+</td>
          <td><strong>blocked</strong></td>
        </tr>

        <tr>
          <td>blocked</td>
          <td><strong>admin.unblock</strong></td>
          <td>Admin UI</td>
          <td>роль admin+</td>
          <td>предыдущий статус</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Failure handling -->
  <div class="content-block">
    <h3>Обработка ошибок в State Machine (L3)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Временные ошибки (retry)</h3>
        <ul>
          <li>IntegrationError: таймаут, 5xx, сетевые сбои.</li>
          <li>Task остаётся в processing → retrying.</li>
          <li>Card статус не меняется на failed до исчерпания attempts.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Фатальные ошибки (DLQ)</h3>
        <ul>
          <li>ValidationError: невалидный контракт.</li>
          <li>BusinessError: запрещённое состояние (например publish без экспортов).</li>
          <li>Задача уходит в DLQ, Card фиксируется в *_failed.</li>
        </ul>
      </div>
    </div>

    <details>
      <summary>Правило “Card не прыгает назад сама”</summary>
      <ul>
        <li>Автоматический откат статуса запрещён.</li>
        <li>Назад переводит только оператор/админ через явное действие.</li>
        <li>Это сохраняет прозрачность аудита.</li>
      </ul>
    </details>
  </div>

  <!-- Frontend implications -->
  <div class="content-block">
    <h3>Как State Machine управляет UI</h3>
    <div class="card gray">
      <ul>
        <li>Operator UI показывает действия только для разрешённых статусов.</li>
        <li>Например: кнопка “Запустить фото” видна только в draft/ready_for_photos.</li>
        <li>Admin UI видит все статусы и может делать unblock/retry.</li>
        <li>WS-события “card.status.updated” — единственный триггер обновления UI.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Статусы Card формально описаны, переходы происходят только через события,
    ретраи не переводят Card в failed до исчерпания attempts, фатальные ошибки → DLQ.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    конкретные enum’ы ошибок Avito/Dolphin/Photo API и их маппинг на retry vs fatal — Part 11.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 11 (L2): Reliability, SLA и эксплуатационные правила  -->
<!-- Лимиты, таймауты, backoff, health-check, алерты, runbooks  -->
<!-- ========================================================= -->
<section id="p11" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 11.</span>
    Reliability, SLA и эксплуатационные правила
  </h2>
  <p class="subtitle">
    Набор правил, который делает pipeline предсказуемым в проде:
    таймауты, ретраи, лимиты, health-индикаторы и порядок восстановления.
  </p>
  <div class="level-pill">L2 — надёжность и прод-контур</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Цель Reliability слоя</h3>
    <p>
      Надёжность в Autocontent — это не “чтобы не падало”, а чтобы:
      <strong>1)</strong> карточки всегда доходили до финала,
      <strong>2)</strong> ошибки были заметны и управляемы,
      <strong>3)</strong> время прохождения стадий было контролируемо.
    </p>
  </div>

  <!-- SLA per stage -->
  <div class="content-block">
    <h3>SLA на стадии pipeline (целевые значения)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Стадия</th>
          <th>Цель по времени</th>
          <th>Считаем “просрочено”</th>
          <th>Действия системы</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Parser → draft</strong></td>
          <td>до 2 мин после пуша</td>
          <td>&gt; 10 мин</td>
          <td>Retry parser job → DLQ при фатале</td>
        </tr>
        <tr>
          <td><strong>Photos</strong></td>
          <td>до 15 мин / карточка</td>
          <td>&gt; 60 мин</td>
          <td>Backoff + auto retry → DLQ</td>
        </tr>
        <tr>
          <td><strong>Export</strong></td>
          <td>до 5 мин / пакет</td>
          <td>&gt; 20 мин</td>
          <td>Retry export job → DLQ</td>
        </tr>
        <tr>
          <td><strong>Publish</strong></td>
          <td>до 10 мин / карточка</td>
          <td>&gt; 45 мин</td>
          <td>Retry publish job → DLQ</td>
        </tr>
        <tr>
          <td><strong>Status sync</strong></td>
          <td>каждые 1–3 мин</td>
          <td>&gt; 10 мин без апдейта</td>
          <td>Повторный опрос → алерт админу</td>
        </tr>
      </tbody>
    </table>

    <p class="muted small" style="margin-top:6px;">
      Это целевые значения L2. Точные цифры можно корректировать по факту реальной нагрузки.
    </p>
  </div>

  <!-- Retry policy -->
  <div class="content-block">
    <h3>RetryPolicy (L2)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Лимиты attempts</h3>
        <ul>
          <li><strong>parser</strong> — 3 попытки</li>
          <li><strong>photos</strong> — 5 попыток</li>
          <li><strong>export</strong> — 3 попытки</li>
          <li><strong>publish</strong> — 5 попыток</li>
          <li><strong>robot_status</strong> — бесконечно, но с алертом</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Backoff схема</h3>
        <div style="font-family:var(--mono); font-size:13px;">
          retry_delays = [1m, 5m, 15m, 60m, 3h]
        </div>
        <p class="muted small" style="margin-top:6px;">
          При каждом ретрае берём следующий delay.
          Последний delay повторяем до исчерпания attempts.
        </p>
      </div>
    </div>

    <details>
      <summary>Что считается временной ошибкой (retry)</summary>
      <ul>
        <li>HTTP 429 / rate limit.</li>
        <li>HTTP 5xx или сетевой таймаут.</li>
        <li>Падение процесса Photo API / Storage / Dolphin.</li>
      </ul>
    </details>

    <details>
      <summary>Что считается фатальной ошибкой (DLQ)</summary>
      <ul>
        <li>Невалидная схема входа (ValidationError).</li>
        <li>Отказ Avito по бизнес-причинам (запрещённое поле, бан, лимиты аккаунта).</li>
        <li>Несовместимая версия схемы.</li>
        <li>Нарушение guard-условий state machine.</li>
      </ul>
    </details>
  </div>

  <!-- Timeouts -->
  <div class="content-block">
    <h3>Таймауты внешних сервисов</h3>

    <div class="card gray">
      <ul>
        <li><strong>Parser API</strong>: connect 5s / read 30s</li>
        <li><strong>Photo API</strong>: connect 5s / read 120s (фото тяжёлые)</li>
        <li><strong>S3 Storage</strong>: connect 3s / read 30s / upload 120s</li>
        <li><strong>Dolphin API</strong>: connect 5s / read 30s</li>
        <li><strong>Robot</strong>: connect 5s / read 180s (публикация)</li>
      </ul>
    </div>
  </div>

  <!-- Health checks -->
  <div class="content-block">
    <h3>Health-check модель</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>System health</h3>
        <ul>
          <li>DB доступна</li>
          <li>Queue backend доступен</li>
          <li>Workers живы</li>
          <li>WS сервер жив</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Integrations health</h3>
        <ul>
          <li>Parser API</li>
          <li>Photo API</li>
          <li>S3 Storage</li>
          <li>Dolphin API</li>
          <li>Avito доступность (через Robot)</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Pipeline health</h3>
        <ul>
          <li>глубина очередей</li>
          <li>доля retry</li>
          <li>рост DLQ</li>
          <li>просрок SLA</li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Health выводится в Admin UI и отдаётся endpoint’ом <code>/health</code>.
    </p>
  </div>

  <!-- Alerts -->
  <div class="content-block">
    <h3>Алерты (что кричит админу)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Сигнал</th>
          <th>Порог</th>
          <th>Куда</th>
          <th>Смысл</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>DLQ рост</strong></td>
          <td>&gt; 5 задач / 15 мин</td>
          <td>Admin UI + чат</td>
          <td>Появилась фатальная проблема</td>
        </tr>
        <tr>
          <td><strong>Очередь фоток</strong></td>
          <td>&gt; 500 задач</td>
          <td>Admin UI</td>
          <td>Не хватает PhotoWorker или API тормозит</td>
        </tr>
        <tr>
          <td><strong>SLA просрок</strong></td>
          <td>&gt; 10% карточек</td>
          <td>Admin UI + owner</td>
          <td>Конвейер “плывёт” по времени</td>
        </tr>
        <tr>
          <td><strong>Integration down</strong></td>
          <td>health=fail &gt; 5 мин</td>
          <td>Admin UI</td>
          <td>Сервис недоступен</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Runbooks -->
  <div class="content-block">
    <h3>Runbooks (порядок восстановления)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Если упал внешний сервис</h3>
        <ol>
          <li>Health показывает fail, очередь растёт.</li>
          <li>Задачи автоматически уходят в retrying.</li>
          <li>Админ устраняет проблему сервиса.</li>
          <li>После восстановления — ручной retry DLQ (если есть).</li>
        </ol>
      </div>
      <div class="card gray">
        <h3>Если вырос DLQ</h3>
        <ol>
          <li>Смотрим тип ошибок (Validation / Business / Integration).</li>
          <li>Если контракт — чинится адаптер/схема.</li>
          <li>Если бизнес-ошибка — правим карточку/маппинг.</li>
          <li>Делаем retry по выбранным задачам.</li>
        </ol>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Полные runbooks лежат в <code>docs/runbooks/</code>.
    </p>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Операции через очередь защищены SLA, RetryPolicy с backoff и DLQ.
    В Admin UI есть health/alerts/runbooks для быстрого восстановления.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    финальные пороги алертов и реальные SLA уточняются после первых недель прод-эксплуатации.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 12 (L2): RBAC, права доступа и feature flags          -->
<!-- Детальная ролевка: как проверяется доступ в ядре и UI      -->
<!-- ========================================================= -->
<section id="p12" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 12.</span>
    RBAC, права доступа и feature flags
  </h2>
  <p class="subtitle">
    Формализуем доступы: какие права существуют, как они назначаются,
    где проверяются и как фичи включаются/выключаются без релиза.
  </p>
  <div class="level-pill">L2 — безопасность и управление доступом</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип RBAC</h3>
    <p>
      Доступ к любому действию определяется не экраном, а <strong>правом (permission)</strong>.
      Роль — это набор прав.  
      Проверка прав происходит <strong>в backend</strong> (истина) и дублируется
      <strong>в frontend guards</strong> (UX).
    </p>
  </div>

  <!-- Permissions catalog (L2) -->
  <div class="content-block">
    <h3>Каталог прав (permissions)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Cards</h3>
        <ul>
          <li><code>cards.read</code></li>
          <li><code>cards.update</code></li>
          <li><code>cards.bulk.update</code></li>
          <li><code>cards.status.set</code></li>
          <li><code>cards.block</code> (admin)</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Photos / Export / Publish</h3>
        <ul>
          <li><code>photos.start</code></li>
          <li><code>photos.retry</code> (admin/operator)</li>
          <li><code>export.create</code></li>
          <li><code>export.download</code></li>
          <li><code>publish.start</code></li>
          <li><code>publish.retry</code> (admin)</li>
        </ul>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>Admin / System</h3>
        <ul>
          <li><code>queues.read</code></li>
          <li><code>queues.pause</code></li>
          <li><code>queues.resume</code></li>
          <li><code>dlq.read</code></li>
          <li><code>dlq.retry</code></li>
          <li><code>logs.read</code></li>
          <li><code>health.read</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Users / Roles / Config</h3>
        <ul>
          <li><code>users.read</code></li>
          <li><code>users.create</code></li>
          <li><code>users.update</code></li>
          <li><code>users.delete</code></li>
          <li><code>roles.assign</code></li>
          <li><code>integrations.config.write</code> (owner)</li>
          <li><code>feature_flags.write</code> (owner)</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Roles mapping -->
  <div class="content-block">
    <h3>Наборы прав по ролям (L2)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Permission group</th>
          <th>Operator</th>
          <th>Admin</th>
          <th>Owner/Superadmin</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Cards</strong></td>
          <td>read, update, bulk, status.set</td>
          <td>read, status.set, block</td>
          <td>all</td>
        </tr>
        <tr>
          <td><strong>Photos</strong></td>
          <td>start, retry</td>
          <td>start, retry</td>
          <td>all</td>
        </tr>
        <tr>
          <td><strong>Export</strong></td>
          <td>create, download</td>
          <td>create, download</td>
          <td>all</td>
        </tr>
        <tr>
          <td><strong>Publish</strong></td>
          <td>start</td>
          <td>start, retry</td>
          <td>all</td>
        </tr>
        <tr>
          <td><strong>Admin/System</strong></td>
          <td>—</td>
          <td>queues.*, dlq.*, logs.read, health.read</td>
          <td>all</td>
        </tr>
        <tr>
          <td><strong>Users/Roles/Config</strong></td>
          <td>—</td>
          <td>users.read, roles.assign</td>
          <td>all</td>
        </tr>
      </tbody>
    </table>

    <p class="muted small" style="margin-top:6px;">
      Owner/Superadmin — это “суперроль”, включающая все permissions.
    </p>
  </div>

  <!-- Where checks happen -->
  <div class="content-block">
    <h3>Где проверяются права</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Backend (истина)</h3>
        <ul>
          <li><code>AuthMiddleware</code> валидирует токен.</li>
          <li><code>RoleMiddleware</code> сверяет permission на endpoint.</li>
          <li>Доменные сервисы повторно проверяют guard-условия (state machine).</li>
          <li>Любое нарушение → <code>403 Forbidden</code> + audit-log.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Файлы: <code>backend/src/Middlewares/*</code>, <code>Config/roles.php</code>
        </p>
      </div>

      <div class="card">
        <h3>Frontend (UX)</h3>
        <ul>
          <li><code>AuthGuard</code> защищает приватные роуты.</li>
          <li><code>RoleGuard</code> скрывает экраны/действия без прав.</li>
          <li>Actions недоступные по правам не отображаются.</li>
          <li>Даже если кнопку “подделать” — backend всё равно запретит.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Файлы: <code>frontend/src/shared/guards/*</code>
        </p>
      </div>
    </div>
  </div>

  <!-- Feature flags -->
  <div class="content-block">
    <h3>Feature Flags</h3>

    <div class="card gray">
      <p class="small muted" style="margin-bottom:6px;">
        Feature flags позволяют включать/выключать функции без правки кода.
      </p>
      <ul>
        <li>Флаги хранятся в <code>backend/src/Config/feature_flags.php</code> и/или в DB.</li>
        <li>Backend отдаёт активные флаги в <code>/me</code> или <code>/config</code>.</li>
        <li>Frontend включает функции через <code>FeatureFlagGuard</code>.</li>
        <li>Owner может менять флаги в Admin UI.</li>
      </ul>
    </div>

    <details>
      <summary>Примеры флагов</summary>
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        feature_flags = {
          "photos.auto_start": true,
          "export.multi_format": false,
          "publish.dry_run": true,
          "admin.dlq_bulk_retry": false,
          "cards.ai_description": false
        }
      </div>
    </details>
  </div>

  <!-- Audit -->
  <div class="content-block">
    <h3>Аудит действий по RBAC</h3>
    <div class="card gray">
      <ul>
        <li>Любое действие, требующее permission, логируется в AuditLog.</li>
        <li>Запись: кто → что → над чем → результат (ok/forbidden/error).</li>
        <li>Admin UI может фильтровать аудит по пользователю/карточке/дате.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    RBAC построен на permissions, роли — это наборы прав.
    Backend является источником истины, frontend guards дают UX.
    Feature flags управляют включением функций без релиза.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    нужно ли выделять отдельную роль “Reviewer/QA” с ограниченными правами на publish — решаем после MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 13 (L2/L3): Схема БД, индексация и миграции           -->
<!-- Детально: таблицы, ключи, индексы под UI, версии миграций  -->
<!-- ========================================================= -->
<section id="p13" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 13.</span>
    Схема БД, индексация и миграции
  </h2>
  <p class="subtitle">
    Как физически хранится источник правды Autocontent: таблицы, связи,
    ключевые индексы под фильтры Operator UI, и правила миграций.
  </p>
  <div class="level-pill">L2/L3 — уровень хранения данных</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип БД</h3>
    <p>
      База данных хранит <strong>метаданные и статусы</strong>, а не бинарные файлы.
      Любая сущность, участвующая в pipeline, должна быть видима в БД,
      чтобы можно было восстановить состояние и объяснить “почему так”.
    </p>
  </div>

  <!-- Tables overview -->
  <div class="content-block">
    <h3>Набор таблиц (L2)</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>cards</h3>
        <ul>
          <li>центральная таблица</li>
          <li>поля карточки</li>
          <li>status pipeline</li>
          <li>source/source_id</li>
          <li>timestamps</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>photos</h3>
        <ul>
          <li>photo_id</li>
          <li>card_id FK</li>
          <li>raw_key / masked_key</li>
          <li>order</li>
          <li>status + error</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>exports</h3>
        <ul>
          <li>export_id</li>
          <li>формат + версия</li>
          <li>storage_key</li>
          <li>created_by</li>
          <li>status</li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>export_cards</h3>
        <ul>
          <li>export_id FK</li>
          <li>card_id FK</li>
          <li>позиция в пакете</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          связка N:N Export ↔ Cards
        </p>
      </div>

      <div class="card gray">
        <h3>publish_jobs</h3>
        <ul>
          <li>publish_job_id</li>
          <li>card_id FK</li>
          <li>dolphin_profile_id</li>
          <li>avito_item_id</li>
          <li>status + error</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>queue_jobs</h3>
        <ul>
          <li>job_id</li>
          <li>type</li>
          <li>entity_ref</li>
          <li>attempts + next_retry_at</li>
          <li>status + last_error</li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>dlq_jobs</h3>
        <ul>
          <li>job_id</li>
          <li>origin_queue</li>
          <li>payload</li>
          <li>fatal_reason</li>
          <li>created_at</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>users / roles / user_roles</h3>
        <ul>
          <li>пользователи</li>
          <li>роли</li>
          <li>назначение ролей</li>
          <li>hash токенов</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>audit_logs</h3>
        <ul>
          <li>actor</li>
          <li>entity + entity_id</li>
          <li>action</li>
          <li>before/after</li>
          <li>result</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Minimal schemas -->
  <div class="content-block">
    <h3>Минимальные схемы таблиц (L2)</h3>

    <div class="grid-2">
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">cards</h3>
        cards(
          id PK,
          source,
          source_id UNIQUE,
          status,
          vehicle_make,
          vehicle_model,
          vehicle_year,
          vehicle_body,
          mileage,
          vin NULL,
          price_value,
          price_currency,
          city,
          address NULL,
          lat NULL,
          lon NULL,
          description NULL,
          created_by NULL,
          created_at,
          updated_at
        )
      </div>

      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">photos</h3>
        photos(
          id PK,
          card_id FK → cards.id,
          raw_key,
          masked_key NULL,
          sort_order INT,
          status,
          error_code NULL,
          error_message NULL,
          created_at,
          updated_at
        )
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">exports</h3>
        exports(
          id PK,
          format ENUM("xlsx","json"),
          version,
          storage_key,
          status,
          created_by FK → users.id,
          created_at
        )
      </div>

      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        <h3 style="font-family:var(--sans); font-size:15px;">publish_jobs</h3>
        publish_jobs(
          id PK,
          card_id FK → cards.id,
          dolphin_profile_id,
          avito_item_id NULL,
          status,
          attempts,
          last_error NULL,
          created_at,
          updated_at
        )
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Полные DDL-файлы и миграции лежат в <code>backend/src/DB/Migrations</code>.
    </p>
  </div>

  <!-- Indexing for UI -->
  <div class="content-block">
    <h3>Индексы под Operator UI (L3)</h3>

    <div class="card gray">
      <ul>
        <li><strong>cards(status)</strong> — быстрые фильтры по стадиям.</li>
        <li><strong>cards(source, source_id)</strong> — идемпотентность входа Parser.</li>
        <li><strong>cards(vehicle_make, vehicle_model, vehicle_year)</strong> — фильтры по авто.</li>
        <li><strong>cards(price_value)</strong> — диапазоны цены.</li>
        <li><strong>cards(city)</strong> — фильтры по локации.</li>
        <li><strong>photos(card_id, status)</strong> — прогресс фото-пайплайна.</li>
        <li><strong>publish_jobs(card_id, status)</strong> — статусы публикаций.</li>
        <li><strong>queue_jobs(type, status, next_retry_at)</strong> — админские очереди.</li>
      </ul>
    </div>

    <details>
      <summary>Правило: индекс добавляем только под реальные фильтры</summary>
      <ul>
        <li>Сначала измеряем частоту запросов UI/воркеров.</li>
        <li>Добавляем индекс, если запрос стабильно в топе нагрузки.</li>
        <li>Ревизия индексов — после первых недель прод-наблюдений.</li>
      </ul>
    </details>
  </div>

  <!-- Migrations -->
  <div class="content-block">
    <h3>Правила миграций</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Формат</h3>
        <ul>
          <li>Нумерация: <code>001_*.sql</code>, <code>002_*.sql</code> …</li>
          <li>Миграции атомарные и обратимые по смыслу.</li>
          <li>Каждая миграция сопровождается коротким README/комментом.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Совместимость</h3>
        <ul>
          <li>Сначала добавляем новые поля (NULL/optional).</li>
          <li>Потом обновляем код.</li>
          <li>После стабилизации — делаем tighten/NOT NULL/cleanup.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    БД — источник правды по карточкам, статусам и очередям.
    Основная таблица — cards, индексы строятся под реальные фильтры Operator/Admin UI,
    миграции версионируются и не ломают совместимость.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    выбор конкретного движка (Postgres vs MySQL) и типы json-полей — фиксируем при старте разработки.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 14 (L2): Архитектура фронтенда (слои, apps, features) -->
<!-- Как устроен React фронт: дизайн-слой, shared, features     -->
<!-- ========================================================= -->
<section id="p14" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 14.</span>
    Архитектура фронтенда (слои, apps, features)
  </h2>
  <p class="subtitle">
    Как организован фронтенд Autocontent: слоистость “design → shared → features → apps”,
    как это помогает поддержке двух UI-контуров и росту функционала.
  </p>
  <div class="level-pill">L2 — фронтенд-архитектура</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Смысл слоистой архитектуры</h3>
    <p>
      Фронтенд делится на 4 уровня, чтобы:
      <strong>1)</strong> дизайн был единым и переиспользуемым,
      <strong>2)</strong> инфраструктура (API/store/guards) не дублировалась,
      <strong>3)</strong> доменные фичи развивались независимо,
      <strong>4)</strong> Operator/Admin UI собирались из одной базы, но с разными маршрутами.
    </p>
  </div>

  <!-- Layers -->
  <div class="content-block">
    <h3>Слои фронтенда</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>1) design/ — конечный дизайн (UI-kit)</h3>
        <ul>
          <li>Токены: цвета/типографика/отступы/темы.</li>
          <li>Примитивы: кнопки, инпуты, таблицы, модалки, бейджи.</li>
          <li>Лэйауты: Shell, Sidebar, Header, Grid.</li>
          <li>Storybook для визуального контроля.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Не содержит бизнес-логики, только “красивые кирпичи”.
        </p>
      </div>

      <div class="card gray">
        <h3>2) shared/ — инфраструктура</h3>
        <ul>
          <li>API-клиент, endpoints, WS.</li>
          <li>Глобальный store + session.</li>
          <li>Хуки (useMe, useRole, useWSSubscription).</li>
          <li>Guards (Auth/Role/FeatureFlag).</li>
          <li>Утилиты, константы, mocks.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Это “двигатель”, одинаковый для всех UI-контуров.
        </p>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>3) features/ — доменные блоки</h3>
        <ul>
          <li>cards, photos, export, publish, parser, admin.</li>
          <li>Внутри фичи: api.ts, model.ts, schemas.ts, ui/*.</li>
          <li>Фича знает только свою доменную область.</li>
          <li>Фича не знает, в каком app её используют.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>4) apps/ — 2 контура UI</h3>
        <ul>
          <li><strong>apps/operator</strong> — рабочие страницы оператора.</li>
          <li><strong>apps/admin</strong> — панели очередей, DLQ, логов.</li>
          <li>Свой routes.tsx и каркас App.tsx у каждого контура.</li>
          <li>Собираются из общих features и shared.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Composition -->
  <div class="content-block">
    <h3>Как собирается экран</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      Design primitives/layouts
        → Feature UI components
          → App pages
            → Routes
              → AppShell
    </div>

    <p class="muted small" style="margin-top:6px;">
      То есть “красивые кирпичи” → “доменные куски” → “страницы по ролям”.
    </p>
  </div>

  <!-- Routing -->
  <div class="content-block">
    <h3>Роутинг и изоляция контуров</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Operator routes</h3>
        <ul>
          <li>/dashboard</li>
          <li>/cards</li>
          <li>/photos</li>
          <li>/export</li>
          <li>/publish</li>
        </ul>
      </div>
      <div class="card">
        <h3>Admin routes</h3>
        <ul>
          <li>/admin/queues</li>
          <li>/admin/dlq</li>
          <li>/admin/logs</li>
          <li>/admin/integrations</li>
          <li>/admin/users-roles</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>Guard’ы на уровне routes скрывают чужие контуры.</li>
        <li>Если у пользователя 2 роли — доступно переключение app-mode.</li>
        <li>Общий AppShell (sidebar/header) подключается в зависимости от режима.</li>
      </ul>
    </div>
  </div>

  <!-- State management -->
  <div class="content-block">
    <h3>Управление состоянием</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Глобальное состояние (shared/store)</h3>
        <ul>
          <li>session.slice — пользователь, роли, флаги.</li>
          <li>cards.slice — списки карточек, фильтры, кеш.</li>
          <li>publish.slice — статусы публикаций.</li>
          <li>queue.slice — только для Admin UI.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Локальное состояние (features)</h3>
        <ul>
          <li>формы редактирования карточки</li>
          <li>wizard-потоки (если появятся)</li>
          <li>табличные UI-состояния</li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Источник правды по статусам — backend; store на фронте это “кеш и проекция”.
    </p>
  </div>

  <!-- WS usage -->
  <div class="content-block">
    <h3>Реакция на WS события</h3>

    <div class="card gray">
      <ul>
        <li>shared/ws.ts поднимает соединение после login.</li>
        <li>useWSSubscription подписывает фичи на нужные event types.</li>
        <li>События обновляют store через events.ts → slices.</li>
        <li>UI сразу перерисовывается, без ручного refresh.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Фронтенд слоистый: design → shared → features → apps.
    Два UI-контура собираются из одной базы, права и флаги управляют доступом.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    нужен ли отдельный “QA app” с ограниченным набором страниц — решаем после MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 15 (L2): Правила фасада UI и дизайн-система продукта  -->
<!-- Как визуально и UX-логически должен выглядеть Autocontent  -->
<!-- ========================================================= -->
<section id="p15" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 15.</span>
    Правила фасада UI и дизайн-система продукта
  </h2>
  <p class="subtitle">
    Единые UX/визуальные правила для Operator/Admin UI:
    как строятся экраны, где применяются цвета, серые/черные блоки, акценты и градиент.
  </p>
  <div class="level-pill">L2 — UI/UX правила</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Смысл фасада</h3>
    <p>
      Фасад UI — это не “стиль ради стиля”, а способ сделать
      <strong>конвейер понятным</strong>. Любое решение в дизайне отвечает на вопрос:
      “можно ли за 3 секунды понять, где карточка и что с ней делать дальше?”.
    </p>
  </div>

  <!-- Color rules -->
  <div class="content-block">
    <h3>Правила цветов</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>База (≈ 85%)</h3>
        <ul>
          <li><strong>Белый фон</strong> — основной холст страниц.</li>
          <li><strong>Серые подложки</strong> — логические контейнеры, вторичные зоны.</li>
          <li><strong>Черный/темно-серый текст</strong> — основная иерархия и выделения.</li>
          <li>Цель: спокойное чтение, фокус на данных.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Бренд (≈ 15%)</h3>
        <ul>
          <li><strong>Оранжевый</strong> — только для действий и ключевых узлов.</li>
          <li><strong>Градиент</strong> — на hero-линии, прогресс-потоках, редких акцентах.</li>
          <li><strong>Красный</strong> — ошибки/DLQ/фатальные состояния.</li>
          <li>Цель: акцент на “движении карточки”.</li>
        </ul>
      </div>
    </div>

    <details>
      <summary>Где обязательно использовать оранжевый</summary>
      <ul>
        <li>Primary кнопки: Start Photos / Export / Publish.</li>
        <li>Активный этап pipeline/stepper.</li>
        <li>Числовые KPI/главные метрики на Dashboard.</li>
      </ul>
    </details>
  </div>

  <!-- Typography rules -->
  <div class="content-block">
    <h3>Типографика и иерархия</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Заголовки</h3>
        <ul>
          <li>H1 (страница): 24–28px, bold, black.</li>
          <li>H2 (секция): 18–20px, semibold.</li>
          <li>H3 (блок): 15–16px, bold.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Текст</h3>
        <ul>
          <li>Body: 14–15px, dark-gray.</li>
          <li>Muted: 12–13px, gray.</li>
          <li>Тех-текст/JSON: 12–13px mono.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Выделения</h3>
        <ul>
          <li>Логика/термины — black + weight.</li>
          <li>Важные вторичные подсказки — в серых callout.</li>
          <li>Не использовать цвет как единственный сигнал.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Layout rules -->
  <div class="content-block">
    <h3>Сетка и layout (общие правила)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>PageShell</h3>
        <ul>
          <li>Sidebar слева — навигация по доменам pipeline.</li>
          <li>Header сверху — поиск, профиль, режим/роль.</li>
          <li>Content зона — всегда белая, с карточками-контейнерами.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Карточки и блоки</h3>
        <ul>
          <li>Любой экран — это набор “white cards”.</li>
          <li>Внутри — серые под-контейнеры для групп данных.</li>
          <li>Между блоками 8–12px (чтобы не липли).</li>
        </ul>
      </div>
    </div>

    <details>
      <summary>Правила таблиц (CardsTable, LogsTable и т.д.)</summary>
      <ul>
        <li>Sticky header + серый фон шапки.</li>
        <li>Строки на белом, hover — light-gray.</li>
        <li>Статусы в виде бейджей (см. ниже).</li>
      </ul>
    </details>
  </div>

  <!-- Status UX -->
  <div class="content-block">
    <h3>Визуальные правила статусов</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Тип статуса</th>
          <th>Цвет</th>
          <th>Вид в UI</th>
          <th>Смысл</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Processing</strong></td>
          <td>оранжевый / градиент тонко</td>
          <td>Badge + ProgressBar</td>
          <td>Стадия идёт, показываем прогресс</td>
        </tr>
        <tr>
          <td><strong>Ready / OK</strong></td>
          <td>черный/темно-серый</td>
          <td>Badge neutral</td>
          <td>Карточка ждёт следующего шага</td>
        </tr>
        <tr>
          <td><strong>Done</strong></td>
          <td>темный + легкий accent-outline</td>
          <td>Badge success-neutral</td>
          <td>Стадия завершена</td>
        </tr>
        <tr>
          <td><strong>Error / Failed</strong></td>
          <td>красный</td>
          <td>Badge danger + текст ошибки</td>
          <td>Нужен retry или ручная правка</td>
        </tr>
        <tr>
          <td><strong>DLQ</strong></td>
          <td>красный + серый контейнер</td>
          <td>DLQ row highlight</td>
          <td>Фатальная ошибка, вмешательство админа</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Interaction rules -->
  <div class="content-block">
    <h3>UX-правила взаимодействия</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Действия по месту</h3>
        <ul>
          <li>Кнопки стадий рядом со статусом.</li>
          <li>Bulk-actions доступны только для совместимых статусов.</li>
          <li>Не прячем важное в меню “…” без нужды.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Обратная связь</h3>
        <ul>
          <li>Любое действие → toast + смена статуса.</li>
          <li>Долго → показываем прогресс, а не “спиннер навсегда”.</li>
          <li>Ошибки говорим человеческим языком.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Ошибки</h3>
        <ul>
          <li>Operator видит “что сделать”.</li>
          <li>Admin видит “что сломалось”.</li>
          <li>У каждой ошибки есть код для поиска по логам.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Dashboard facade -->
  <div class="content-block">
    <h3>Фасад Dashboard (L2)</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Operator Dashboard</h3>
        <ul>
          <li>KPI по своим карточкам (draft/processing/ready/published).</li>
          <li>Топ ошибок “что мешает работе”.</li>
          <li>Быстрые фильтры “продолжить работу”.</li>
        </ul>
      </div>

      <div class="card">
        <h3>Admin Dashboard</h3>
        <ul>
          <li>KPI по очередям (depth, rate, retries).</li>
          <li>DLQ рост и причины.</li>
          <li>Health-виджет интеграций.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    UI строится на белой базе с активным использованием серых/черных контейнеров.
    Оранжевый и градиент — только для действий и ключевых статусов (≈15%).
    Статусы показываются через бейджи/прогресс, ошибки — через понятные сообщения.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    нужно ли вводить отдельный “ночной режим” — пока нет, решаем после MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 16 (L2): Operator UI — ключевые экраны и логика       -->
<!-- Что именно видит оператор и как он работает с pipeline     -->
<!-- ========================================================= -->
<section id="p16" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 16.</span>
    Operator UI — ключевые экраны и логика
  </h2>
  <p class="subtitle">
    Рабочий контур оператора: какие страницы нужны для ежедневной работы,
    что на них отображается и какие действия доступны.
  </p>
  <div class="level-pill">L2 — фронтенд по ролям</div>

  <!-- Purpose -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Цель Operator UI</h3>
    <p>
      Оператор должен <strong>быстро доводить карточки до публикации</strong>.
      Поэтому UI заточен на:
      <strong>1)</strong> потоковую работу со списком,
      <strong>2)</strong> быструю правку карточки,
      <strong>3)</strong> запуск стадий pipeline,
      <strong>4)</strong> мгновенное понимание статуса.
    </p>
  </div>

  <!-- Pages map -->
  <div class="content-block">
    <h3>Карта страниц Operator UI</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>/dashboard</h3>
        <ul>
          <li>KPI по карточкам (draft / processing / ready / publish_failed / published).</li>
          <li>“Очередь на работу”: последние карточки в draft/photos_ready.</li>
          <li>Топ ошибок по стадиям.</li>
          <li>Быстрые кнопки-фильтры.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/cards</h3>
        <ul>
          <li>Главная таблица карточек.</li>
          <li>Фильтры по статусам, авто, цене, городу.</li>
          <li>Сортировка, поиск по source_id/VIN.</li>
          <li>Bulk actions по совместимым статусам.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/cards/:id</h3>
        <ul>
          <li>Просмотр/редактирование карточки.</li>
          <li>Вкладки: Data / Photos / Export / Publish / History.</li>
          <li>Контекстные действия pipeline.</li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>/photos</h3>
        <ul>
          <li>Очередь карточек с фото-стадией.</li>
          <li>Прогресс фото по каждой карточке.</li>
          <li>Кнопки retry для временных ошибок.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/export</h3>
        <ul>
          <li>Список экспортов.</li>
          <li>Создание пакета из выбранных карточек.</li>
          <li>Скачивание/export link.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/publish</h3>
        <ul>
          <li>Очередь публикаций.</li>
          <li>Статусы робота/Avito.</li>
          <li>Повторная публикация (если разрешено).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Cards List screen -->
  <div class="content-block">
    <h3>Экран Cards List (главный рабочий)</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Что отображаем в таблице</h3>
        <ul>
          <li>Основные поля: марка/модель/год/цена/город.</li>
          <li>Статус pipeline (badge).</li>
          <li>Прогресс фото/экспорта/публикации (mini-progress).</li>
          <li>Время последнего изменения.</li>
          <li>Ошибки (иконка + tooltip).</li>
        </ul>
      </div>

      <div class="card">
        <h3>Фильтры (L2)</h3>
        <ul>
          <li>Статус: draft / photos_ready / ready_for_export / publish_failed / published.</li>
          <li>Марка/модель/год.</li>
          <li>Цена (range).</li>
          <li>Город.</li>
          <li>Источник (auto_ru).</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <h3>Bulk Actions</h3>
      <ul>
        <li><strong>Start Photos</strong> — только для draft/ready_for_photos.</li>
        <li><strong>Mark Ready for Export</strong> — только для photos_ready.</li>
        <li><strong>Create Export</strong> — только для ready_for_export.</li>
        <li><strong>Start Publish</strong> — только для ready_for_publish.</li>
      </ul>
      <p class="muted small" style="margin-top:6px;">
        Если статусы смешанные — bulk action скрывается или дизейблится.
      </p>
    </div>
  </div>

  <!-- Card Details -->
  <div class="content-block">
    <h3>Экран Card Details (редактор)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Вкладка Data</h3>
        <ul>
          <li>Форма полей карточки.</li>
          <li>Валидация на лету (schemas.ts).</li>
          <li>Серые секции по смыслу: Vehicle / Price / Location / Text.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Вкладка Photos</h3>
        <ul>
          <li>Галерея raw/masked.</li>
          <li>Сравнение “до/после”.</li>
          <li>Drag-sort порядка фото.</li>
          <li>Retry по конкретной фотке.</li>
        </ul>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>Вкладка Export</h3>
        <ul>
          <li>История экспортов.</li>
          <li>Ссылка на текущий экспортный файл.</li>
          <li>Статус exporting/exported.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Вкладка Publish</h3>
        <ul>
          <li>История publish_jobs.</li>
          <li>Статус робота/Avito.</li>
          <li>Avito item id + ссылка (если есть).</li>
          <li>Кнопка retry при publish_failed (если разрешено).</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <h3>Вкладка History</h3>
      <ul>
        <li>Лента AuditLog по карточке.</li>
        <li>Кто/когда менял поля и статусы.</li>
        <li>Ошибки стадий и попытки retry.</li>
      </ul>
    </div>
  </div>

  <!-- Operator workflow -->
  <div class="content-block">
    <h3>Рабочий сценарий оператора (коротко)</h3>

    <ol class="steps">
      <li>Открывает /cards с фильтром “draft”.</li>
      <li>Выбирает карточки → Start Photos.</li>
      <li>Ждёт photos_ready (WS обновляет таблицу).</li>
      <li>Открывает карточку → проверяет Data/Photos → Mark Ready for Export.</li>
      <li>Создаёт Export по готовым карточкам.</li>
      <li>После ready_for_publish → Start Publish.</li>
      <li>Следит за published/publish_failed.</li>
    </ol>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Operator UI состоит из Dashboard, Cards List, Card Details и доменных очередей Photos/Export/Publish.
    Главный экран — таблица карточек с фильтрами и bulk actions по state machine.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    нужны ли дополнительные “мастера” (wizard) для массовой проверки карточек — решим после MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 17 (L2): Admin UI — ключевые экраны и логика          -->
<!-- Системный контур: очереди, DLQ, логи, интеграции, роли     -->
<!-- ========================================================= -->
<section id="p17" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 17.</span>
    Admin UI — ключевые экраны и логика
  </h2>
  <p class="subtitle">
    Системный контур админа: наблюдаемость и управление pipeline,
    интеграциями, пользователями и аварийными сценариями.
  </p>
  <div class="level-pill">L2 — системные экраны</div>

  <!-- Purpose -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Цель Admin UI</h3>
    <p>
      Admin UI нужен не для “работы с карточками”, а для
      <strong>поддержания здоровья конвейера</strong>.  
      Админ должен быстро видеть: где узкое место, что упало, почему,
      и иметь безопасные рычаги восстановления.
    </p>
  </div>

  <!-- Pages map -->
  <div class="content-block">
    <h3>Карта страниц Admin UI</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>/admin/dashboard</h3>
        <ul>
          <li>KPI pipeline: throughput, retries%, DLQ growth.</li>
          <li>Глубина очередей по типам.</li>
          <li>Сводка health интеграций.</li>
          <li>Топ причин ошибок за сутки.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/admin/queues</h3>
        <ul>
          <li>Список очередей (photos/export/publish/parser/status).</li>
          <li>Depth, rate, avg latency.</li>
          <li>Фильтр по status queued/retrying/processing.</li>
          <li>Pause/Resume конкретной очереди.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/admin/dlq</h3>
        <ul>
          <li>Все фатальные задачи.</li>
          <li>Причина, payload, attempts, сервис-источник.</li>
          <li>Retry / Bulk retry / Drop.</li>
          <li>Ссылки на затронутые Cards.</li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>/admin/logs</h3>
        <ul>
          <li>Поиск по audit_logs и system_logs.</li>
          <li>Фильтры: user, card_id, action, time range.</li>
          <li>Склейка событий по correlation_id.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/admin/integrations</h3>
        <ul>
          <li>Health всех внешних сервисов.</li>
          <li>Последний ping / latency.</li>
          <li>Отображение текущих endpoints.</li>
          <li>Test-call (owner).</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>/admin/users-roles</h3>
        <ul>
          <li>Список пользователей.</li>
          <li>Назначение/снятие ролей.</li>
          <li>Блокировка аккаунта.</li>
          <li>Просмотр истории действий.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Queues screen -->
  <div class="content-block">
    <h3>Экран Queues (центральный для админа)</h3>

    <div class="grid-2">
      <div class="card">
        <h3>Что видно</h3>
        <ul>
          <li>Очередь → depth (сколько задач).</li>
          <li>Rate (задач/мин).</li>
          <li>Средняя задержка (latency).</li>
          <li>Retrying %.</li>
          <li>Последняя ошибка.</li>
        </ul>
      </div>

      <div class="card">
        <h3>Что можно делать</h3>
        <ul>
          <li>pause/resume очередь.</li>
          <li>просмотреть задачи в разрезе status.</li>
          <li>перевести конкретную задачу в retry сейчас.</li>
          <li>перепривязать задачу к Card (крайний случай).</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <p class="small muted" style="margin-bottom:6px;">
        Важно:
      </p>
      <ul>
        <li>pause — только безопасный стоп (не убиваем processing).</li>
        <li>resume — поднимает воркеров/разрешает бэкенду брать новые задачи.</li>
        <li>Любое действие пишет audit-log.</li>
      </ul>
    </div>
  </div>

  <!-- DLQ screen -->
  <div class="content-block">
    <h3>Экран DLQ (разбор фаталов)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Столбцы DLQ</h3>
        <ul>
          <li>origin_queue</li>
          <li>entity_ref (card/photo/export/publish_job)</li>
          <li>fatal_reason (Validation/Business/Integration)</li>
          <li>last_error_code</li>
          <li>created_at</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Функции DLQ</h3>
        <ul>
          <li><strong>Open payload</strong> (сырой JSON).</li>
          <li><strong>Open card</strong> → переход в Card Details.</li>
          <li><strong>Retry</strong> — вернуть в origin_queue.</li>
          <li><strong>Bulk retry</strong> — по фильтру причины.</li>
          <li><strong>Drop</strong> — удалить задачу (только owner).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Integrations -->
  <div class="content-block">
    <h3>Экран Integrations</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Сервис</th>
          <th>Health</th>
          <th>Latency</th>
          <th>Последний успех</th>
          <th>Действия</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Parser API</strong></td>
          <td>ok/fail</td>
          <td>ms</td>
          <td>ts</td>
          <td>test, view endpoint</td>
        </tr>
        <tr>
          <td><strong>Photo API</strong></td>
          <td>ok/fail</td>
          <td>ms</td>
          <td>ts</td>
          <td>test, view endpoint</td>
        </tr>
        <tr>
          <td><strong>S3 Storage</strong></td>
          <td>ok/fail</td>
          <td>ms</td>
          <td>ts</td>
          <td>test, buckets</td>
        </tr>
        <tr>
          <td><strong>Dolphin API</strong></td>
          <td>ok/fail</td>
          <td>ms</td>
          <td>ts</td>
          <td>test profiles</td>
        </tr>
        <tr>
          <td><strong>Avito (via Robot)</strong></td>
          <td>ok/fail</td>
          <td>ms</td>
          <td>ts</td>
          <td>test publish dry-run</td>
        </tr>
      </tbody>
    </table>

    <p class="muted small" style="margin-top:6px;">
      Изменение endpoints и чувствительных параметров доступно только Owner/Superadmin.
    </p>
  </div>

  <!-- Users/Roles -->
  <div class="content-block">
    <h3>Экран Users & Roles</h3>
    <div class="card gray">
      <ul>
        <li>Список пользователей с ролями и статусом аккаунта.</li>
        <li>Назначение роли = добавление permission-set.</li>
        <li>Снятие роли не удаляет историю действий.</li>
        <li>Блокировка аккаунта запрещает login и любые новые действия.</li>
      </ul>
    </div>
  </div>

  <!-- Admin workflow -->
  <div class="content-block">
    <h3>Рабочий сценарий админа (коротко)</h3>

    <ol class="steps">
      <li>Смотрит /admin/dashboard: есть ли рост DLQ или очередей.</li>
      <li>Если очередь растёт — проверяет Integrations health и workers.</li>
      <li>Если DLQ растёт — открывает DLQ, сортирует по fatal_reason.</li>
      <li>Чинит причину (контракт/сервис/маппинг) и делает retry.</li>
      <li>Следит за нормализацией rate/latency.</li>
    </ol>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Admin UI включает dashboard, queues, DLQ, logs, integrations, users-roles.
    Главные функции — наблюдаемость pipeline и безопасное восстановление через retry/DLQ.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    нужно ли выносить отдельный экран “Workers fleet” (сколько воркеров и их состояние) — по итогам MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 18 (L2): Инфраструктура, деплой и окружения           -->
<!-- Docker/K8s, dev/stage/prod, конфиги, секреты, автозапуск   -->
<!-- ========================================================= -->
<section id="p18" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 18.</span>
    Инфраструктура, деплой и окружения
  </h2>
  <p class="subtitle">
    Как Autocontent разворачивается и работает в dev/stage/prod:
    контейнеры, сети, конфиги, секреты, автозапуск и эксплуатация.
  </p>
  <div class="level-pill">L2 — инфраструктурный контур</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип окружений</h3>
    <p>
      У системы 3 режима: <strong>dev</strong> (локальная разработка),
      <strong>stage</strong> (предпрод для тестов интеграций),
      <strong>prod</strong> (боевой).  
      Во всех трёх режимах структура контейнеров едина — отличаются только конфиги и секреты.
    </p>
  </div>

  <!-- Containers in infra -->
  <div class="content-block">
    <h3>Контейнеры и сервисы</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>backend</h3>
        <ul>
          <li>PHP ядро + HTTP API</li>
          <li>WS сервер</li>
          <li>миграции БД</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Dockerfile: <code>infra/docker/backend.Dockerfile</code>
        </p>
      </div>

      <div class="card gray">
        <h3>workers</h3>
        <ul>
          <li>PhotoWorker</li>
          <li>ExportWorker</li>
          <li>PublishWorker</li>
          <li>ParserWorker</li>
          <li>RobotStatusWorker</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Dockerfile: <code>infra/docker/workers.Dockerfile</code>
        </p>
      </div>

      <div class="card gray">
        <h3>frontend</h3>
        <ul>
          <li>React Operator/Admin apps</li>
          <li>Статическая сборка</li>
          <li>Раздаётся через nginx</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Dockerfile: <code>infra/docker/frontend.Dockerfile</code>
        </p>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>db</h3>
        <ul>
          <li>Postgres/MySQL</li>
          <li>source of truth</li>
          <li>резервные копии</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>queue backend</h3>
        <ul>
          <li>MVP: DB очередь</li>
          <li>Prod: Redis/Broker</li>
          <li>health + metrics</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>external stack</h3>
        <ul>
          <li>Photo API (on-prem)</li>
          <li>MinIO/S3 storage</li>
          <li>Parser API (внешний)</li>
          <li>Dolphin/Avito (внешние)</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Локально может подниматься частично.
        </p>
      </div>
    </div>
  </div>

  <!-- Compose -->
  <div class="content-block">
    <h3>Docker Compose</h3>

    <div class="grid-2">
      <div class="card">
        <h3>dev compose</h3>
        <ul>
          <li><code>docker-compose.yml</code></li>
          <li>hot-reload для backend/frontend</li>
          <li>точные эндпоинты на локальные external сервисы</li>
        </ul>
      </div>

      <div class="card">
        <h3>prod compose</h3>
        <ul>
          <li><code>docker-compose.prod.yml</code></li>
          <li>без dev-томов и hot-reload</li>
          <li>production nginx + TLS</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px; font-family:var(--mono); font-size:13px;">
      docker compose up -d backend workers frontend db redis minio
    </div>
  </div>

  <!-- K8s -->
  <div class="content-block">
    <h3>Kubernetes (если уходим в кластер)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Манифесты</h3>
        <ul>
          <li><code>infra/k8s/backend.yaml</code></li>
          <li><code>infra/k8s/workers.yaml</code></li>
          <li><code>infra/k8s/frontend.yaml</code></li>
          <li><code>infra/k8s/external.yaml</code></li>
          <li><code>infra/k8s/ingress.yaml</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Скалирование</h3>
        <ul>
          <li>backend — 2+ реплики</li>
          <li>workers — горизонтально по очередям</li>
          <li>frontend — 2+ реплики</li>
          <li>autoscaling по CPU + depth queue (опционально)</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Configs / env -->
  <div class="content-block">
    <h3>Конфиги и секреты</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Что лежит в .env</h3>
        <ul>
          <li>DB_DSN / DB_USER / DB_PASS</li>
          <li>QUEUE_DRIVER (db|redis)</li>
          <li>PARSER_ENDPOINT</li>
          <li>PHOTO_API_ENDPOINT</li>
          <li>S3_ENDPOINT / S3_KEYS</li>
          <li>DOLPHIN_ENDPOINT / TOKEN</li>
          <li>AVITO_ACCOUNT_IDS</li>
          <li>WS_PUBLIC_URL</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Пример: <code>.env.example</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Правила секретов</h3>
        <ul>
          <li>Секреты не коммитим.</li>
          <li>В проде — только Secret Manager/K8s Secrets.</li>
          <li>Ротация ключей Dolphin/Avito/S3 — по процедуре owner.</li>
          <li>Любая смена ключа логируется (audit).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Nginx -->
  <div class="content-block">
    <h3>Nginx и маршрутизация</h3>
    <div class="card gray">
      <ul>
        <li><code>infra/nginx/nginx.dev.conf</code> — прокси на backend + WS + frontend dev.</li>
        <li><code>infra/nginx/nginx.prod.conf</code> — TLS, gzip, cache для статики.</li>
        <li>Единая точка входа: <code>/api/*</code> → backend, остальное → frontend.</li>
        <li>WS: <code>/ws</code> → backend WS сервер.</li>
      </ul>
    </div>
  </div>

  <!-- Autostart scripts -->
  <div class="content-block">
    <h3>Автозапуск / удобство локально</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>autostart.js</h3>
        <ul>
          <li>Поднимает docker compose.</li>
          <li>Ждёт DB/Redis/MinIO.</li>
          <li>Запускает миграции.</li>
          <li>Стартует workers.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>run_app.bat</h3>
        <ul>
          <li>Windows-обёртка для автозапуска.</li>
          <li>Снижает входной порог для команды.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Деплой идёт через Docker Compose (dev/prod) с возможностью перехода на K8s.
    Контейнеры: backend, workers, frontend, db, queue backend, external stack.
    Конфиги через .env, секреты не коммитятся и ротируются по процедуре.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    схема бэкапов DB/Storage и disaster-recovery план — Part 19.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 18 (L2): Инфраструктура, деплой и окружения           -->
<!-- Docker/K8s, dev/stage/prod, конфиги, секреты, автозапуск   -->
<!-- ========================================================= -->
<section id="p18" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 18.</span>
    Инфраструктура, деплой и окружения
  </h2>
  <p class="subtitle">
    Как Autocontent разворачивается и работает в dev/stage/prod:
    контейнеры, сети, конфиги, секреты, автозапуск и эксплуатация.
  </p>
  <div class="level-pill">L2 — инфраструктурный контур</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип окружений</h3>
    <p>
      У системы 3 режима: <strong>dev</strong> (локальная разработка),
      <strong>stage</strong> (предпрод для тестов интеграций),
      <strong>prod</strong> (боевой).  
      Во всех трёх режимах структура контейнеров едина — отличаются только конфиги и секреты.
    </p>
  </div>

  <!-- Containers in infra -->
  <div class="content-block">
    <h3>Контейнеры и сервисы</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>backend</h3>
        <ul>
          <li>PHP ядро + HTTP API</li>
          <li>WS сервер</li>
          <li>миграции БД</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Dockerfile: <code>infra/docker/backend.Dockerfile</code>
        </p>
      </div>

      <div class="card gray">
        <h3>workers</h3>
        <ul>
          <li>PhotoWorker</li>
          <li>ExportWorker</li>
          <li>PublishWorker</li>
          <li>ParserWorker</li>
          <li>RobotStatusWorker</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Dockerfile: <code>infra/docker/workers.Dockerfile</code>
        </p>
      </div>

      <div class="card gray">
        <h3>frontend</h3>
        <ul>
          <li>React Operator/Admin apps</li>
          <li>Статическая сборка</li>
          <li>Раздаётся через nginx</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Dockerfile: <code>infra/docker/frontend.Dockerfile</code>
        </p>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>db</h3>
        <ul>
          <li>Postgres/MySQL</li>
          <li>source of truth</li>
          <li>резервные копии</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>queue backend</h3>
        <ul>
          <li>MVP: DB очередь</li>
          <li>Prod: Redis/Broker</li>
          <li>health + metrics</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>external stack</h3>
        <ul>
          <li>Photo API (on-prem)</li>
          <li>MinIO/S3 storage</li>
          <li>Parser API (внешний)</li>
          <li>Dolphin/Avito (внешние)</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Локально может подниматься частично.
        </p>
      </div>
    </div>
  </div>

  <!-- Compose -->
  <div class="content-block">
    <h3>Docker Compose</h3>

    <div class="grid-2">
      <div class="card">
        <h3>dev compose</h3>
        <ul>
          <li><code>docker-compose.yml</code></li>
          <li>hot-reload для backend/frontend</li>
          <li>точные эндпоинты на локальные external сервисы</li>
        </ul>
      </div>

      <div class="card">
        <h3>prod compose</h3>
        <ul>
          <li><code>docker-compose.prod.yml</code></li>
          <li>без dev-томов и hot-reload</li>
          <li>production nginx + TLS</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px; font-family:var(--mono); font-size:13px;">
      docker compose up -d backend workers frontend db redis minio
    </div>
  </div>

  <!-- K8s -->
  <div class="content-block">
    <h3>Kubernetes (если уходим в кластер)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Манифесты</h3>
        <ul>
          <li><code>infra/k8s/backend.yaml</code></li>
          <li><code>infra/k8s/workers.yaml</code></li>
          <li><code>infra/k8s/frontend.yaml</code></li>
          <li><code>infra/k8s/external.yaml</code></li>
          <li><code>infra/k8s/ingress.yaml</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Скалирование</h3>
        <ul>
          <li>backend — 2+ реплики</li>
          <li>workers — горизонтально по очередям</li>
          <li>frontend — 2+ реплики</li>
          <li>autoscaling по CPU + depth queue (опционально)</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Configs / env -->
  <div class="content-block">
    <h3>Конфиги и секреты</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Что лежит в .env</h3>
        <ul>
          <li>DB_DSN / DB_USER / DB_PASS</li>
          <li>QUEUE_DRIVER (db|redis)</li>
          <li>PARSER_ENDPOINT</li>
          <li>PHOTO_API_ENDPOINT</li>
          <li>S3_ENDPOINT / S3_KEYS</li>
          <li>DOLPHIN_ENDPOINT / TOKEN</li>
          <li>AVITO_ACCOUNT_IDS</li>
          <li>WS_PUBLIC_URL</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Пример: <code>.env.example</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Правила секретов</h3>
        <ul>
          <li>Секреты не коммитим.</li>
          <li>В проде — только Secret Manager/K8s Secrets.</li>
          <li>Ротация ключей Dolphin/Avito/S3 — по процедуре owner.</li>
          <li>Любая смена ключа логируется (audit).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Nginx -->
  <div class="content-block">
    <h3>Nginx и маршрутизация</h3>
    <div class="card gray">
      <ul>
        <li><code>infra/nginx/nginx.dev.conf</code> — прокси на backend + WS + frontend dev.</li>
        <li><code>infra/nginx/nginx.prod.conf</code> — TLS, gzip, cache для статики.</li>
        <li>Единая точка входа: <code>/api/*</code> → backend, остальное → frontend.</li>
        <li>WS: <code>/ws</code> → backend WS сервер.</li>
      </ul>
    </div>
  </div>

  <!-- Autostart scripts -->
  <div class="content-block">
    <h3>Автозапуск / удобство локально</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>autostart.js</h3>
        <ul>
          <li>Поднимает docker compose.</li>
          <li>Ждёт DB/Redis/MinIO.</li>
          <li>Запускает миграции.</li>
          <li>Стартует workers.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>run_app.bat</h3>
        <ul>
          <li>Windows-обёртка для автозапуска.</li>
          <li>Снижает входной порог для команды.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Деплой идёт через Docker Compose (dev/prod) с возможностью перехода на K8s.
    Контейнеры: backend, workers, frontend, db, queue backend, external stack.
    Конфиги через .env, секреты не коммитятся и ротируются по процедуре.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    схема бэкапов DB/Storage и disaster-recovery план — Part 19.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 19 (L2): Monitoring, бэкапы и Disaster Recovery       -->
<!-- Как наблюдаем систему, что бэкапим, как восстанавливаем    -->
<!-- ========================================================= -->
<section id="p19" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 19.</span>
    Monitoring, бэкапы и Disaster Recovery
  </h2>
  <p class="subtitle">
    Как система наблюдается в проде, что именно резервируется и
    как восстанавливаемся при сбоях DB/Storage/интеграций.
  </p>
  <div class="level-pill">L2 — эксплуатация и устойчивость</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип “восстанавливаемости”</h3>
    <p>
      Autocontent считается устойчивым, если после любого сбоя
      мы можем восстановить <strong>статусы pipeline</strong>,
      <strong>историю действий</strong> и <strong>файлы</strong>,
      не создавая дублей карточек и публикаций.
    </p>
  </div>

  <!-- Monitoring stack -->
  <div class="content-block">
    <h3>Monitoring (что наблюдаем)</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Системные метрики</h3>
        <ul>
          <li>CPU / RAM / Disk контейнеров.</li>
          <li>Аптайм backend/WS/workers.</li>
          <li>Доступность DB/Redis/MinIO.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Pipeline метрики</h3>
        <ul>
          <li>Throughput (cards/hour).</li>
          <li>Depth очередей по типам.</li>
          <li>Retry % и среднее attempts.</li>
          <li>DLQ growth rate.</li>
          <li>SLA latency по стадиям.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Интеграционные метрики</h3>
        <ul>
          <li>Health ok/fail.</li>
          <li>Latency внешних сервисов.</li>
          <li>Коды ошибок по сервисам.</li>
          <li>Rate-limit/429 частота.</li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Метрики отображаются на Admin Dashboard и доступны через <code>/metrics</code> (если подключим Prometheus).
    </p>
  </div>

  <!-- Logging -->
  <div class="content-block">
    <h3>Логи</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>System logs</h3>
        <ul>
          <li>ошибки адаптеров и воркеров</li>
          <li>stack traces</li>
          <li>latency + correlation_id</li>
          <li>уровни: debug/info/warn/error</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Audit logs</h3>
        <ul>
          <li>все действия пользователей</li>
          <li>изменения статусов</li>
          <li>админские операции (queues/DLQ)</li>
          <li>снапшоты before/after</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <p class="small muted" style="margin-bottom:6px;">
        Обязательные поля любого лога:
      </p>
      <div style="font-family:var(--mono); font-size:13px;">
        { ts, level, service, module, action, entity_ref?, correlation_id?, message, details? }
      </div>
    </div>
  </div>

  <!-- Backups -->
  <div class="content-block">
    <h3>Бэкапы (что и как резервируем)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Объект</th>
          <th>Частота</th>
          <th>Глубина хранения</th>
          <th>Критичность</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>DB</strong></td>
          <td>каждые 6 часов + daily snapshot</td>
          <td>30 дней</td>
          <td>максимальная</td>
        </tr>
        <tr>
          <td><strong>S3 Storage</strong></td>
          <td>daily sync + versioning</td>
          <td>14–30 дней</td>
          <td>высокая</td>
        </tr>
        <tr>
          <td><strong>.env / configs</strong></td>
          <td>при изменении</td>
          <td>вечно (git/secret vault)</td>
          <td>высокая</td>
        </tr>
        <tr>
          <td><strong>Contracts / schemas</strong></td>
          <td>как часть репозитория</td>
          <td>вечно</td>
          <td>средняя</td>
        </tr>
      </tbody>
    </table>

    <details>
      <summary>Почему DB важнее Storage</summary>
      <ul>
        <li>DB содержит статусы pipeline и связи сущностей — это “карта мира”.</li>
        <li>Storage можно пересоздать частично, если есть ссылки и raw источники.</li>
      </ul>
    </details>
  </div>

  <!-- DR scenarios -->
  <div class="content-block">
    <h3>Disaster Recovery сценарии</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>1) Потеря DB</h3>
        <ol>
          <li>Поднимаем новый инстанс DB.</li>
          <li>Восстанавливаем последний snapshot + incrementals.</li>
          <li>Сверяем версии миграций.</li>
          <li>Включаем backend в режим “read-only check”.</li>
          <li>Resume очереди.</li>
        </ol>
        <p class="muted small">
          Возможные потери — максимум 6 часов данных (по частоте бэкапа).
        </p>
      </div>

      <div class="card gray">
        <h3>2) Потеря Storage / MinIO</h3>
        <ol>
          <li>Поднимаем новый storage.</li>
          <li>Восстанавливаем bucket’ы из daily sync.</li>
          <li>Если часть raw потеряна — догружаем из Parser API (если возможно).</li>
          <li>Перепроверяем ключи в DB.</li>
        </ol>
        <p class="muted small">
          При несовпадениях — Cards в photos_failed, оператор решает вручную.
        </p>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>3) Падение очередей/Redis</h3>
        <ol>
          <li>Resume/поднять redis/broker.</li>
          <li>Если broker потерял задачи — пересоздаём из DB-источника.</li>
          <li>Запускаем workers.</li>
        </ol>
        <p class="muted small">
          DB хранит queue_jobs, поэтому восстановление без потерь.
        </p>
      </div>

      <div class="card gray">
        <h3>4) Падение внешней интеграции</h3>
        <ol>
          <li>Health → fail, очередь растёт.</li>
          <li>RetryPolicy удерживает задачи.</li>
          <li>После восстановления сервиса — ретраи продолжаются.</li>
          <li>DLQ разбирается админом.</li>
        </ol>
      </div>
    </div>
  </div>

  <!-- DR checklist -->
  <div class="content-block">
    <h3>DR чек-лист (что всегда должно быть под рукой)</h3>
    <div class="card gray">
      <ul>
        <li>Последние snapshot DB + ключи доступа к хранилищу бэкапов.</li>
        <li>Список endpoints внешних сервисов (Config/endpoints.php).</li>
        <li>Текущие секреты Dolphin/Avito/S3 в vault.</li>
        <li>Runbooks для DLQ/queues.</li>
        <li>Контакты ответственных владельцев интеграций.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Наблюдаем системные/пайплайн/интеграционные метрики,
    регулярно бэкапим DB и Storage, DR-процедуры опираются на DB как карту pipeline.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    где физически хранить бэкапы (второй DC/облако) — решается с инфраструктурой.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 20 (L2): Тестирование, CI/CD и контроль качества      -->
<!-- Как проверяем систему, что гоняем в пайплайне, релизы      -->
<!-- ========================================================= -->
<section id="p20" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 20.</span>
    Тестирование, CI/CD и контроль качества
  </h2>
  <p class="subtitle">
    Как мы гарантируем корректность Autocontent: уровни тестов,
    что запускается в GitHub Actions, как устроены релизы и проверки контрактов.
  </p>
  <div class="level-pill">L2 — качество и поставка</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип контроля качества</h3>
    <p>
      Pipeline сложный и асинхронный, поэтому качество держим не “ручными проверками”,
      а <strong>тремя уровнями тестов</strong> + <strong>контрактными проверками</strong> +
      <strong>автоматическими релизами</strong>.
    </p>
  </div>

  <!-- Test pyramid -->
  <div class="content-block">
    <h3>Пирамида тестов</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Unit tests</h3>
        <ul>
          <li>Тестируем отдельные модули ядра.</li>
          <li>StateMachine, Validators, Services, Adapters.</li>
          <li>Без реальных внешних API.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Папка: <code>tests/unit/backend</code>, <code>tests/unit/frontend</code>
        </p>
      </div>

      <div class="card gray">
        <h3>Integration tests</h3>
        <ul>
          <li>Тестируем связки модулей.</li>
          <li>Parser → Cards → Photos → Export → Publish.</li>
          <li>Используем fixtures контрактов.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Папка: <code>tests/integration</code>
        </p>
      </div>

      <div class="card gray">
        <h3>E2E tests</h3>
        <ul>
          <li>Прогонка полного цикла как пользователь.</li>
          <li>UI + backend + очередь + воркеры.</li>
          <li>Проверяем важные сценарии.</li>
        </ul>
        <p class="muted small" style="margin-top:6px;">
          Папка: <code>tests/e2e</code>
        </p>
      </div>
    </div>
  </div>

  <!-- Contract tests -->
  <div class="content-block">
    <h3>Контрактные тесты</h3>

    <div class="card gray">
      <ul>
        <li>Каждый контракт в <code>external/*/contracts</code> имеет fixtures.</li>
        <li>Adapters прогоняют fixtures на валидность JSON-схемы.</li>
        <li>Если схема изменилась — тест падает, пока не обновили адаптер и версию.</li>
      </ul>
    </div>

    <details>
      <summary>Минимальные проверки</summary>
      <ul>
        <li>schema_version присутствует и поддерживается.</li>
        <li>обязательные поля не пустые.</li>
        <li>enum значения корректны.</li>
        <li>форматы url/date/number валидны.</li>
      </ul>
    </details>
  </div>

  <!-- CI pipeline -->
  <div class="content-block">
    <h3>CI пайплайн (GitHub Actions)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>ci.yml</h3>
        <ol>
          <li>Install deps (backend composer, frontend npm).</li>
          <li>Lint/format (php-cs-fixer/eslint/prettier).</li>
          <li>Unit tests (backend + frontend).</li>
          <li>Integration tests (с поднятым compose).</li>
          <li>Contract tests.</li>
          <li>Build docker images (test mode).</li>
        </ol>
      </div>

      <div class="card gray">
        <h3>Fail-fast правила</h3>
        <ul>
          <li>Любой невалидный контракт — стоп сборки.</li>
          <li>Падение unit — стоп, без integration.</li>
          <li>Coverage ниже порога — стоп.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Release pipeline -->
  <div class="content-block">
    <h3>Release пайплайн</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>release.yml</h3>
        <ol>
          <li>Tag/release в main.</li>
          <li>Build prod images.</li>
          <li>Push в registry.</li>
          <li>Deploy в prod (compose/k8s).</li>
          <li>Smoke tests /health + critical endpoints.</li>
        </ol>
      </div>

      <div class="card gray">
        <h3>Версионирование релиза</h3>
        <ul>
          <li>SemVer: <code>MAJOR.MINOR.PATCH</code></li>
          <li>PATCH — багфикс без изменения контрактов.</li>
          <li>MINOR — новая функциональность, совместимая по контрактам.</li>
          <li>MAJOR — ломающие изменения (контракты/SM/DB).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Quality gates -->
  <div class="content-block">
    <h3>Quality gates (что не даёт сломать репу)</h3>
    <div class="card gray">
      <ul>
        <li>PR требует зелёный CI.</li>
        <li>Запрещены прямые пуши в main (только через PR).</li>
        <li>Обязателен review от владельца домена (backend/frontend/infra).</li>
        <li>Любые изменения контрактов требуют bump версии + обновление fixtures.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Качество держим через unit/integration/e2e + контрактные тесты.
    CI в PR гоняет линтеры и тесты, релизы версионируются по SemVer,
    main защищён quality gates.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точные пороги coverage и набор smoke-сценариев — фиксируем при запуске MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 21 (L2): MVP-объем, roadmap и порядок реализации      -->
<!-- Что делаем первым, что позже, как не раздувать систему     -->
<!-- ========================================================= -->
<section id="p21" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 21.</span>
    MVP-объем, roadmap и порядок реализации
  </h2>
  <p class="subtitle">
    Фиксируем “ограниченную, но гибкую” версию Autocontent:
    что точно входит в первый релиз, что откладываем и в какой очереди строим.
  </p>
  <div class="level-pill">L2 — план поставки</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип MVP</h3>
    <p>
      MVP — это <strong>полный рабочий цикл pipeline</strong> без украшательств,
      но с надежностью и наблюдаемостью.  
      Мы делаем минимальный набор, который уже даёт бизнес-ценность:
      “спарсили → обработали фото → экспорт → публикация → статусы в UI”.
    </p>
  </div>

  <!-- MVP scope -->
  <div class="content-block">
    <h3>Что входит в MVP (обязательно)</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Core / Backend</h3>
        <ul>
          <li>Cards domain + StateMachine.</li>
          <li>ParserAdapter (auto-parser.ru).</li>
          <li>PhotoApiAdapter + S3Adapter (MinIO).</li>
          <li>ExportGenerator (1 формат, напр. xlsx).</li>
          <li>PublishOrchestrator + RobotAdapter + DolphinAdapter.</li>
          <li>Очереди + воркеры (DB queue или Redis).</li>
          <li>WS события для UI.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Operator UI</h3>
        <ul>
          <li>Dashboard KPI.</li>
          <li>Cards List с фильтрами и bulk actions.</li>
          <li>Card Details (Data/Photos/Export/Publish/History).</li>
          <li>Pages Photos/Export/Publish.</li>
          <li>WS live-статусы.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Admin UI</h3>
        <ul>
          <li>Queues (depth/rate/pause/resume).</li>
          <li>DLQ (list/retry/bulk retry).</li>
          <li>Integrations health.</li>
          <li>Logs (audit + system).</li>
          <li>Users/Roles управление.</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <h3>Маркеры готовности MVP</h3>
      <ul>
        <li>Карточка проходит happy-path до published.</li>
        <li>Ошибки корректно уходят в retry и DLQ.</li>
        <li>Оператор видит прогресс стадий в реальном времени.</li>
        <li>Админ может восстановить pipeline через DLQ/queues.</li>
      </ul>
    </div>
  </div>

  <!-- Post-MVP -->
  <div class="content-block">
    <h3>Что делаем после MVP (Phase 2)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Улучшения pipeline</h3>
        <ul>
          <li>Export в нескольких форматах.</li>
          <li>Advanced маппинг Avito полей + шаблоны.</li>
          <li>Распределение публикаций по аккаунтам/профилям.</li>
          <li>Авто-решения части ошибок (self-heal).</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Фронтенд/UX расширения</h3>
        <ul>
          <li>Wizard-потоки (массовая проверка, массовый publish).</li>
          <li>Персональные очереди/assign карточек.</li>
          <li>Глубокие отчёты/аналитика.</li>
          <li>Ночной режим (если нужен).</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Implementation order -->
  <div class="content-block">
    <h3>Порядок реализации (roadmap по этапам)</h3>

    <ol class="steps">
      <li>
        <strong>Фаза A — ядро и модель данных</strong><br/>
        Cards + DB + StateMachine + базовые Validators.
      </li>
      <li>
        <strong>Фаза B — внешние интеграции входа/фото/хранилища</strong><br/>
        ParserAdapter → Photos pipeline → S3Adapter.
      </li>
      <li>
        <strong>Фаза C — экспорт</strong><br/>
        ExportGenerator + ExportWorker + UI download.
      </li>
      <li>
        <strong>Фаза D — публикация</strong><br/>
        PublishOrchestrator → Robot → Dolphin → Avito status sync.
      </li>
      <li>
        <strong>Фаза E — UI контуры</strong><br/>
        Operator UI (все домены) → Admin UI (queues/DLQ/health/logs).
      </li>
      <li>
        <strong>Фаза F — надежность и прод-контур</strong><br/>
        RetryPolicy, SLA, alerts, CI/CD, runbooks.
      </li>
    </ol>
  </div>

  <!-- Freeze rules -->
  <div class="content-block">
    <h3>“Заморозка структуры” и правила расширения</h3>

    <div class="card gray">
      <ul>
        <li>Текущая структура репозитория считается <strong>фронтиром-стандартом</strong>.</li>
        <li>Новые домены добавляются <strong>только как Modules/* + features/*</strong>.</li>
        <li>Интеграции добавляются через <strong>Adapters/* + external/*/contracts</strong>.</li>
        <li>Нельзя смешивать доменную логику в Adapters или UI.</li>
        <li>Любое расширение должно вписываться в StateMachine, иначе это отдельный домен.</li>
      </ul>
    </div>

    <details>
      <summary>Как безопасно расширять систему</summary>
      <ul>
        <li>Сначала пишем контракт + fixtures.</li>
        <li>Дальше — адаптер/модуль/feature.</li>
        <li>Добавляем статусы/переходы StateMachine.</li>
        <li>Только потом — UI кнопки и экраны.</li>
      </ul>
    </details>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    MVP = полный цикл pipeline + Operator/Admin UI + retry/DLQ/WS.
    Структуру можно считать замороженной: расширяемся только через Modules/Features/Adapters и контракты.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    точный состав Phase 2 и приоритеты уточняются после запуска MVP и замеров нагрузки.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 22 (L1/L2): Глоссарий, термины и правила нейминга     -->
<!-- Чтобы все одинаково понимали сущности и не путались        -->
<!-- ========================================================= -->
<section id="p22" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 22.</span>
    Глоссарий, термины и правила нейминга
  </h2>
  <p class="subtitle">
    Единый словарь Autocontent: что значит каждый термин,
    как называем сущности, статусы, файлы и события.
  </p>
  <div class="level-pill">L1/L2 — общий договор</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Зачем нужен глоссарий</h3>
    <p>
      У системы много доменных терминов, интеграций и статусов.
      Глоссарий фиксирует “как мы называем вещи”, чтобы:
      разработчики, операторы и руководство говорили одним языком.
    </p>
  </div>

  <!-- Glossary -->
  <div class="content-block">
    <h3>Глоссарий сущностей</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Термин</th>
          <th>Определение</th>
          <th>Где живёт</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Card (Карточка)</strong></td>
          <td>Центральная сущность — объявление авто, которое проходит pipeline.</td>
          <td>DB: <code>cards</code>, Backend: <code>Modules/Cards</code>, UI: <code>features/cards</code></td>
        </tr>
        <tr>
          <td><strong>Pipeline</strong></td>
          <td>Последовательность стадий draft → photos → export → publish.</td>
          <td>Docs Part 4–11, Backend Workers, UI statuses</td>
        </tr>
        <tr>
          <td><strong>Stage (Стадия)</strong></td>
          <td>Одна часть pipeline (Photos/Export/Publish/Status Sync).</td>
          <td>Backend: Modules + Workers</td>
        </tr>
        <tr>
          <td><strong>Adapter</strong></td>
          <td>Интеграционный слой, скрывающий реализацию внешнего сервиса.</td>
          <td><code>backend/src/Adapters</code></td>
        </tr>
        <tr>
          <td><strong>External Service</strong></td>
          <td>Внешняя или on-prem система, связанная контрактом.</td>
          <td><code>external/*</code> + Adapters</td>
        </tr>
        <tr>
          <td><strong>Worker</strong></td>
          <td>Фоновый consumer, обрабатывающий очередь.</td>
          <td><code>backend/src/Workers</code></td>
        </tr>
        <tr>
          <td><strong>Queue Job</strong></td>
          <td>Задача в очереди для стадии pipeline.</td>
          <td>DB: <code>queue_jobs</code>, Backend: <code>Queues/*</code></td>
        </tr>
        <tr>
          <td><strong>DLQ Job</strong></td>
          <td>Фатальная задача, требующая вмешательства админа.</td>
          <td>DB: <code>dlq_jobs</code>, Admin UI</td>
        </tr>
        <tr>
          <td><strong>Export Package</strong></td>
          <td>Сформированный файл/пакет карточек для передачи дальше.</td>
          <td>DB: <code>exports</code>, Storage: <code>exports/</code></td>
        </tr>
        <tr>
          <td><strong>Publish Job</strong></td>
          <td>Одна попытка публикации карточки роботом в Avito.</td>
          <td>DB: <code>publish_jobs</code>, Backend: <code>Modules/Publish</code></td>
        </tr>
        <tr>
          <td><strong>WS Event</strong></td>
          <td>Событие реального времени о прогрессе pipeline.</td>
          <td><code>backend/src/WS</code>, UI: <code>shared/api/ws.ts</code></td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Naming conventions -->
  <div class="content-block">
    <h3>Правила нейминга (обязательные)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Backend</h3>
        <ul>
          <li>Модуль = домен: <code>Modules/DomainName</code>.</li>
          <li>Файлы: <code>DomainController.php</code>, <code>DomainService.php</code>, <code>DomainModel.php</code>.</li>
          <li>Схемы/валидаторы: <code>DomainSchemas.php</code>, <code>DomainValidators.php</code>.</li>
          <li>Adapters: <code>XxxAdapter.php</code> (1 сервис = 1 адаптер).</li>
          <li>Workers: <code>XxxWorker.php</code> по названию стадии.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Frontend</h3>
        <ul>
          <li>Feature = домен: <code>features/domain</code>.</li>
          <li>Внутри: <code>api.ts</code>, <code>model.ts</code>, <code>schemas.ts</code>, <code>ui/*</code>.</li>
          <li>Компоненты: PascalCase, файл = компонент.</li>
          <li>Хуки: <code>useXxx.ts</code>.</li>
          <li>Guards: <code>XxxGuard.tsx</code>.</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <h3>Contracts / Schemas</h3>
      <ul>
        <li>JSON schema файл: <code>service.action.schema.json</code></li>
        <li>Fixtures: рядом, с тем же префиксом.</li>
        <li>Обязательное поле: <code>schema_version</code>.</li>
        <li>Любое изменение схемы = bump версии + обновление fixtures + адаптеров.</li>
      </ul>
    </div>
  </div>

  <!-- Status naming -->
  <div class="content-block">
    <h3>Нейминг статусов и событий</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Card statuses</h3>
        <ul>
          <li>snake_case</li>
          <li>префикс по стадии: <code>photos_*</code>, <code>export_*</code>, <code>publish_*</code></li>
          <li>терминальные: <code>published</code>, <code>*_failed</code>, <code>blocked</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>WS/HTTP events</h3>
        <ul>
          <li>dot notation: <code>domain.action.state</code></li>
          <li>пример: <code>card.status.updated</code>, <code>photos.progress</code></li>
          <li>payload всегда версии</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Repo navigation -->
  <div class="content-block">
    <h3>Как ориентироваться в репозитории</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      backend/        → ядро, API, workers, state machine
      external/       → контракты внешних сервисов + on-prem реализации
      frontend/       → design/shared/features/apps
      infra/          → docker/nginx/k8s, деплой
      docs/           → архитектура, openapi, runbooks
      tests/          → unit/integration/e2e/fixtures/mocks
    </div>

    <p class="muted small" style="margin-top:6px;">
      Если не знаешь, куда класть код — отвечай на вопрос:
      “это домен?” → Modules/Features,  
      “это внешняя интеграция?” → Adapters + external/contracts,  
      “это инфраструктура?” → infra.
    </p>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Термины и нейминг зафиксированы.
    Любое расширение обязано соблюдать: домены в Modules/Features, интеграции в Adapters + contracts,
    статусы snake_case, события dot-notation.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 23 (L1/L2): Правила работы с репозиторием (CONTRIBUTING) -->
<!-- Как коммитим, как добавляем фичи, как не ломаем структуру     -->
<!-- ========================================================= -->
<section id="p23" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 23.</span>
    Правила работы с репозиторием (CONTRIBUTING)
  </h2>
  <p class="subtitle">
    Набор обязательных правил для команды, чтобы структура оставалась “замороженной”,
    а расширения были безопасными и предсказуемыми.
  </p>
  <div class="level-pill">L1/L2 — командный процесс</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Главный принцип</h3>
    <p>
      Репозиторий — это контракт.  
      Мы не “двигаем папки как удобно сегодня”, мы развиваем систему
      через заранее утверждённые точки расширения.
    </p>
  </div>

  <!-- Branching -->
  <div class="content-block">
    <h3>Ветки и базовый flow</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Основные ветки</h3>
        <ul>
          <li><strong>main</strong> — только стабильные релизы.</li>
          <li><strong>develop</strong> — интеграционная ветка (если нужна).</li>
          <li><strong>feature/*</strong> — работа над фичей/доменом.</li>
          <li><strong>fix/*</strong> — багфиксы.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Pull Request правила</h3>
        <ul>
          <li>PR маленький, в пределах одной фичи.</li>
          <li>Обязательно описание “что/зачем/как проверить”.</li>
          <li>CI должен быть зелёным.</li>
          <li>Review от владельца домена.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Where to put code -->
  <div class="content-block">
    <h3>Куда класть новый код (решающее дерево)</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      Если это бизнес-логика домена →
        backend/src/Modules/<Domain> +
        frontend/src/features/<domain>

      Если это интеграция с сервисом →
        backend/src/Adapters/<XxxAdapter> +
        external/<service>/contracts + fixtures

      Если это инфраструктура/деплой →
        infra/ + docker-compose* + k8s*

      Если это документация →
        docs/ (architecture/api-docs/runbooks)

      Если это тесты →
        tests/unit | tests/integration | tests/e2e
    </div>
  </div>

  <!-- Structure freeze rules -->
  <div class="content-block">
    <h3>Правила “заморозки структуры”</h3>

    <div class="card gray">
      <ul>
        <li>Запрещено переименовывать папки верхнего уровня без решения владельца проекта.</li>
        <li>Новые домены добавляются только через:
          <code>Modules/*</code> + <code>features/*</code> + (опционально) <code>Workers/*</code>.</li>
        <li>Нельзя писать доменную логику в <code>Adapters</code>.</li>
        <li>Нельзя писать API-вызовы напрямую из UI мимо <code>shared/api</code>.</li>
        <li>Любое расширение pipeline обязано обновлять:
          <strong>StateMachine</strong> + <strong>contracts</strong> + <strong>tests</strong>.</li>
      </ul>
    </div>
  </div>

  <!-- Contract change process -->
  <div class="content-block">
    <h3>Как менять контракты</h3>

    <ol class="steps">
      <li>Добавить/изменить JSON-schema в <code>external/*/contracts</code>.</li>
      <li>Поднять <code>schema_version</code> (minor или major).</li>
      <li>Обновить fixtures рядом со схемой.</li>
      <li>Обновить соответствующий Adapter и его unit-тесты.</li>
      <li>Обновить OpenAPI/WS docs, если контракт затрагивает UI.</li>
    </ol>

    <div class="callout muted" style="margin-top:8px;">
      Контракт без версии = запрещённый контракт.
    </div>
  </div>

  <!-- StateMachine change process -->
  <div class="content-block">
    <h3>Как менять State Machine</h3>

    <ol class="steps">
      <li>Сначала описать изменение в <code>docs/architecture/state_machine.md</code>.</li>
      <li>Добавить статусы/переходы в <code>backend/src/Utils/StateMachine.php</code>.</li>
      <li>Обновить доменные сервисы/воркеры.</li>
      <li>Обновить UI кнопки/guards на новые статусы.</li>
      <li>Добавить/обновить тесты state machine (unit/e2e).</li>
    </ol>
  </div>

  <!-- Definition of Done -->
  <div class="content-block">
    <h3>Definition of Done для любой фичи</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Backend DoD</h3>
        <ul>
          <li>Есть схемы/валидаторы.</li>
          <li>Есть unit-тесты на сервисы/адаптеры.</li>
          <li>Есть интеграционный тест для цепочки.</li>
          <li>Логи и ошибки нормализованы.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Frontend DoD</h3>
        <ul>
          <li>UI использует design primitives.</li>
          <li>API-вызовы через shared/api.</li>
          <li>Guards/permissions учтены.</li>
          <li>WS подписки обновляют store.</li>
          <li>Есть unit/e2e тест на критичный сценарий.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Commit message rules -->
  <div class="content-block">
    <h3>Сообщения коммитов</h3>

    <div class="card gray">
      <ul>
        <li>Формат: <code>[domain] кратко что сделал</code></li>
        <li>Примеры:
          <code>[cards] add bulk status set</code>,
          <code>[photos] fix retry backoff</code>,
          <code>[publish] map avito errors</code>
        </li>
        <li>Один коммит — одна мысль.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Структура репозитория фиксирована.
    Команда расширяет систему только через Modules/Features/Adapters/Contracts,
    соблюдая процесс изменения схем и state machine и Definition of Done.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 24 (L2): API фасад, эндпоинты и правила совместимости -->
<!-- Обзор публичного API для UI и внешних вызовов             -->
<!-- ========================================================= -->
<section id="p24" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 24.</span>
    API фасад, эндпоинты и правила совместимости
  </h2>
  <p class="subtitle">
    Какие REST/WS API предоставляет ядро, как они группируются по доменам,
    как их использовать во фронте и как их расширять без ломания клиентов.
  </p>
  <div class="level-pill">L2 — API слой</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип API фасада</h3>
    <p>
      Backend отдаёт <strong>единый API для обоих UI-контуров</strong>.
      Фронт не должен “знать” про внутренние воркеры или очереди —
      он общается только через facade-endpoints и WS события.
    </p>
  </div>

  <!-- API groups -->
  <div class="content-block">
    <h3>Группы API по доменам</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Auth</h3>
        <ul>
          <li><code>POST /auth/login</code></li>
          <li><code>POST /auth/logout</code></li>
          <li><code>GET /me</code></li>
          <li><code>POST /auth/refresh</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Cards</h3>
        <ul>
          <li><code>GET /cards</code> (filters, pagination)</li>
          <li><code>GET /cards/:id</code></li>
          <li><code>PATCH /cards/:id</code></li>
          <li><code>POST /cards/bulk</code></li>
          <li><code>POST /cards/:id/status</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Parser</h3>
        <ul>
          <li><code>POST /parser/push</code> (внутр. вход)</li>
          <li><code>GET /parser/health</code></li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>Photos</h3>
        <ul>
          <li><code>POST /cards/:id/photos/start</code></li>
          <li><code>POST /photos/:id/retry</code></li>
          <li><code>GET /cards/:id/photos</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Export</h3>
        <ul>
          <li><code>POST /exports</code> (create)</li>
          <li><code>GET /exports</code></li>
          <li><code>GET /exports/:id</code></li>
          <li><code>GET /exports/:id/download</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Publish</h3>
        <ul>
          <li><code>POST /publish</code> (start job)</li>
          <li><code>GET /publish/jobs</code></li>
          <li><code>POST /publish/jobs/:id/retry</code></li>
          <li><code>GET /publish/jobs/:id</code></li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>Admin: Queues</h3>
        <ul>
          <li><code>GET /admin/queues</code></li>
          <li><code>GET /admin/queues/:type/jobs</code></li>
          <li><code>POST /admin/queues/:type/pause</code></li>
          <li><code>POST /admin/queues/:type/resume</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Admin: DLQ</h3>
        <ul>
          <li><code>GET /admin/dlq</code></li>
          <li><code>GET /admin/dlq/:id</code></li>
          <li><code>POST /admin/dlq/:id/retry</code></li>
          <li><code>POST /admin/dlq/bulk-retry</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Admin: System</h3>
        <ul>
          <li><code>GET /admin/health</code></li>
          <li><code>GET /admin/logs</code></li>
          <li><code>GET /admin/users</code></li>
          <li><code>POST /admin/users/:id/roles</code></li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Полная спецификация: <code>docs/api-docs/openapi.yaml</code>.
    </p>
  </div>

  <!-- Pagination/filtering -->
  <div class="content-block">
    <h3>Пагинация и фильтры (Cards)</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      GET /cards?status=draft,photos_ready
                &make=toyota
                &model=camry
                &year_from=2019
                &price_min=1200000
                &price_max=2500000
                &city=moscow
                &page=1
                &limit=50
                &sort=updated_at:desc
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>Фильтры соответствуют индексам БД (см. Part 13).</li>
        <li>limit по умолчанию 50, максимум 200.</li>
        <li>Любая сортировка должна быть по индексируемому полю.</li>
      </ul>
    </div>
  </div>

  <!-- DTO rules -->
  <div class="content-block">
    <h3>DTO правила (что отдаём в UI)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>CardDTO</h3>
        <ul>
          <li>только нормализованные поля</li>
          <li>status + stage_progress</li>
          <li>errors (human + code)</li>
          <li>timestamps</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>JobDTO (photos/export/publish)</h3>
        <ul>
          <li>job_id, type, status</li>
          <li>attempts, next_retry_at</li>
          <li>last_error (code/message)</li>
          <li>entity_ref</li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      DTO = “проекция”, не содержащая внутренних деталей реализаций сервисов.
    </p>
  </div>

  <!-- Compatibility -->
  <div class="content-block">
    <h3>Совместимость API</h3>

    <div class="card gray">
      <ul>
        <li>API версионируется через префикс: <code>/api/v1/...</code>.</li>
        <li>Minor изменения: добавляем необязательные поля в DTO.</li>
        <li>Major изменения: новый префикс v2 и параллельная поддержка v1.</li>
        <li>WS события также имеют <code>schema_version</code>.</li>
      </ul>
    </div>
  </div>

  <!-- Extension rules -->
  <div class="content-block">
    <h3>Как добавлять новые endpoints</h3>

    <ol class="steps">
      <li>Определить домен (Modules/*).</li>
      <li>Добавить Schemas/Validators/Controller/Service.</li>
      <li>Прописать маршрут в <code>backend/src/Routes/routes.php</code>.</li>
      <li>Обновить OpenAPI + tests.</li>
      <li>Подключить в frontend через <code>shared/api/endpoints.ts</code>.</li>
    </ol>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Backend даёт единый API фасад для UI.
    Эндпоинты группируются по доменам, фильтры карточек соответствуют индексам БД,
    совместимость держим через /v1 + schema_version в WS.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    финальный набор endpoints для Photos/Publish может уточниться по итогам MVP.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 25 (L2): WS события и real-time протокол             -->
<!-- Что отправляет backend в UI, форматы payload, подписки     -->
<!-- ========================================================= -->
<section id="p25" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 25.</span>
    WS события и real-time протокол
  </h2>
  <p class="subtitle">
    Детальный контракт событий между backend и UI: какие типы событий есть,
    когда они отправляются, какие payload несут и как фронт на них реагирует.
  </p>
  <div class="level-pill">L2 — real-time слой</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип real-time в Autocontent</h3>
    <p>
      UI не делает постоянный polling на прогресс стадий.
      Источник истины — backend, а обновления приходят через WS:
      <strong> любое изменение статуса или прогресса → событие → обновление store → UI</strong>.
    </p>
  </div>

  <!-- WS channel -->
  <div class="content-block">
    <h3>WS канал и подключение</h3>

    <div class="card gray">
      <ul>
        <li>Единая точка: <code>GET /ws</code> (через nginx proxy).</li>
        <li>Подключаемся после login и получения access token.</li>
        <li>Токен передаётся в query/header (dev/prod одинаково).</li>
        <li>При обрыве — auto-reconnect с backoff.</li>
      </ul>
    </div>

    <div class="card gray" style="margin-top:8px; font-family:var(--mono); font-size:13px;">
      ws://host/ws?token=JWT
    </div>
  </div>

  <!-- Event envelope -->
  <div class="content-block">
    <h3>Общий envelope события</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px;">
      {
        "event": "card.status.updated",
        "schema_version": "1.0",
        "correlation_id": "c-8f2a...",
        "ts": "2025-12-08T12:00:12Z",
        "payload": { ... }
      }
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li><strong>event</strong> — тип события (dot-notation).</li>
        <li><strong>schema_version</strong> — версия payload.</li>
        <li><strong>correlation_id</strong> — склейка цепочек pipeline.</li>
        <li><strong>ts</strong> — время генерации.</li>
        <li><strong>payload</strong> — доменные данные.</li>
      </ul>
    </div>
  </div>

  <!-- Event catalog -->
  <div class="content-block">
    <h3>Каталог WS событий (L2)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Event</th>
          <th>Когда отправляется</th>
          <th>Payload (ключевые поля)</th>
          <th>Кто слушает</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>card.created</strong></td>
          <td>Card появилась из Parser</td>
          <td>card_id, source_id, status=draft</td>
          <td>CardsList, Dashboard</td>
        </tr>
        <tr>
          <td><strong>card.updated</strong></td>
          <td>Оператор изменил поля</td>
          <td>card_id, changed_fields, updated_at</td>
          <td>CardDetails, CardsList</td>
        </tr>
        <tr>
          <td><strong>card.status.updated</strong></td>
          <td>Смена статуса pipeline</td>
          <td>card_id, from, to, stage_progress</td>
          <td>Все экраны, где есть Card</td>
        </tr>
        <tr>
          <td><strong>photos.progress</strong></td>
          <td>Фото-воркер двигает прогресс</td>
          <td>card_id, total, done, failed</td>
          <td>PhotosPage, CardDetails</td>
        </tr>
        <tr>
          <td><strong>export.created</strong></td>
          <td>Экспорт создан/обновлён</td>
          <td>export_id, status, card_ids</td>
          <td>ExportPage, CardDetails</td>
        </tr>
        <tr>
          <td><strong>publish.progress</strong></td>
          <td>Публикация в процессе</td>
          <td>publish_job_id, card_id, step, message</td>
          <td>PublishPage, CardDetails</td>
        </tr>
        <tr>
          <td><strong>publish.status.updated</strong></td>
          <td>Статус робота/Avito изменился</td>
          <td>publish_job_id, card_id, avito_status</td>
          <td>PublishPage, CardsList</td>
        </tr>
        <tr>
          <td><strong>queue.depth.updated</strong></td>
          <td>Админ-очереди обновились</td>
          <td>queue_type, depth, retrying</td>
          <td>Admin Queues</td>
        </tr>
        <tr>
          <td><strong>dlq.updated</strong></td>
          <td>Изменения в DLQ</td>
          <td>dlq_count, last_fatal_reason</td>
          <td>Admin DLQ/Dashboard</td>
        </tr>
        <tr>
          <td><strong>health.updated</strong></td>
          <td>Health интеграций/системы</td>
          <td>service, status, latency, ts</td>
          <td>Admin Integrations</td>
        </tr>
      </tbody>
    </table>

    <p class="muted small" style="margin-top:6px;">
      Полный список и версии — <code>docs/api-docs/ws-events.md</code>.
    </p>
  </div>

  <!-- Payload examples -->
  <div class="content-block">
    <h3>Примеры payload</h3>

    <details>
      <summary>card.status.updated</summary>
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        "payload": {
          "card_id": 4123,
          "from": "photos_processing",
          "to": "photos_ready",
          "stage_progress": {
            "photos": { "total": 12, "done": 12, "failed": 0 },
            "export": null,
            "publish": null
          },
          "updated_at": "2025-12-08T12:03:41Z"
        }
      </div>
    </details>

    <details>
      <summary>publish.status.updated</summary>
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        "payload": {
          "publish_job_id": 98,
          "card_id": 4123,
          "avito_item_id": "AV-553912",
          "avito_status": "active",
          "robot_status": "done",
          "updated_at": "2025-12-08T12:12:10Z"
        }
      </div>
    </details>
  </div>

  <!-- Frontend handling -->
  <div class="content-block">
    <h3>Как фронт обрабатывает события</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>shared/api/ws.ts</h3>
        <ul>
          <li>поднимает соединение</li>
          <li>раскидывает события по подпискам</li>
          <li>делает reconnect/backoff</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>shared/api/events.ts</h3>
        <ul>
          <li>маппит WS events → store actions</li>
          <li>выполняет нормализацию payload</li>
          <li>обновляет slices</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>Features вызывают <code>useWSSubscription(eventType, handler)</code>.</li>
        <li>Handler должен быть идемпотентным (двойное событие не ломает UI).</li>
        <li>Если UI пропустил событие — при открытии экрана делаем refresh REST.</li>
      </ul>
    </div>
  </div>

  <!-- Reliability -->
  <div class="content-block">
    <h3>Надёжность WS</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Реконнект</h3>
        <ul>
          <li>1s → 2s → 5s → 15s → 60s</li>
          <li>после восстановления — синхронизируем критичные списки REST-запросом</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Гарантии доставки</h3>
        <ul>
          <li>WS “at most once”.</li>
          <li>Backend не хранит очередь WS событий.</li>
          <li>REST всегда позволяет догнать состояние.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Extension rules -->
  <div class="content-block">
    <h3>Как добавлять новые WS events</h3>

    <ol class="steps">
      <li>Добавить тип события в <code>backend/src/WS/WsEvents.php</code>.</li>
      <li>Описать payload и версию в <code>docs/api-docs/ws-events.md</code>.</li>
      <li>Добавить emitter (модуль/воркер) где меняется состояние.</li>
      <li>На фронте — mapping в <code>shared/api/events.ts</code>.</li>
      <li>Добавить тест на корректность payload.</li>
    </ol>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    WS — основной канал прогресса pipeline.
    События версионируются, фронт обрабатывает их идемпотентно,
    а REST остаётся опорой для догоняющей синхронизации.
  </div>
  <div class="callout open">
    <strong>Открытые вопросы:</strong>
    если понадобится “гарантированная доставка” — добавим event log + last_seen_cursor в Phase 2.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 26 (L2): Contracts-first подход и версионирование      -->
<!-- Как мы живём с контрактами внешних сервисов и внутри API    -->
<!-- ========================================================= -->
<section id="p26" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 26.</span>
    Contracts-first подход и версионирование
  </h2>
  <p class="subtitle">
    Правила работы с контрактами: как фиксируются схемы внешних сервисов,
    как мы ими управляем, как обновляем без остановки pipeline.
  </p>
  <div class="level-pill">L2 — интеграционные правила</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип Contracts-first</h3>
    <p>
      В Autocontent контракт важнее реализации.  
      Сначала описываем “какие данные и в каком виде ходят между системами”,
      и только потом пишем код.  
      Это защищает от хаоса, особенно когда есть внешние API (parser, dolphin, avito).
    </p>
  </div>

  <!-- What is a contract -->
  <div class="content-block">
    <h3>Что такое контракт</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Контракт = JSON schema</h3>
        <ul>
          <li>Формально описывает вход/выход сервиса.</li>
          <li>Хранится рядом с сервисом в <code>external/&lt;service&gt;/contracts</code>.</li>
          <li>Имеет версию <code>schema_version</code>.</li>
          <li>Имеет fixtures (пример реальных payload).</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Контракт защищает</h3>
        <ul>
          <li>Backend от неожиданных форматов.</li>
          <li>UI от ломания DTO/WS.</li>
          <li>Стабильность pipeline при деталях интеграций.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Places of contracts -->
  <div class="content-block">
    <h3>Где у нас есть контракты</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Parser</h3>
        <ul>
          <li><code>parser.push.schema.json</code></li>
          <li><code>parser.poll.schema.json</code></li>
          <li><code>parser.health.json</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Photo API</h3>
        <ul>
          <li><code>photo.process.schema.json</code></li>
          <li><code>photo.status.schema.json</code></li>
          <li><code>photo.health.json</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Storage (S3)</h3>
        <ul>
          <li><code>s3.health.json</code></li>
          <li><code>s3.keys.md</code> (док)</li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>Dolphin</h3>
        <ul>
          <li><code>dolphin.profile.schema.json</code></li>
          <li><code>dolphin.health.json</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Avito (via Robot)</h3>
        <ul>
          <li><code>avito.publish.schema.json</code></li>
          <li><code>avito.status.schema.json</code></li>
          <li><code>avito.health.json</code></li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Внутренние API</h3>
        <ul>
          <li>OpenAPI: <code>docs/api-docs/openapi.yaml</code></li>
          <li>WS: <code>docs/api-docs/ws-events.md</code></li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Versioning rules -->
  <div class="content-block">
    <h3>Правила версионирования контрактов</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Тип изменения</th>
          <th>Что делаем с версией</th>
          <th>Пример</th>
          <th>Совместимость</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Backward-compatible</strong></td>
          <td>MINOR bump (1.1 → 1.2)</td>
          <td>добавили optional поле</td>
          <td>старые клиенты живут</td>
        </tr>
        <tr>
          <td><strong>Breaking change</strong></td>
          <td>MAJOR bump (1.x → 2.0)</td>
          <td>переименовали поле, изменили enum</td>
          <td>нужен адаптер v2</td>
        </tr>
        <tr>
          <td><strong>Hotfix schema</strong></td>
          <td>PATCH bump (1.2.0 → 1.2.1)</td>
          <td>починили описание формата</td>
          <td>не меняет payload</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Multi-version handling -->
  <div class="content-block">
    <h3>Как поддерживаем несколько версий</h3>

    <div class="card gray">
      <ul>
        <li>Adapter читает <code>schema_version</code> входящего payload.</li>
        <li>В Adapter есть map: version → normalizer/handler.</li>
        <li>Если версия неизвестна → ValidationError → DLQ.</li>
        <li>Старые версии поддерживаются минимум 1 релизный цикл.</li>
      </ul>
    </div>

    <details>
      <summary>Пример (логика Adapter)</summary>
      <div class="card gray" style="font-family:var(--mono); font-size:13px;">
        switch(schema_version){
          case "1.0": return normalizeV1(payload);
          case "1.1": return normalizeV11(payload);
          default: throw UnsupportedSchemaVersion;
        }
      </div>
    </details>
  </div>

  <!-- Update process -->
  <div class="content-block">
    <h3>Процесс обновления контракта без остановки pipeline</h3>

    <ol class="steps">
      <li>Добавляем новую схему v2 рядом со старой v1.</li>
      <li>Добавляем нормализатор v2 в Adapter.</li>
      <li>Деплоим backend с поддержкой v1+v2.</li>
      <li>Переключаем источник (Parser/Photo/Robot) на v2.</li>
      <li>Собираем статистику ошибок v2.</li>
      <li>После стабилизации — помечаем v1 как deprecated.</li>
    </ol>

    <div class="callout muted" style="margin-top:8px;">
      Главное правило: <strong>сначала поддержка в коде, потом включение у сервиса</strong>.
    </div>
  </div>

  <!-- Contracts tests -->
  <div class="content-block">
    <h3>Контрактные тесты — обязательная страховка</h3>

    <div class="card gray">
      <ul>
        <li>Fixtures валидируются схемой на CI (см. Part 20).</li>
        <li>Adapter unit-тесты прогоняют fixtures и проверяют нормализацию.</li>
        <li>Если контракт меняется и не обновлены fixtures — CI падает.</li>
      </ul>
    </div>
  </div>

  <!-- Who owns contracts -->
  <div class="content-block">
    <h3>Кто владеет контрактами</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Внешние сервисы</h3>
        <ul>
          <li>Owner интеграции (backend lead).</li>
          <li>Согласование изменений с тех. владельцем сервиса.</li>
          <li>Обязательный bump версии.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Внутренние API</h3>
        <ul>
          <li>Owner продукта + frontend lead.</li>
          <li>OpenAPI/WS docs — источник истины для UI.</li>
          <li>Breaking change = новая версия /v2.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Contracts-first обязателен: схемы в external/, fixtures рядом,
    версии schema_version, multi-version support через Adapter map,
    обновление без остановки pipeline по staged-процессу.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 27 (L2): Безопасность, приватность и compliance       -->
<!-- Аутентификация, хранение токенов, доступы к внешним API    -->
<!-- ========================================================= -->
<section id="p27" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 27.</span>
    Безопасность, приватность и compliance
  </h2>
  <p class="subtitle">
    Как защищаем Autocontent: аутентификация и сессии, права доступа,
    безопасная работа с внешними сервисами, хранение данных и аудит.
  </p>
  <div class="level-pill">L2 — безопасность продукта</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип безопасности</h3>
    <p>
      Безопасность здесь — это прежде всего
      <strong>контроль доступа к карточкам и к внешним площадкам</strong>.
      Мы защищаемся не “одним барьером”, а несколькими:
      auth → RBAC → audit → изоляция секретов → ограничение действий робота.
    </p>
  </div>

  <!-- Auth -->
  <div class="content-block">
    <h3>Аутентификация и сессии</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>JWT/Session flow</h3>
        <ul>
          <li>Логин по <code>/auth/login</code> → выдача access + refresh.</li>
          <li>access живёт коротко (минуты), refresh — дольше (дни).</li>
          <li>refresh можно отозвать (logout/блокировка пользователя).</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Правила хранения</h3>
        <ul>
          <li>access — только в памяти приложения (не localStorage).</li>
          <li>refresh — httpOnly cookie или защищённое хранилище.</li>
          <li>При смене роли/флагов — forced refresh.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- RBAC enforcement -->
  <div class="content-block">
    <h3>RBAC как барьер безопасности</h3>
    <div class="card gray">
      <ul>
        <li>Все endpoints защищены middleware (см. Part 12).</li>
        <li>Frontend guards — только UX, не защита.</li>
        <li>Каждый sensitive endpoint пишет audit-log.</li>
      </ul>
    </div>
  </div>

  <!-- External API secrets -->
  <div class="content-block">
    <h3>Секреты внешних сервисов</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Что считаем секретом</h3>
        <ul>
          <li>Dolphin token / profile keys.</li>
          <li>Avito account keys / session artifacts.</li>
          <li>S3 access/secret keys (MinIO).</li>
          <li>Parser API keys.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Как храним</h3>
        <ul>
          <li>Dev — в локальном .env (не коммитим).</li>
          <li>Prod — Secret Vault / K8s Secrets.</li>
          <li>Ротация ключей по регламенту owner.</li>
          <li>Подмена/утечка фиксируется audit-log.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Robot safety -->
  <div class="content-block">
    <h3>Безопасность робота публикации</h3>

    <div class="card gray">
      <ul>
        <li>Robot работает <strong>только</strong> по publish_jobs из backend.</li>
        <li>Robot не имеет “свободного режима” — только заданные действия.</li>
        <li>Ограничение rate-limit публикаций на уровне backend.</li>
        <li>Dry-run режим (feature flag) для безопасных тестов.</li>
        <li>Все действия робота логируются с correlation_id.</li>
      </ul>
    </div>
  </div>

  <!-- Data privacy -->
  <div class="content-block">
    <h3>Приватность данных</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Что храним</h3>
        <ul>
          <li>Метаданные карточки (DB).</li>
          <li>Ссылки на фото (storage keys).</li>
          <li>История действий (audit_logs).</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Что не храним</h3>
        <ul>
          <li>Личные данные пользователей Avito/Dolphin.</li>
          <li>Внутренние cookies/профили Dolphin — не в DB.</li>
          <li>Сырые токены в логах.</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>Фото с номерами автомобилей после маскировки не несут PII.</li>
        <li>Если PII появляется в payload Parser — нормализатор удаляет/маскирует.</li>
      </ul>
    </div>
  </div>

  <!-- Network / CORS -->
  <div class="content-block">
    <h3>Сетевые ограничения</h3>
    <div class="card gray">
      <ul>
        <li>Backend доступен только через nginx/ingress.</li>
        <li>CORS разрешён только для домена фронта.</li>
        <li>WS подключение также ограничено origin.</li>
        <li>В dev можно расширять origin через feature flag.</li>
      </ul>
    </div>
  </div>

  <!-- Audit -->
  <div class="content-block">
    <h3>Аудит и расследование</h3>
    <div class="card gray">
      <ul>
        <li>AuditLog хранит каждое действие пользователя/админа.</li>
        <li>System logs хранят ошибки адаптеров/робота.</li>
        <li>По correlation_id можно восстановить полный путь карточки.</li>
      </ul>
    </div>
  </div>

  <!-- Minimal compliance -->
  <div class="content-block">
    <h3>Минимальные требования compliance для MVP</h3>
    <div class="card gray">
      <ul>
        <li>Секреты не в репозитории.</li>
        <li>RBAC включён на все endpoints.</li>
        <li>Аудит доступен админам.</li>
        <li>Ошибки без PII в логах.</li>
        <li>Доступ к прод-окружению только по списку.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Безопасность строится на auth + RBAC + audit + изоляции секретов.
    Robot работает только по заданиям backend, секреты не попадают в код/логи,
    PII не хранится в DB и маскируется на входе.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 28 (L2): Производительность и масштабирование         -->
<!-- Где будут узкие места, как мы их заранее учитываем         -->
<!-- ========================================================= -->
<section id="p28" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 28.</span>
    Производительность и масштабирование
  </h2>
  <p class="subtitle">
    Как Autocontent выдерживает рост объёма карточек: где ожидаем нагрузку,
    как ограничиваем, распараллеливаем и не теряем стабильность pipeline.
  </p>
  <div class="level-pill">L2 — производственный контур</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип производительности</h3>
    <p>
      Производительность достигается не “быстрым кодом”, а правильным разрезом:
      <strong>очереди → воркеры → идемпотентность → лимиты интеграций</strong>.  
      Мы заранее проектируем так, чтобы любой этап можно было усилить
      независимо от остальных.
    </p>
  </div>

  <!-- Load hotspots -->
  <div class="content-block">
    <h3>Главные точки нагрузки</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>1) Parser intake</h3>
        <ul>
          <li>массовое создание Cards</li>
          <li>upsert/merge</li>
          <li>валидация payload</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>2) Photos pipeline</h3>
        <ul>
          <li>скачивание raw фото</li>
          <li>маскировка (CPU/GPU)</li>
          <li>загрузка в storage</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>3) Publish pipeline</h3>
        <ul>
          <li>антибот/браузерная автоматика</li>
          <li>rate-limit Dolphin/Avito</li>
          <li>долгие сессии</li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Export — обычно дешевле, т.к. это CPU+IO локально и без внешних лимитов.
    </p>
  </div>

  <!-- Queue-based scaling -->
  <div class="content-block">
    <h3>Масштабирование через очереди</h3>

    <div class="card gray">
      <ul>
        <li>Каждая стадия имеет свою очередь (<code>photos</code>, <code>export</code>, <code>publish</code>…).</li>
        <li>Каждый Worker масштабируется отдельно (replicas).</li>
        <li>Если стадия узкая — увеличиваем только её воркеры.</li>
        <li>Очереди дают back-pressure: вход идёт быстрее, чем выход, но система не падает.</li>
      </ul>
    </div>

    <div class="card gray" style="margin-top:8px; font-family:var(--mono); font-size:13px;">
      cards intake  →  photos queue  →  photo workers xN
                               ↓
                        export queue  →  export workers xM
                               ↓
                        publish queue → publish workers xK
    </div>
  </div>

  <!-- Idempotency & dedup -->
  <div class="content-block">
    <h3>Идемпотентность и дедупликация</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>На входе Parser</h3>
        <ul>
          <li>Уникальность: <code>(source, source_id)</code>.</li>
          <li>Повторный payload → update карточки, не новый insert.</li>
          <li>Нормализатор вычищает шум/PII.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>В очередях</h3>
        <ul>
          <li>Job содержит <code>idempotency_key</code>.</li>
          <li>Повторное задание не запускает стадию повторно, если она уже done.</li>
          <li>Retry не создаёт дубль publish_jobs.</li>
        </ul>
      </div>
    </div>

    <p class="muted small" style="margin-top:6px;">
      Это ключ к устойчивости при рестартах/повторах/обрывах интеграций.
    </p>
  </div>

  <!-- Rate limits -->
  <div class="content-block">
    <h3>Rate limiting внешних сервисов</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Dolphin / Avito</h3>
        <ul>
          <li>Лимит публикаций на аккаунт/час.</li>
          <li>Лимит параллельных сессий.</li>
          <li>Backoff при 429/anti-bot сигналах.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Parser / Photo API / S3</h3>
        <ul>
          <li>Пакетная обработка (batching).</li>
          <li>Ограничение одновременных запросов.</li>
          <li>RetryPolicy для временных ошибок.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Caching -->
  <div class="content-block">
    <h3>Кеширование</h3>

    <div class="card gray">
      <ul>
        <li>Frontend кеширует списки Cards через queryClient.</li>
        <li>Backend кеширует справочники (марки/модели/города) в памяти/redis.</li>
        <li>WS события инвалидируют кеш выборочно.</li>
      </ul>
    </div>
  </div>

  <!-- DB perf -->
  <div class="content-block">
    <h3>Производительность БД</h3>

    <div class="card gray">
      <ul>
        <li>Фильтры UI опираются на индексы (Part 13).</li>
        <li>Пагинация только keyset/offset-limit с ограничением limit.</li>
        <li>Тяжёлые выборки (audit/logs) — по time range и индексам.</li>
        <li>Транзакции короткие, без блокировок таблиц.</li>
      </ul>
    </div>
  </div>

  <!-- Scaling plan -->
  <div class="content-block">
    <h3>Как масштабируем при росте</h3>

    <ol class="steps">
      <li>Смотрим метрики: какая очередь растёт и какое SLA нарушено.</li>
      <li>Если очередь растёт из-за внешнего лимита → усиливаем backoff, а не воркеры.</li>
      <li>Если очередь растёт из-за CPU/IO → добавляем replicas workers.</li>
      <li>Если DB начинает быть узким местом → включаем read-replica и оптимизируем индексы.</li>
      <li>Если storage узкий → переносим MinIO на отдельный узел + включаем versioning.</li>
    </ol>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Масштабирование строится через независимые очереди и воркеры.
    Основные узкие места — intake parser, photos pipeline и publish pipeline.
    Идемпотентность и rate-limit защищают от дублей и падений интеграций.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 29 (L1/L2): Риски, допущения и открытые решения       -->
<!-- Что может пойти не так, на что опираемся, где нужен выбор  -->
<!-- ========================================================= -->
<section id="p29" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 29.</span>
    Риски, допущения и открытые решения
  </h2>
  <p class="subtitle">
    Фиксируем ключевые допущения проекта, технические и операционные риски,
    и список решений, которые нужно принять до/во время MVP.
  </p>
  <div class="level-pill">L1/L2 — управляем неопределённость</div>

  <!-- Core idea -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Почему важно зафиксировать риски сейчас</h3>
    <p>
      Autocontent — pipeline с внешними сервисами и роботизацией.  
      Значит, главные угрозы — не “код в одном месте”, а
      <strong>интеграции, масштаб, антибот и операционный процесс</strong>.
      Чем раньше их обозначим, тем дешевле будет решение.
    </p>
  </div>

  <!-- Assumptions -->
  <div class="content-block">
    <h3>Ключевые допущения (assumptions)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>A1. Источник данных стабилен</h3>
        <ul>
          <li>auto-parser.ru продолжает отдавать валидные payload.</li>
          <li>Изменения формата приходят заранее (или ловятся контрактами).</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>A2. On-prem сервисы под контролем</h3>
        <ul>
          <li>Photo API и MinIO доступны 24/7 внутри сети.</li>
          <li>Есть хотя бы базовый мониторинг и бэкапы.</li>
        </ul>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>A3. Dolphin/Avito лимиты известны</h3>
        <ul>
          <li>Мы знаем rate-limit и правила антибота.</li>
          <li>Есть пул профилей/аккаунтов под нужный объём.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>A4. Операторский процесс регламентирован</h3>
        <ul>
          <li>Есть роли и ответственность за DLQ/ошибки.</li>
          <li>Операторы понимают happy-path и retry-логику.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Technical risks -->
  <div class="content-block">
    <h3>Технические риски</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>R1. Ломающиеся внешние форматы</h3>
        <ul>
          <li>Parser или Dolphin меняют JSON.</li>
          <li>Риск: массовый DLQ, стоп pipeline.</li>
          <li>Контрмера: contracts-first + multi-version adapters.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>R2. Антибот Avito/Dolphin</h3>
        <ul>
          <li>Блокировки профилей/аккаунтов.</li>
          <li>Риск: publish queue растёт.</li>
          <li>Контрмера: rate-limit, backoff, ротация профилей.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>R3. Нагрузка на Photos</h3>
        <ul>
          <li>CPU/GPU узкое место.</li>
          <li>Риск: очередь фото копится сутками.</li>
          <li>Контрмера: выделенные воркеры + горизонтальное масштабирование.</li>
        </ul>
      </div>
    </div>

    <div class="grid-3">
      <div class="card gray">
        <h3>R4. Неконсистентность статусов</h3>
        <ul>
          <li>Стадия упала после частичного успеха.</li>
          <li>Риск: карточки “застревают”.</li>
          <li>Контрмера: идемпотентность + audit + ручной reset админом.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>R5. Сбой on-prem storage</h3>
        <ul>
          <li>MinIO/диск умер.</li>
          <li>Риск: потеря фото.</li>
          <li>Контрмера: versioning + daily backup + DR-процедура.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>R6. Слабый мониторинг</h3>
        <ul>
          <li>Не замечаем деградацию вовремя.</li>
          <li>Риск: SLA рушится тихо.</li>
          <li>Контрмера: метрики + алерты + Admin dashboard.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Operational risks -->
  <div class="content-block">
    <h3>Операционные риски</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>O1. Нет владельца DLQ</h3>
        <ul>
          <li>Фаталы копятся без реакции.</li>
          <li>Риск: pipeline “умирает” в тишине.</li>
          <li>Контрмера: назначить on-call/ответственного + runbook.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>O2. Некорректная ручная правка</h3>
        <ul>
          <li>Оператор меняет поля “как кажется”.</li>
          <li>Риск: ошибки публикации/мэппинга.</li>
          <li>Контрмера: валидаторы форм + подсказки UI + audit.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Open decisions -->
  <div class="content-block">
    <h3>Открытые решения (принять до финала MVP)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Решение</th>
          <th>Варианты</th>
          <th>Влияние</th>
          <th>Когда фиксируем</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>D1. DB движок</strong></td>
          <td>Postgres / MySQL</td>
          <td>DDL, индексы, миграции</td>
          <td>Фаза A</td>
        </tr>
        <tr>
          <td><strong>D2. Очередь прод-уровня</strong></td>
          <td>Redis Streams / RabbitMQ / DB-queue</td>
          <td>throughput, retry</td>
          <td>между Фазой B и F</td>
        </tr>
        <tr>
          <td><strong>D3. Формат Export MVP</strong></td>
          <td>XLSX / JSON</td>
          <td>UI/генератор/интеграции</td>
          <td>Фаза C</td>
        </tr>
        <tr>
          <td><strong>D4. Лимиты publish</strong></td>
          <td>по аккаунту/профилю/час</td>
          <td>SLA публикаций</td>
          <td>Фаза D</td>
        </tr>
        <tr>
          <td><strong>D5. Периметр мониторинга</strong></td>
          <td>Prometheus+Grafana / простые health-checks</td>
          <td>надежность прод-контуров</td>
          <td>Фаза F</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Exit criteria -->
  <div class="content-block">
    <h3>Как поймём, что риски под контролем</h3>

    <div class="card gray">
      <ul>
        <li>DLQ не растёт “вечно” — есть владелец и среднее время разбора.</li>
        <li>Publish-ошибки держатся в пределах ожидаемых лимитов.</li>
        <li>Photos-очередь стабильно опустошается быстрее, чем наполняется.</li>
        <li>Contracts меняются через версии и не ломают pipeline внезапно.</li>
      </ul>
    </div>
  </div>

  <!-- Callouts -->
  <div class="callout accepted">
    <strong>Утверждено:</strong>
    Зафиксированы ключевые допущения, тех/операционные риски и список решений,
    которые нужно принять в ходе MVP. Это часть “замороженной” архитектуры.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 30 (L1): Финальная фиксация архитектуры и резюме       -->
<!-- Коротко: что это за система, что утверждено, что дальше     -->
<!-- ========================================================= -->
<section id="p30" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 30.</span>
    Финальная фиксация архитектуры и резюме
  </h2>
  <p class="subtitle">
    Закрепляем итог: что такое Autocontent, как работает,
    какая структура репозитория заморожена, и как по ней развиваем продукт.
  </p>
  <div class="level-pill">L1 — финал документа</div>

  <!-- System identity -->
  <div class="card brand" style="margin-bottom:12px;">
    <h3>Autocontent — что это</h3>
    <p>
      Autocontent — это <strong>конвейер автокарточек</strong>, который автоматизирует путь:
      <strong>Parser (Auto.ru/auto-parser.ru) → Cards → Photos → Export → Publish → Avito</strong>
      с наблюдаемостью, ретраями и живыми статусами в UI.
    </p>
    <p class="muted small">
      Главная ценность: меньше ручной рутины + быстрый стабильный выпуск объявлений.
    </p>
  </div>

  <!-- One-screen pipeline recap -->
  <div class="content-block">
    <h3>Конвейер в одном экране</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px; line-height:1.6;">
      Parser(API) → Cards(draft)
                → Photos(queue) → Photo API → Storage
                → Export(queue) → Storage
                → Publish(queue) → Robot → Dolphin → Avito
                → WS статусы в UI
                → DLQ при фатальных ошибках
    </div>
  </div>

  <!-- Repo freeze recap -->
  <div class="content-block">
    <h3>Замороженная структура репозитория (итоговая)</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px; line-height:1.6;">
      full_project/
      ├── backend/     # PHP ядро, домены Modules/*, Adapters/*, Workers/*, Queues/*
      ├── external/    # контракты внешних и on-prem сервисов + fixtures
      ├── frontend/    # React: design/ shared/ features/ apps(operator/admin)
      ├── infra/       # docker/nginx/k8s + compose
      ├── docs/        # C4 модели, OpenAPI, WS events, runbooks
      ├── tests/       # unit / integration / e2e / mocks / fixtures
      └── ...root files
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>Доменная логика — только в <code>backend/src/Modules</code> и <code>frontend/src/features</code>.</li>
        <li>Интеграции — только через <code>Adapters</code> + <code>external/*/contracts</code>.</li>
        <li>Pipeline меняется только через StateMachine + тесты.</li>
      </ul>
    </div>
  </div>

  <!-- What is already approved -->
  <div class="content-block">
    <h3>Что утверждено этим документом</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Архитектура</h3>
        <ul>
          <li>State Machine карточки и стадии pipeline.</li>
          <li>Очереди + воркеры как базовый механизм.</li>
          <li>Adapters как фасад интеграций.</li>
          <li>WS как канал статусов.</li>
          <li>DLQ как механизм фаталов.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>UI и дизайн</h3>
        <ul>
          <li>2 контура UI: Operator/Admin.</li>
          <li>Слоистость фронта: design → shared → features → apps.</li>
          <li>Белая база + серые/черные блоки, акцент бренда ≈15%.</li>
          <li>Статусы через бейджи/прогресс.</li>
        </ul>
      </div>
    </div>

    <div class="grid-2">
      <div class="card gray">
        <h3>Инфра и качество</h3>
        <ul>
          <li>Docker compose (dev/prod) + путь в k8s.</li>
          <li>Contracts-first и versioning.</li>
          <li>Unit/Integration/E2E + contract tests на CI.</li>
          <li>Monitoring + backup + DR процедуры.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>MVP и расширение</h3>
        <ul>
          <li>MVP = полный happy-path конвейера.</li>
          <li>Roadmap по фазам A–F.</li>
          <li>Структура репы “заморожена”, расширяемся через точки расширения.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- How to develop next -->
  <div class="content-block">
    <h3>Как по этому жить и развивать дальше</h3>

    <ol class="steps">
      <li>
        <strong>Любая новая функциональность начинается с контракта.</strong><br/>
        Схема → fixtures → версия → только потом код.
      </li>
      <li>
        <strong>Новые домены добавляем как Modules + features.</strong><br/>
        Не в Adapters, не в Utils, не в UI “напрямую”.
      </li>
      <li>
        <strong>Pipeline меняем через StateMachine.</strong><br/>
        Статусы/переходы → модуль/воркер → UI кнопки/guards → тесты.
      </li>
      <li>
        <strong>Стабильность важнее фич.</strong><br/>
        Сначала надежность/наблюдаемость, потом расширения Phase 2.
      </li>
    </ol>
  </div>

  <!-- Next concrete steps -->
  <div class="content-block">
    <h3>Ближайшие конкретные шаги (после утверждения)</h3>

    <div class="card gray">
      <ol>
        <li>Фаза A: зафиксировать DB движок и поднять базовые миграции.</li>
        <li>Фаза B: подключить ParserAdapter и протянуть draft → photos_queue.</li>
        <li>Собрать Photo API on-prem pipeline и MinIO buckets.</li>
        <li>Фаза C: сделать 1 формат Export и страницу export download.</li>
        <li>Фаза D: сделать RobotAdapter + Dolphin + Avito publish flow.</li>
        <li>Фаза E: добить Operator/Admin UI и WS live-статусы.</li>
        <li>Фаза F: CI/CD, мониторинг, алерты, runbooks.</li>
      </ol>
    </div>
  </div>

  <!-- Final callout -->
  <div class="callout accepted">
    <strong>Финал:</strong>
    Архитектура, структура репозитория и правила расширения Autocontent
    зафиксированы и считаются “замороженными”.
    Дальше работаем строго по Contracts-first, StateMachine и утверждённым точкам расширения.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 31 (Appendix A / L2): Сквозной сценарий в псевдокоде   -->
<!-- "Happy path" от прихода JSON до published + WS/UI          -->
<!-- ========================================================= -->
<section id="p31" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 31.</span>
    Appendix A — Сквозной сценарий (happy path) в псевдокоде
  </h2>
  <p class="subtitle">
    Прямая, наглядная “протяжка” всего конвейера: какие модули/воркеры/адаптеры
    участвуют на каждом шаге и какие статусы меняются.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Зачем эта часть</h3>
    <p>
      Это “операционный план” для разработчика: если читать сверху вниз,
      становится видно <strong>что за чем вызывается</strong> и <strong>какие сущности рождаются</strong>.
    </p>
  </div>

  <div class="content-block">
    <h3>Happy path: Parser → Published</h3>

    <div class="card gray" style="font-family:var(--mono); font-size:13px; line-height:1.7;">
      // 0) Parser push (вход)
      POST /parser/push  → ParserController::push()
        validate(parser.push.schema.json)
        normalized = ParserNormalizer::fromAutoParser(payload)
        card = CardsService::upsertFromParser(normalized)
        card.status = "draft"
        WS.emit("card.created", CardDTO(card))

      // 1) Оператор запускает Photos
      POST /cards/:id/photos/start → PhotosController::start(card_id)
        StateMachine.assert(card.status in ["draft","ready_for_photos"])
        job = PhotosJobs::enqueue(card_id)
        card.status = "photos_queued"
        WS.emit("card.status.updated", ...)

      // 2) PhotosWorker обрабатывает очередь
      PhotosWorker::handle(job)
        card = CardsModel::get(job.card_id)
        card.status = "photos_processing"
        WS.emit("photos.progress", {total, done:0, failed:0})

        raw_urls = ParserModel::getRawPhotoUrls(card_id)
        foreach(url in raw_urls):
          file_raw = PhotoApiAdapter::download(url)
          file_masked = PhotoApiAdapter::maskPlate(file_raw)
          key = S3Adapter::putMasked(file_masked)
          PhotosModel::attach(card_id, key)
          WS.emit("photos.progress", {done:+1})

        card.status = "photos_ready"
        WS.emit("card.status.updated", ...)

      // 3) Оператор/система переводит в ready_for_export
      POST /cards/:id/status {to:"ready_for_export"}
        StateMachine.assert(card.status=="photos_ready")
        card.status="ready_for_export"
        WS.emit("card.status.updated", ...)

      // 4) Создание экспорта
      POST /exports {card_ids:[...]} → ExportController::create()
        foreach(id in card_ids): assert(cards[id].status=="ready_for_export")
        export = ExportService::createExport(card_ids)
        ExportJobs::enqueue(export.id)
        WS.emit("export.created", ExportDTO(export))

      // 5) ExportWorker
      ExportWorker::handle(job)
        export = ExportModel::get(job.export_id)
        export.status="export_processing"
        rows = ExportGenerator::build(export.card_ids)
        file = ExportGenerator::toXlsx(rows)
        key = S3Adapter::putExport(file)
        export.file_key = key
        export.status="exported"
        foreach(card_id in export.card_ids):
          CardsService::setStatus(card_id, "ready_for_publish")
          WS.emit("card.status.updated", ...)
        WS.emit("export.created", ExportDTO(export))

      // 6) Публикация
      POST /publish {card_ids:[...]} → PublishController::start()
        foreach(id): assert(cards[id].status=="ready_for_publish")
        foreach(id):
          job = PublishJobs::enqueue(id)
          CardsService::setStatus(id, "publish_queued")
          WS.emit("card.status.updated", ...)

      // 7) PublishWorker
      PublishWorker::handle(job)
        card = CardsModel::get(job.card_id)
        CardsService::setStatus(card.id, "publish_processing")
        WS.emit("publish.progress", {step:"start"})

        profile = DolphinAdapter::allocateProfile(card)
        session = RobotAdapter::start(profile)
        avito_payload = AvitoAdapter::map(card)
        result = RobotAdapter::publish(session, avito_payload)

        PublishModel::markDone(job.id, result.avito_item_id)
        CardsService::setStatus(card.id, "published")
        WS.emit("publish.status.updated", {avito_status:"active"})
        WS.emit("card.status.updated", ...)

      // 8) UI получает WS и обновляет store
      UI(ws.on("card.status.updated")) → cards.slice.update(...)
      UI(ws.on("photos.progress")) → photos.slice.update(...)
      UI(ws.on("publish.status.updated")) → publish.slice.update(...)
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Сквозной happy-path прозрачно раскладывается на:
    Controllers → Jobs → Queues → Workers → Adapters → WS → UI store.
  </div>
</section>


<!-- ========================================================= -->
<!-- Part 32 (Appendix B / L2): Чек-листы запуска и приемки      -->
<!-- Что нужно для dev, stage и prod, и как подписывать MVP      -->
<!-- ========================================================= -->
<section id="p32" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 32.</span>
    Appendix B — Чек-листы запуска и приемки
  </h2>
  <p class="subtitle">
    Практические списки: что должно быть заведено/поднято,
    и как мы принимаем MVP технически и операционно.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="content-block">
    <h3>Dev checklist (локальная разработка)</h3>
    <div class="card gray">
      <ol>
        <li>.env заполнен локальными endpoints (Parser/Photo/MinIO).</li>
        <li>docker compose up поднимает backend/workers/frontend/db.</li>
        <li>Миграции прогнаны, seed создал admin user.</li>
        <li>WS подключается и шлёт тест-события.</li>
        <li>Fixtures Parser/Photo проходят в contract tests.</li>
      </ol>
    </div>
  </div>

  <div class="content-block">
    <h3>Stage checklist (предпрод)</h3>
    <div class="card gray">
      <ol>
        <li>Подключен реальный Parser API key.</li>
        <li>Photo API поднят на сервере, health ok.</li>
        <li>MinIO поднят, buckets созданы, versioning включен.</li>
        <li>Dolphin токены заведены в vault, profiles готовы.</li>
        <li>Robot dry-run режим включен для первых тестов.</li>
        <li>Admin UI показывает health всех интеграций.</li>
      </ol>
    </div>
  </div>

  <div class="content-block">
    <h3>Prod checklist (боевой запуск)</h3>
    <div class="card gray">
      <ol>
        <li>Секреты только через vault/Secrets (не .env в репе).</li>
        <li>Мониторинг глубины очередей + алерты включены.</li>
        <li>DB бэкапы по расписанию, проверено восстановление.</li>
        <li>MinIO бэкапы + nightly sync в 2-е хранилище.</li>
        <li>Publish rate-limit задан и протестирован.</li>
        <li>Runbooks готовы (DLQ/Integrations/OnCall).</li>
        <li>Ответственные роли назначены (owner/admin/operator).</li>
      </ol>
    </div>
  </div>

  <div class="content-block">
    <h3>Критерии приемки MVP</h3>
    <div class="card gray">
      <ul>
        <li>Happy-path: 50+ карточек прошли до published без ручных фиксов кода.</li>
        <li>Ошибки Parser/Photo/Publish корректно уходят в retry и DLQ.</li>
        <li>Operator UI позволяет довести карточку до готовности без админа.</li>
        <li>Admin UI позволяет остановить/восстановить pipeline и разобрать DLQ.</li>
        <li>WS статусы в UI соответствуют DB конечному состоянию.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Чек-листы фиксируют “как запускать” и “как принимать” MVP
    без расползания требований.
  </div>
</section>


<!-- ========================================================= -->
<!-- Part 33 (Appendix C / L2): Шаблоны экранов и компонентов    -->
<!-- Единые паттерны UI, чтобы не выдумывать каждый раз         -->
<!-- ========================================================= -->
<section id="p33" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 33.</span>
    Appendix C — Шаблоны экранов и UI-паттерны
  </h2>
  <p class="subtitle">
    Набор “скелетов” экранов и повторяемых компонентов,
    которые применяются в Operator/Admin UI.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="content-block">
    <h3>Паттерн 1: Табличный доменный экран</h3>
    <div class="grid-2">
      <div class="card gray">
        <h3>Применение</h3>
        <ul>
          <li>/cards</li>
          <li>/photos</li>
          <li>/export</li>
          <li>/publish</li>
          <li>/admin/queues</li>
          <li>/admin/dlq</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Скелет</h3>
        <ol>
          <li>Header: title + KPI + primary action.</li>
          <li>Filters row (серый контейнер).</li>
          <li>Table card (white).</li>
          <li>Bulk actions bar (sticky).</li>
          <li>Pagination footer.</li>
        </ol>
      </div>
    </div>
  </div>

  <div class="content-block">
    <h3>Паттерн 2: Детальная карточка сущности</h3>
    <div class="grid-2">
      <div class="card gray">
        <h3>Применение</h3>
        <ul>
          <li>/cards/:id</li>
          <li>/exports/:id</li>
          <li>/publish/jobs/:id</li>
          <li>/admin/dlq/:id</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Скелет</h3>
        <ol>
          <li>Top bar: ID + status badges + next actions.</li>
          <li>Tabs по доменам (Data/Photos/Export/Publish/History).</li>
          <li>Секции внутри табов — серые подложки.</li>
          <li>Правый aside: quick info + errors.</li>
        </ol>
      </div>
    </div>
  </div>

  <div class="content-block">
    <h3>Паттерн 3: Health/Monitoring экран</h3>
    <div class="card gray">
      <ul>
        <li>Каждый сервис = строка с badge ok/fail.</li>
        <li>Latency — маленький серый текст.</li>
        <li>Primary action — “Test call”.</li>
        <li>Ошибки раскрываются в panel справа.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Повторяемые UI-компоненты (design/shared)</h3>
    <div class="grid-3">
      <div class="card gray">
        <h3>Badge</h3>
        <ul>
          <li>status / stage</li>
          <li>danger / neutral / accent</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>ProgressBar</h3>
        <ul>
          <li>mini для таблиц</li>
          <li>full для detail view</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Error Callout</h3>
        <ul>
          <li>code + human text</li>
          <li>retry hint</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Эти паттерны — “строительные блоки” UI.  
    Новые экраны должны собираться из них, а не из уникальных решений.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 34 (Appendix D / L2): Модель данных (ERD текстом)     -->
<!-- Сущности БД, связи, ключи — чтобы всем было одинаково ясно -->
<!-- ========================================================= -->
<section id="p34" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 34.</span>
    Appendix D — Модель данных (ERD текстом)
  </h2>
  <p class="subtitle">
    Полный список таблиц MVP, их ключевые поля и связи.
    Это “карта данных” Autocontent.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип модели данных</h3>
    <p>
      <strong>Cards — центр системы.</strong>
      Все остальные сущности либо “принадлежат карточке” (photos/publish_jobs),
      либо “обслуживают конвейер” (queue_jobs/dlq/audit).
    </p>
  </div>

  <!-- Entities -->
  <div class="content-block">
    <h3>Таблицы и поля</h3>

    <div class="card gray">
      <h3>1) users</h3>
      <div class="mono small">
        id (PK), email (UQ), name, password_hash, is_active, created_at, updated_at
      </div>
      <p class="muted small">Назначаются роли через users_roles.</p>
    </div>

    <div class="card gray">
      <h3>2) roles</h3>
      <div class="mono small">
        id (PK), code (UQ), title, permissions_json, created_at
      </div>
    </div>

    <div class="card gray">
      <h3>3) users_roles</h3>
      <div class="mono small">
        user_id (FK users.id), role_id (FK roles.id), assigned_at
      </div>
      <p class="muted small">Связь M:N пользователей и ролей.</p>
    </div>

    <div class="card gray">
      <h3>4) cards</h3>
      <div class="mono small">
        id (PK),
        source, source_id (UQ with source),
        status,
        vehicle_json, price_json, location_json, text_json,
        stage_progress_json,
        last_error_code, last_error_message,
        created_at, updated_at
      </div>
      <p class="muted small">
        Единственная “истина” о карточке + её текущем статусе в pipeline.
      </p>
    </div>

    <div class="card gray">
      <h3>5) parser_payloads</h3>
      <div class="mono small">
        id (PK), card_id (FK cards.id), schema_version,
        raw_json, normalized_json, received_at
      </div>
      <p class="muted small">Храним трассировку входящих данных.</p>
    </div>

    <div class="card gray">
      <h3>6) photos</h3>
      <div class="mono small">
        id (PK), card_id (FK cards.id),
        raw_url, masked_key, sort_order,
        status, last_error_code, last_error_message,
        created_at, updated_at
      </div>
    </div>

    <div class="card gray">
      <h3>7) exports</h3>
      <div class="mono small">
        id (PK), status, file_key,
        card_ids_json,
        created_by (FK users.id),
        created_at, updated_at
      </div>
    </div>

    <div class="card gray">
      <h3>8) publish_jobs</h3>
      <div class="mono small">
        id (PK), card_id (FK cards.id),
        status, attempts,
        dolphin_profile_id, avito_item_id,
        last_error_code, last_error_message,
        created_at, updated_at
      </div>
    </div>

    <div class="card gray">
      <h3>9) queue_jobs</h3>
      <div class="mono small">
        id (PK), queue_type,
        entity_ref_type, entity_ref_id,
        payload_json,
        status (queued|processing|retrying|done|dead),
        attempts, next_retry_at,
        idempotency_key (UQ),
        created_at, updated_at
      </div>
      <p class="muted small">Универсальная очередь для всех стадий.</p>
    </div>

    <div class="card gray">
      <h3>10) dlq_jobs</h3>
      <div class="mono small">
        id (PK), origin_queue_type,
        entity_ref_type, entity_ref_id,
        payload_json,
        fatal_reason, last_error_code, last_error_message,
        attempts, created_at
      </div>
    </div>

    <div class="card gray">
      <h3>11) audit_logs</h3>
      <div class="mono small">
        id (PK), actor_user_id (FK users.id),
        action, entity_ref_type, entity_ref_id,
        before_json, after_json,
        correlation_id, created_at
      </div>
      <p class="muted small">Факт любых системных/пользовательских изменений.</p>
    </div>

    <div class="card gray">
      <h3>12) system_logs (опционально)</h3>
      <div class="mono small">
        id (PK), level, service, module, message,
        details_json, correlation_id, created_at
      </div>
    </div>
  </div>

  <!-- Relations -->
  <div class="content-block">
    <h3>Связи (ERD словами)</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      users 1—N audit_logs
      users M—N roles (через users_roles)

      cards 1—N parser_payloads
      cards 1—N photos
      cards 1—N publish_jobs

      exports N—M cards (через exports.card_ids_json в MVP,
                         затем можно нормализовать в exports_cards)

      queue_jobs → entity_ref (cards/photos/exports/publish_jobs)
      dlq_jobs   → entity_ref (cards/photos/exports/publish_jobs)
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Модель данных MVP зафиксирована. Cards — центр,
    jobs/lq/audit — обслуживают конвейер и наблюдаемость.
  </div>
</section>


<!-- ========================================================= -->
<!-- Part 35 (Appendix E / L2): Таблица State Machine           -->
<!-- Полный список статусов и разрешённых переходов             -->
<!-- ========================================================= -->
<section id="p35" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 35.</span>
    Appendix E — Таблица State Machine
  </h2>
  <p class="subtitle">
    “Законная” карта статусов карточки.  
    UI показывает только допустимые действия, backend режет всё недопустимое.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="content-block">
    <h3>Статусы и переходы (MVP)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Стадия</th>
          <th>Статус</th>
          <th>Кто ставит</th>
          <th>Допустимые next</th>
          <th>Кнопка в UI</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Cards</td>
          <td><strong>draft</strong></td>
          <td>Parser / Operator</td>
          <td>photos_queued, blocked</td>
          <td>Start Photos</td>
        </tr>
        <tr>
          <td>Photos</td>
          <td><strong>photos_queued</strong></td>
          <td>Operator / System</td>
          <td>photos_processing</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Photos</td>
          <td><strong>photos_processing</strong></td>
          <td>PhotoWorker</td>
          <td>photos_ready, photos_failed</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Photos</td>
          <td><strong>photos_failed</strong></td>
          <td>PhotoWorker</td>
          <td>photos_queued, blocked</td>
          <td>Retry Photos</td>
        </tr>
        <tr>
          <td>Photos</td>
          <td><strong>photos_ready</strong></td>
          <td>PhotoWorker</td>
          <td>ready_for_export</td>
          <td>Mark Ready for Export</td>
        </tr>
        <tr>
          <td>Export</td>
          <td><strong>ready_for_export</strong></td>
          <td>Operator</td>
          <td>export_queued</td>
          <td>Create Export</td>
        </tr>
        <tr>
          <td>Export</td>
          <td><strong>export_queued</strong></td>
          <td>System</td>
          <td>export_processing</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Export</td>
          <td><strong>export_processing</strong></td>
          <td>ExportWorker</td>
          <td>ready_for_publish, export_failed</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Export</td>
          <td><strong>export_failed</strong></td>
          <td>ExportWorker</td>
          <td>export_queued, blocked</td>
          <td>Retry Export</td>
        </tr>
        <tr>
          <td>Publish</td>
          <td><strong>ready_for_publish</strong></td>
          <td>ExportWorker / Operator</td>
          <td>publish_queued</td>
          <td>Start Publish</td>
        </tr>
        <tr>
          <td>Publish</td>
          <td><strong>publish_queued</strong></td>
          <td>System</td>
          <td>publish_processing</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Publish</td>
          <td><strong>publish_processing</strong></td>
          <td>PublishWorker</td>
          <td>published, publish_failed</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Publish</td>
          <td><strong>publish_failed</strong></td>
          <td>PublishWorker</td>
          <td>publish_queued, blocked</td>
          <td>Retry Publish</td>
        </tr>
        <tr>
          <td>Publish</td>
          <td><strong>published</strong></td>
          <td>PublishWorker</td>
          <td>—</td>
          <td>—</td>
        </tr>
        <tr>
          <td>System</td>
          <td><strong>blocked</strong></td>
          <td>Admin</td>
          <td>draft (manual reset)</td>
          <td>Unblock (admin)</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    State Machine — замороженный “закон” карточки.
    UI и backend обязаны ему соответствовать.
  </div>
</section>


<!-- ========================================================= -->
<!-- Part 36 (Appendix F / L2): Примеры конфигов и feature flags -->
<!-- Чтобы сразу было ясно, как выглядит настройка системы      -->
<!-- ========================================================= -->
<section id="p36" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 36.</span>
    Appendix F — Примеры конфигов и feature flags
  </h2>
  <p class="subtitle">
    Наглядные примеры: endpoints, роли, флаги, лимиты.
    В репе это лежит в backend/src/Config.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="content-block">
    <h3>Config/endpoints.php (пример)</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      return [
        "parser" => [
          "base_url" => env("PARSER_ENDPOINT"),
          "timeout_ms" => 8000,
        ],
        "photo_api" => [
          "base_url" => env("PHOTO_API_ENDPOINT"),
          "timeout_ms" => 15000,
        ],
        "s3" => [
          "endpoint" => env("S3_ENDPOINT"),
          "bucket_masked" => "masked-photos",
          "bucket_exports" => "exports",
        ],
        "dolphin" => [
          "base_url" => env("DOLPHIN_ENDPOINT"),
          "token" => env("DOLPHIN_TOKEN"),
        ],
        "avito" => [
          "accounts" => explode(",", env("AVITO_ACCOUNT_IDS")),
        ],
      ];
    </div>
  </div>

  <div class="content-block">
    <h3>Config/roles.php (пример)</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      return [
        "operator" => [
          "cards.read", "cards.edit",
          "photos.start", "photos.retry",
          "export.create", "export.download",
          "publish.start", "publish.retry",
        ],
        "admin" => [
          "all.operator",
          "queues.view", "queues.pause", "queues.resume",
          "dlq.view", "dlq.retry", "dlq.bulk_retry",
          "logs.read", "integrations.view",
        ],
        "owner" => [
          "all.admin",
          "integrations.edit",
          "users.manage", "roles.manage",
          "system.feature_flags.edit",
        ],
      ];
    </div>
  </div>

  <div class="content-block">
    <h3>Config/feature_flags.php (пример)</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      return [
        "robot_dry_run" => env_bool("FF_ROBOT_DRY_RUN", true),
        "photos_parallelism" => env_int("FF_PHOTOS_PARALLELISM", 4),
        "publish_rate_limit_per_hour" => env_int("FF_PUBLISH_RPH", 20),
        "contracts_strict_mode" => env_bool("FF_CONTRACTS_STRICT", true),
      ];
    </div>
  </div>

  <div class="content-block">
    <h3>Как флаги влияют на поведение</h3>
    <div class="card gray">
      <ul>
        <li><strong>robot_dry_run</strong>: робот проходит сценарий, но не подтверждает публикацию.</li>
        <li><strong>photos_parallelism</strong>: сколько фото одновременно гоняем в PhotoWorker.</li>
        <li><strong>publish_rate_limit_per_hour</strong>: жёсткий лимит публикаций на аккаунт.</li>
        <li><strong>contracts_strict_mode</strong>: неизвестная schema_version сразу в DLQ.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Конфиги и feature flags — официальный рычаг управления поведением системы
    без переписывания кода.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 37 (Appendix G / L2): Каталог ошибок и retry-политика -->
<!-- Коды ошибок, классификация, что ретраим, что в DLQ         -->
<!-- ========================================================= -->
<section id="p37" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 37.</span>
    Appendix G — Каталог ошибок и retry-политика
  </h2>
  <p class="subtitle">
    Единые правила обработки ошибок во всех стадиях pipeline:
    классификация, коды, условия retry и DLQ.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип ошибок</h3>
    <p>
      Ошибка — это не “провал”, а <strong>сигнал стадии pipeline</strong>.  
      Мы обязаны либо:
      <strong>исправиться retry</strong>, либо
      <strong>остановиться в DLQ</strong> с понятной причиной.
    </p>
  </div>

  <div class="content-block">
    <h3>Классификация ошибок</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Класс</th>
          <th>Описание</th>
          <th>Примеры</th>
          <th>Действие</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Transient</strong></td>
          <td>Временная, сама проходит</td>
          <td>timeouts, 502/503, network fail</td>
          <td>Retry</td>
        </tr>
        <tr>
          <td><strong>RateLimit</strong></td>
          <td>Лимиты внешнего API</td>
          <td>429, anti-bot soft ban</td>
          <td>Retry с backoff</td>
        </tr>
        <tr>
          <td><strong>Validation</strong></td>
          <td>Payload невалиден</td>
          <td>schema mismatch, missing field</td>
          <td>DLQ</td>
        </tr>
        <tr>
          <td><strong>Business</strong></td>
          <td>Доменное правило нарушено</td>
          <td>нет фото, нет цены, forbidden status transition</td>
          <td>UI fix / DLQ</td>
        </tr>
        <tr>
          <td><strong>Fatal</strong></td>
          <td>Не исправляется автоматически</td>
          <td>unsupported schema_version, broken mapping</td>
          <td>DLQ</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="content-block">
    <h3>Единый формат кода ошибки</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      <DOMAIN>.<STAGE>.<CATEGORY>.<CODE>

      Примеры:
      PARSER.INTAKE.VALIDATION.MISSING_FIELD
      PHOTOS.MASK.TRANSIENT.TIMEOUT
      PUBLISH.ROBOT.RATELIMIT.HTTP_429
      EXPORT.GENERATE.BUSINESS.NO_CARDS
    </div>
  </div>

  <div class="content-block">
    <h3>RetryPolicy (MVP)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Попытка</th>
          <th>Задержка</th>
          <th>Примечание</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>1</td><td>1 мин</td><td>быстрое восстановление</td></tr>
        <tr><td>2</td><td>5 мин</td><td>типичный transient</td></tr>
        <tr><td>3</td><td>15 мин</td><td>на случай перегруза</td></tr>
        <tr><td>4</td><td>1 час</td><td>под лимиты/окна сервисов</td></tr>
        <tr><td>5</td><td>6 часов</td><td>последний автоматический шанс</td></tr>
      </tbody>
    </table>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>После 5-й попытки → DLQ.</li>
        <li>Для RateLimit ошибки backoff умножается x2.</li>
        <li>Validation/Fatal не ретраим.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Как UI показывает ошибки</h3>
    <div class="card gray">
      <ul>
        <li>В CardsList — красный badge с кодом класса.</li>
        <li>В CardDetails — Error Callout (code + human text + hint).</li>
        <li>Кнопки Retry доступны только если статус *_failed.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Ошибки типизированы и кодируются единообразно.
    Retry только для transient/ratelimit; validation/fatal → DLQ.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 38 (Appendix H / L2): Инструкции для Codex/агента      -->
<!-- Как агент должен читать репу, какие правила соблюдать       -->
<!-- ========================================================= -->
<section id="p38" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 38.</span>
    Appendix H — Инструкции для Codex/агента
  </h2>
  <p class="subtitle">
    Короткий, но жёсткий набор правил для AI-агента,
    чтобы он генерировал код строго в рамках замороженной архитектуры.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Роль Codex в проекте</h3>
    <p>
      Codex — это “инженер-исполнитель”. Он не придумывает архитектуру,
      а <strong>реализует утверждённое</strong>.  
      Любые отклонения от структуры = ошибка.
    </p>
  </div>

  <div class="content-block">
    <h3>Правила чтения репозитория</h3>
    <div class="card gray">
      <ol>
        <li>Сначала прочитай <code>README.md</code> и <code>AGENT.md</code>.</li>
        <li>Пойми структуру: backend / external / frontend / infra / docs / tests.</li>
        <li>Найди домен, к которому относится задача.</li>
        <li>Проверь StateMachine и контракты до написания кода.</li>
      </ol>
    </div>
  </div>

  <div class="content-block">
    <h3>Правила генерации кода (строгие)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Backend</h3>
        <ul>
          <li>Доменный код только в <code>backend/src/Modules/&lt;Domain&gt;</code>.</li>
          <li>Интеграции только в <code>backend/src/Adapters</code>.</li>
          <li>Фоновые задачи только через <code>Queues</code> + <code>Workers</code>.</li>
          <li>Любая смена статуса — через <code>StateMachine</code>.</li>
          <li>Ошибки обязаны иметь код формата Appendix G.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Frontend</h3>
        <ul>
          <li>UI собирается из primitives в <code>design/</code>.</li>
          <li>Сетевые вызовы только через <code>shared/api</code>.</li>
          <li>Feature-логика в <code>features/&lt;domain&gt;</code>.</li>
          <li>Роуты и страницы только в <code>apps/operator</code> или <code>apps/admin</code>.</li>
          <li>События WS должны маппиться в store.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="content-block">
    <h3>Что агенту запрещено делать</h3>
    <div class="card gray">
      <ul>
        <li>Переименовывать верхние папки проекта.</li>
        <li>Класть доменную логику в Adapters/Utils.</li>
        <li>Прямые fetch/axios из компонентов UI мимо shared/api.</li>
        <li>Добавлять статусы без обновления StateMachine + docs + tests.</li>
        <li>Менять контракты без bump версии и fixtures.</li>
        <li>Удалять audit/логирование “ради чистоты кода”.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Обязательный порядок работы агента над задачей</h3>
    <ol class="steps">
      <li>Определи домен задачи.</li>
      <li>Проверь существующие контракты и StateMachine.</li>
      <li>Сгенерируй/обнови схему (если нужен новый формат).</li>
      <li>Добавь код в правильные папки.</li>
      <li>Добавь минимум 1 unit и 1 integration тест.</li>
      <li>Обнови docs (OpenAPI/WS/architecture если требуется).</li>
    </ol>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Codex работает как исполнитель строго по замороженной структуре:
    домены → Modules/Features, интеграции → Adapters+Contracts, статусы → StateMachine.
  </div>
</section>


<!-- ========================================================= -->
<!-- Part 39 (Appendix I / L2): Quick Start для новых разработчиков -->
<!-- Одна страница: как поднять, где смотреть, что править        -->
<!-- ========================================================= -->
<section id="p39" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 39.</span>
    Appendix I — Quick Start для новых разработчиков
  </h2>
  <p class="subtitle">
    Максимально короткий вход: как поднять проект локально,
    что проверить и как начать фичу, не сломав архитектуру.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="content-block">
    <h3>1) Поднять проект локально</h3>
    <div class="card gray mono small" style="line-height:1.8;">
      git clone &lt;repo&gt;
      cp .env.example .env
      docker compose up -d
      # backend миграции/seed:
      docker compose exec backend php src/DB/Migrations/run.php
      docker compose exec backend php src/DB/Seed/run.php
      # frontend:
      docker compose exec frontend npm i
      docker compose exec frontend npm run dev
    </div>
  </div>

  <div class="content-block">
    <h3>2) Проверка что всё ок</h3>
    <div class="card gray">
      <ol>
        <li><code>GET /admin/health</code> → ok.</li>
        <li>WS подключение работает (видно ping/hello event).</li>
        <li>Залей fixtures Parser → появились draft cards.</li>
        <li>Запусти Photos/Export/Publish на демо карточке.</li>
      </ol>
    </div>
  </div>

  <div class="content-block">
    <h3>3) Где что смотреть</h3>
    <div class="card gray">
      <ul>
        <li>Бизнес-логика: <code>backend/src/Modules</code>.</li>
        <li>Интеграции: <code>backend/src/Adapters</code> + <code>external/*</code>.</li>
        <li>UI доменов: <code>frontend/src/features</code>.</li>
        <li>Страницы: <code>frontend/src/apps/operator|admin</code>.</li>
        <li>Документация: <code>docs/</code> (openapi, ws-events, C4).</li>
        <li>Тесты: <code>tests/</code>.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>4) Как начать новую фичу</h3>
    <ol class="steps">
      <li>Создай ветку <code>feature/&lt;domain&gt;-&lt;short&gt;</code>.</li>
      <li>Определи, нужен ли новый контракт или статус.</li>
      <li>Добавь/обнови Modules + features.</li>
      <li>Проверь DoD (Part 23) и добавь тесты.</li>
      <li>Открой PR с описанием сценария проверки.</li>
    </ol>
  </div>

  <div class="content-block">
    <h3>5) Если не уверен куда класть код</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      "Это домен?" → Modules/Features
      "Это интеграция?" → Adapters + external/contracts
      "Это UI-инфра?" → shared/
      "Это деплой/сервис?" → infra/
      "Это документ/схема?" → docs/ + external/contracts
    </div>
  </div>

  <div class="callout accepted">
    <strong>Документ закрыт.</strong>
    Part 1–39 фиксируют полный каркас Autocontent,
    его архитектуру, структуру репозитория и правила развития.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 40 (Appendix J / L2): Топология деплоя и окружения     -->
<!-- Как физически разворачивается система в dev/stage/prod      -->
<!-- ========================================================= -->
<section id="p40" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 40.</span>
    Appendix J — Топология деплоя и окружения
  </h2>
  <p class="subtitle">
    Наглядно фиксируем, какие сервисы где живут физически,
    как они связаны, и чем отличаются dev/stage/prod окружения.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип топологии</h3>
    <p>
      Autocontent разворачивается как набор независимых сервисов,
      объединённых сетью и общими секретами.  
      Frontend и Backend всегда “вместе”, а внешние/on-prem сервисы — отдельным слоем.
    </p>
  </div>

  <!-- Environments -->
  <div class="content-block">
    <h3>Окружения</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Окружение</th>
          <th>Цель</th>
          <th>Состав</th>
          <th>Секреты</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>dev</strong></td>
          <td>локальная разработка</td>
          <td>docker-compose, fixtures вместо реальных данных</td>
          <td>.env локально</td>
        </tr>
        <tr>
          <td><strong>stage</strong></td>
          <td>предпрод, интеграции</td>
          <td>реальные Parser/Photo/MinIO/Dolphin, dry-run publish</td>
          <td>vault/secrets</td>
        </tr>
        <tr>
          <td><strong>prod</strong></td>
          <td>боевой режим</td>
          <td>полный pipeline, rate-limits, мониторинг, бэкапы</td>
          <td>vault/secrets + ротация</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Physical layout -->
  <div class="content-block">
    <h3>Физическая раскладка сервисов</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Слой ядра (внутри проекта)</h3>
        <ul>
          <li><strong>backend</strong> (php-fpm + nginx)</li>
          <li><strong>workers</strong> (php cli consumers)</li>
          <li><strong>ws</strong> (внутри backend)</li>
          <li><strong>frontend</strong> (react build + nginx)</li>
          <li><strong>db</strong> (postgres/mysql)</li>
          <li><strong>redis/broker</strong> (если в проде)</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Слой внешних/on-prem сервисов</h3>
        <ul>
          <li><strong>parser</strong> (auto-parser.ru API)</li>
          <li><strong>photo-api</strong> (наш маскер номеров)</li>
          <li><strong>storage</strong> (MinIO/S3 compatible)</li>
          <li><strong>dolphin</strong> (антибраузер API)</li>
          <li><strong>avito</strong> (площадка, через робота)</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px; font-family:var(--mono); font-size:13px; line-height:1.7;">
      [User Browser]
           |
           v
      (Frontend Nginx)  ---REST/WS--->  (Backend API + WS)
                                              |
                                              v
                                           (DB)
                                              |
                                              v
                                           (Queues/Broker)
                                              |
                                              v
                                         (Workers Pool)
                                              |
        ----------------------------------------------------------------
        |                 |                 |                 |         |
        v                 v                 v                 v         v
    Parser API       Photo API         MinIO/S3         Dolphin API   Avito
      (in)            (mask)           (store)           (profiles)  (target)
    </div>
  </div>

  <!-- Network boundaries -->
  <div class="content-block">
    <h3>Сетевые границы</h3>

    <div class="card gray">
      <ul>
        <li>Frontend — публичный вход (https).</li>
        <li>Backend — доступен только через ingress/nginx.</li>
        <li>Workers — без публичных портов, в приватной сети.</li>
        <li>Photo API + MinIO — приватный сегмент (on-prem).</li>
        <li>Dolphin/Parser/Avito — внешняя сеть, доступ только из backend/workers.</li>
      </ul>
    </div>
  </div>

  <!-- Compose vs K8s -->
  <div class="content-block">
    <h3>Compose vs Kubernetes</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>docker-compose (dev/stage)</h3>
        <ul>
          <li>Быстрый локальный старт.</li>
          <li>Все сервисы в одном файле.</li>
          <li>Легко включать fixtures.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>k8s (prod при росте)</h3>
        <ul>
          <li>Горизонтальное масштабирование воркеров.</li>
          <li>Rolling updates без даунтайма.</li>
          <li>Удобные secrets/configmaps.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Scaling knobs -->
  <div class="content-block">
    <h3>Рычаги масштабирования (где увеличиваем ресурсы)</h3>
    <div class="card gray">
      <ul>
        <li><strong>workers replicas</strong> → ускоряем конкретную стадию.</li>
        <li><strong>photo-api replicas/узел</strong> → ускоряем маскировку фото.</li>
        <li><strong>db resources + read replica</strong> → ускоряем списки/фильтры.</li>
        <li><strong>minio nodes/disks</strong> → повышаем throughput хранения.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Топология зафиксирована: ядро (frontend/backend/workers/db) живёт вместе,
    внешние и on-prem сервисы — отдельный слой.  
    Dev/Stage/Prod отличаются только источниками данных, секретами и ограничениями publish.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 41 (Appendix K / L2): Метрики, SLA и дашборды          -->
<!-- Что меряем, какие пороги, что показываем в Admin UI         -->
<!-- ========================================================= -->
<section id="p41" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 41.</span>
    Appendix K — Метрики, SLA и дашборды
  </h2>
  <p class="subtitle">
    Фиксируем “что считается нормой” для Autocontent:
    основные метрики pipeline, SLA по стадиям, алерты и виджеты Admin UI.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип наблюдаемости</h3>
    <p>
      Наблюдаемость нужна, чтобы <strong>видеть деградацию раньше бизнеса</strong>.
      Мы меряем не “всё подряд”, а то, что говорит:
      pipeline жив? где узкое место? что сломалось? кто должен реагировать?
    </p>
  </div>

  <!-- Metrics categories -->
  <div class="content-block">
    <h3>Категории метрик</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Throughput</h3>
        <ul>
          <li>cards_ingested_per_hour</li>
          <li>photos_processed_per_hour</li>
          <li>exports_generated_per_hour</li>
          <li>published_per_hour</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Latency</h3>
        <ul>
          <li>time_draft_to_photos_ready</li>
          <li>time_photos_ready_to_exported</li>
          <li>time_ready_for_publish_to_published</li>
          <li>total_time_draft_to_published</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Reliability</h3>
        <ul>
          <li>retry_rate_by_stage</li>
          <li>dlq_rate_by_stage</li>
          <li>fatal_errors_topN</li>
          <li>success_rate_by_stage</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- SLA -->
  <div class="content-block">
    <h3>SLA по стадиям (MVP ориентиры)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Стадия</th>
          <th>SLA (95% карточек)</th>
          <th>Что влияет</th>
          <th>Если хуже — куда смотреть</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Parser → draft</strong></td>
          <td>&lt; 2 мин</td>
          <td>intake + DB write</td>
          <td>Adapter Parser / DB</td>
        </tr>
        <tr>
          <td><strong>Photos</strong></td>
          <td>&lt; 30 мин</td>
          <td>CPU/GPU + Photo API + S3</td>
          <td>photos queue depth, photo-api health</td>
        </tr>
        <tr>
          <td><strong>Export</strong></td>
          <td>&lt; 10 мин</td>
          <td>генератор + S3 upload</td>
          <td>export workers, DB locks</td>
        </tr>
        <tr>
          <td><strong>Publish</strong></td>
          <td>&lt; 2 часа</td>
          <td>лимиты Dolphin/Avito</td>
          <td>publish queue, rate-limit, anti-bot</td>
        </tr>
        <tr>
          <td><strong>Draft → Published total</strong></td>
          <td>&lt; 4 часа</td>
          <td>сумма стадий + ручные шаги</td>
          <td>по stage latency breakdown</td>
        </tr>
      </tbody>
    </table>

    <p class="muted small" style="margin-top:6px;">
      Точные SLA фиксируются после 1–2 недель прод-замеров.
    </p>
  </div>

  <!-- Alerts -->
  <div class="content-block">
    <h3>Алерты (что должно “звонить”)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Queue alerts</h3>
        <ul>
          <li>photos_queue_depth &gt; X (например 500)</li>
          <li>export_queue_depth &gt; Y</li>
          <li>publish_queue_depth &gt; Z</li>
          <li>job_age_p95 &gt; SLA*2</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Error alerts</h3>
        <ul>
          <li>dlq_rate_by_stage spikes</li>
          <li>fatal_errors_topN change</li>
          <li>success_rate_by_stage &lt; threshold</li>
          <li>health.updated = fail</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <ul>
        <li>Адресаты: Owner/Admin on-call.</li>
        <li>В алерте обязательно: stage, error_code, correlation_id, ссылка на Admin UI.</li>
      </ul>
    </div>
  </div>

  <!-- Admin dashboard widgets -->
  <div class="content-block">
    <h3>Admin Dashboard (виджеты)</h3>

    <div class="grid-3">
      <div class="card gray">
        <h3>Pipeline Overview</h3>
        <ul>
          <li>Cards by status (stacked)</li>
          <li>Stage latency p50/p95</li>
          <li>Success rate by stage</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Queues Panel</h3>
        <ul>
          <li>Depth per queue</li>
          <li>In-flight jobs</li>
          <li>Retrying jobs</li>
          <li>Pause/Resume</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Integrations Health</h3>
        <ul>
          <li>Parser / Photo / S3 / Dolphin</li>
          <li>Latency sparkline</li>
          <li>Last error</li>
        </ul>
      </div>
    </div>

    <div class="grid-3" style="margin-top:8px;">
      <div class="card gray">
        <h3>DLQ Panel</h3>
        <ul>
          <li>DLQ count</li>
          <li>Top fatal reasons</li>
          <li>Bulk retry</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Publish Monitor</h3>
        <ul>
          <li>Published/hour</li>
          <li>Anti-bot blocks</li>
          <li>Accounts/profiles load</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Audit / Ops</h3>
        <ul>
          <li>Last admin actions</li>
          <li>Operator activity</li>
          <li>Suspicious spikes</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Data sources -->
  <div class="content-block">
    <h3>Источники метрик</h3>
    <div class="card gray">
      <ul>
        <li>DB агрегации по cards/status + jobs.</li>
        <li>Workers emit counters/timers (если Prometheus).</li>
        <li>Health checks интеграций.</li>
        <li>WS используется только для UI, не как источник метрик.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Метрики и SLA зафиксированы как ориентиры MVP.
    Admin UI показывает throughput/latency/reliability, алерты строятся на очередях,
    DLQ и health интеграций.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 42 (Appendix L / L2): Выпуск релизов, миграции и Rollback -->
<!-- Как выкатываем версии, как обновляем БД, как откатываемся     -->
<!-- ========================================================= -->
<section id="p42" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 42.</span>
    Appendix L — Релизы, миграции и rollback
  </h2>
  <p class="subtitle">
    Правила выпуска новых версий Autocontent:
    как катим код, как мигрируем БД и как быстро откатываемся при проблемах.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип релизов</h3>
    <p>
      Релиз = безопасное изменение pipeline без остановки бизнеса.  
      Поэтому: <strong>сначала совместимость</strong>, потом включение,
      и всегда есть план отката.
    </p>
  </div>

  <!-- Release types -->
  <div class="content-block">
    <h3>Типы релизов</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Тип</th>
          <th>Что меняем</th>
          <th>Риск</th>
          <th>Как катим</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Patch</strong></td>
          <td>фиксы, мелкие улучшения</td>
          <td>низкий</td>
          <td>rolling update</td>
        </tr>
        <tr>
          <td><strong>Minor</strong></td>
          <td>новые optional поля/фичи</td>
          <td>средний</td>
          <td>rolling + feature flags</td>
        </tr>
        <tr>
          <td><strong>Major</strong></td>
          <td>breaking API/StateMachine/contracts</td>
          <td>высокий</td>
          <td>blue/green + параллельные версии</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- DB migrations -->
  <div class="content-block">
    <h3>Миграции БД</h3>

    <div class="card gray">
      <ul>
        <li>Миграции лежат в <code>backend/src/DB/Migrations</code>.</li>
        <li>Каждая миграция — маленькая и обратимая.</li>
        <li>Нельзя делать длительные lock-операции в prod-пике.</li>
        <li>Любая новая колонка сначала nullable, потом заполняем, потом делаем not null.</li>
      </ul>
    </div>

    <details>
      <summary>Правильный порядок для новых полей</summary>
      <div class="card gray mono small" style="line-height:1.7;">
        1) add column nullable
        2) deploy code that writes/reads it
        3) backfill existing rows via worker/cron
        4) add constraint not null (если нужно)
      </div>
    </details>
  </div>

  <!-- Rolling strategy -->
  <div class="content-block">
    <h3>Стратегия выката</h3>

    <ol class="steps">
      <li>Катим backend/API + workers (совместимые).</li>
      <li>Катим frontend (он должен жить и со старым API).</li>
      <li>Если есть новый контракт/статус:
        <strong>поддержка в коде → включение через флаг → снятие старой версии</strong>.
      </li>
      <li>Смотрим метрики/очереди/DLQ 30–60 минут.</li>
      <li>Если норм — фиксируем новую версию в release notes.</li>
    </ol>
  </div>

  <!-- Rollback -->
  <div class="content-block">
    <h3>Rollback — когда и как</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>Триггеры отката</h3>
        <ul>
          <li>DLQ_rate spike &gt; x3 за 10 мин.</li>
          <li>Publish success_rate &lt; threshold.</li>
          <li>photos_queue_depth растёт без снижения.</li>
          <li>health.updated = fail для критичного сервиса.</li>
        </ul>
      </div>

      <div class="card gray">
        <h3>Процедура</h3>
        <ol>
          <li>Отключить фичу флагом (если возможно).</li>
          <li>Откатить backend/workers на предыдущий image tag.</li>
          <li>Откатить frontend (если ломает UX).</li>
          <li>Если миграция breaking — применить down-migration или hotfix.</li>
          <li>Проверить queues/DLQ и прогнать 1 happy-path карточку.</li>
        </ol>
      </div>
    </div>

    <div class="callout muted" style="margin-top:8px;">
      Если откат связан с контрактом → возвращаем источник на старую schema_version
      только после того, как код снова её поддерживает.
    </div>
  </div>

  <!-- Release notes -->
  <div class="content-block">
    <h3>Release notes (что пишем обязательно)</h3>
    <div class="card gray">
      <ul>
        <li>Номер версии + дата.</li>
        <li>Какие домены трогали.</li>
        <li>Изменения StateMachine/Contracts (если есть).</li>
        <li>Новые флаги + их дефолты.</li>
        <li>Риски и план отката.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Релизы безопасные: совместимость сначала, включение потом, rollback всегда готов.
    Миграции маленькие, обратимые и staged.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 43 (Appendix M / L2): План Phase 2 и точки расширения -->
<!-- Что добавляем после MVP, не ломая архитектуру               -->
<!-- ========================================================= -->
<section id="p43" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 43.</span>
    Appendix M — Phase 2: план развития и точки расширения
  </h2>
  <p class="subtitle">
    Финальная карта того, как Autocontent расширяется после MVP:
    какие фичи логичны следующими, где их реализовывать в структуре,
    и какие “гибкие стыки” уже предусмотрены архитектурой.
  </p>
  <div class="level-pill">Appendix / L2 — roadmap</div>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Принцип Phase 2</h3>
    <p>
      Phase 2 не меняет фундамент.  
      Мы усиливаем надёжность, удобство операторов и глубину автоматизации
      <strong>через заранее предусмотренные точки расширения</strong>:
      Modules/Features, Adapters/Contracts, Workers/Queues, StateMachine, Feature flags.
    </p>
  </div>

  <!-- Expansion points -->
  <div class="content-block">
    <h3>Точки расширения (куда добавлять новое)</h3>

    <table class="table">
      <thead>
        <tr>
          <th>Что расширяем</th>
          <th>Где в backend</th>
          <th>Где во frontend</th>
          <th>Нужно ли менять контракты</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Новый домен (напр. Moderation)</td>
          <td><code>Modules/Moderation</code> + (Workers при нужде)</td>
          <td><code>features/moderation</code> + страницы apps</td>
          <td>да, если новый вход/выход</td>
        </tr>
        <tr>
          <td>Новая интеграция (напр. 2-я площадка)</td>
          <td><code>Adapters/NewPlatformAdapter</code></td>
          <td>только новый UI flow, если надо</td>
          <td>да, в <code>external/new-platform</code></td>
        </tr>
        <tr>
          <td>Новая стадия pipeline</td>
          <td>StateMachine + Modules + Workers + Queues</td>
          <td>новый статусный UI + actions</td>
          <td>возможно</td>
        </tr>
        <tr>
          <td>Улучшение UX/операторских инструментов</td>
          <td>как правило без изменений</td>
          <td>features/* + design/shared</td>
          <td>нет</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Phase 2 backlog -->
  <div class="content-block">
    <h3>Backlog Phase 2 (приоритеты)</h3>

    <div class="grid-2">
      <div class="card gray">
        <h3>P1 — надёжность и контроль</h3>
        <ol>
          <li><strong>Guaranteed events</strong> (WS cursor / event log).</li>
          <li><strong>Отложенные публикации</strong> (schedule publish).</li>
          <li><strong>Авто-ремедиация DLQ</strong> (policy-based retry).</li>
          <li><strong>Read replicas DB</strong> для листингов.</li>
        </ol>
      </div>

      <div class="card gray">
        <h3>P1 — удобство операторов</h3>
        <ol>
          <li><strong>Массовые правки</strong> по шаблонам.</li>
          <li><strong>Сравнение версий карточки</strong> (diff view).</li>
          <li><strong>Умные подсказки</strong> “почему не проходит”.</li>
          <li><strong>Визуальные цепочки ошибок</strong> по correlation_id.</li>
        </ol>
      </div>
    </div>

    <div class="grid-2" style="margin-top:8px;">
      <div class="card gray">
        <h3>P2 — глубже автоматизация</h3>
        <ol>
          <li><strong>Auto-moderation</strong> (правила качества карточки).</li>
          <li><strong>Auto-export</strong> по расписанию/триггерам.</li>
          <li><strong>Republish</strong> (обновление цены/текста).</li>
          <li><strong>Авто-распределение аккаунтов</strong> Avito по нагрузке.</li>
        </ol>
      </div>

      <div class="card gray">
        <h3>P3 — мультиплатформенность</h3>
        <ol>
          <li>Новые площадки: Drom, Youla и т.п.</li>
          <li>Единый “Publish Hub” адаптеров.</li>
          <li>Сводная витрина статусов по площадкам.</li>
        </ol>
      </div>
    </div>
  </div>

  <!-- Suggested new modules -->
  <div class="content-block">
    <h3>Какие новые модули вероятны в Phase 2</h3>

    <div class="card gray">
      <ul>
        <li><strong>Modules/Moderation</strong> — правила качества, авто-блокировки.</li>
        <li><strong>Modules/Scheduler</strong> — планирование публикаций/экспортов.</li>
        <li><strong>Modules/Republish</strong> — обновление активных объявлений.</li>
        <li><strong>Modules/Analytics</strong> — витрина KPI, SLA, прогнозы очередей.</li>
        <li><strong>Adapters/PlatformXAdapter</strong> — подключение новых площадок.</li>
      </ul>
    </div>
  </div>

  <!-- Changes to state machine -->
  <div class="content-block">
    <h3>Как будет расширяться State Machine</h3>
    <div class="card gray">
      <ul>
        <li>Добавление новых веток, но без ломания существующих стадий.</li>
        <li>Новые статусы всегда с префиксом стадии (<code>moderation_*</code>, <code>republish_*</code>).</li>
        <li>Старые статусы остаются валидными минимум 1 major релиз.</li>
      </ul>
    </div>
  </div>

  <!-- Guardrails -->
  <div class="content-block">
    <h3>Ограничения (guardrails) Phase 2</h3>
    <div class="card gray">
      <ul>
        <li>Нельзя ломать contracts-first.</li>
        <li>Нельзя обходить Adapters при интеграциях.</li>
        <li>Нельзя добавлять “ручные” статусы без StateMachine.</li>
        <li>Любая автоматизация должна быть обратима флагом.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Финальный итог документа:</strong>
    Phase 2 спланирован как расширение через существующие точки роста.
    Фундамент (структура репы, pipeline, contracts, state machine, UI слои)
    остаётся замороженным.
  </div>
</section>
<!-- ========================================================= -->
<!-- Part 44 (Appendix N / L1-L2): Глоссарий терминов           -->
<!-- Единый словарь, чтобы бизнес/разрабы/операторы говорили     -->
<!-- одинаковыми словами                                        -->
<!-- ========================================================= -->
<section id="p44" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 44.</span>
    Appendix N — Глоссарий терминов Autocontent
  </h2>
  <p class="subtitle">
    Словарь ключевых терминов проекта.  
    Это фиксирует “единый язык” для команды, чтобы не было разночтений.
  </p>
  <div class="level-pill">Appendix / L1-L2</div>

  <div class="content-block">
    <h3>Базовые сущности</h3>
    <div class="card gray">
      <ul>
        <li><strong>Card (Карточка)</strong> — центральная сущность, будущая публикация на Avito. Содержит данные авто, фото, тексты, статусы конвейера.</li>
        <li><strong>Parser payload</strong> — JSON от auto-parser.ru/Auto.ru, входящий в систему.</li>
        <li><strong>Photo</strong> — единица изображения в карточке (raw → masked → stored).</li>
        <li><strong>Export</strong> — пакет карточек в формате выгрузки (XLSX/JSON).</li>
        <li><strong>Publish job</strong> — задача публикации одной карточки.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Pipeline / Технические термины</h3>
    <div class="card gray">
      <ul>
        <li><strong>Pipeline (Конвейер)</strong> — последовательность стадий: Parser → Photos → Export → Publish.</li>
        <li><strong>Stage (Стадия)</strong> — этап pipeline, имеющий свой статус и очередь.</li>
        <li><strong>Status</strong> — состояние карточки в StateMachine (draft, photos_ready, published и т.п.).</li>
        <li><strong>State Machine</strong> — “закон” допустимых статусов и переходов карточки.</li>
        <li><strong>Queue job</strong> — запись задания в очереди (универсально для всех стадий).</li>
        <li><strong>Worker</strong> — фоновый consumer конкретной очереди.</li>
        <li><strong>Retry</strong> — повторное выполнение job по policy.</li>
        <li><strong>DLQ (Dead Letter Queue)</strong> — хранилище фатальных job, которые не исправляются автоматом.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Интеграции / внешние сервисы</h3>
    <div class="card gray">
      <ul>
        <li><strong>Adapter</strong> — фасад для любой интеграции (ParserAdapter, PhotoApiAdapter и т.д.).</li>
        <li><strong>Contract</strong> — JSON schema формата входа/выхода сервиса.</li>
        <li><strong>Photo API</strong> — on-prem сервис маскировки номеров.</li>
        <li><strong>S3/Storage</strong> — MinIO/S3-совместимое хранилище фото и экспортов.</li>
        <li><strong>Dolphin Anty</strong> — антибраузер, выдаёт профили/сессии роботу.</li>
        <li><strong>Robot Service</strong> — внутренний модуль, который кликает/публикует через Dolphin → Avito.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>UI / роли</h3>
    <div class="card gray">
      <ul>
        <li><strong>Operator UI</strong> — рабочий фронт для операторов (карточки, фото, экспорт, публикация).</li>
        <li><strong>Admin UI</strong> — контур админа (очереди, DLQ, логи, здоровье сервисов).</li>
        <li><strong>RBAC</strong> — модель прав доступа по ролям.</li>
        <li><strong>Feature flag</strong> — переключатель поведения системы без релиза (dry-run, лимиты и т.п.).</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Этот глоссарий — официальный язык проекта. Любые новые термины добавляются сюда.
  </div>
</section>


<!-- ========================================================= -->
<!-- Part 45 (Appendix O / L2): Регламенты ролей (Operator/Admin) -->
<!-- Кто за что отвечает и как выглядит рабочий день             -->
<!-- ========================================================= -->
<section id="p45" class="section">
  <h2 class="section-title">
    <span class="part-number">Part 45.</span>
    Appendix O — Регламенты ролей и ответственности
  </h2>
  <p class="subtitle">
    Фиксируем, кто и за что отвечает в Autocontent,
    чтобы pipeline жил в проде без “серых зон”.
  </p>
  <div class="level-pill">Appendix / L2</div>

  <div class="content-block">
    <h3>Роль Operator</h3>
    <div class="grid-2">
      <div class="card gray">
        <h3>Задачи</h3>
        <ul>
          <li>Проверить draft карточки, исправить поля.</li>
          <li>Запустить Photos и контролировать прогресс.</li>
          <li>Создать Export, скачать пакет.</li>
          <li>Запустить Publish и смотреть статусы Avito.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Когда вмешиваться</h3>
        <ul>
          <li>Статус *_failed.</li>
          <li>В карточке есть ошибки Business.</li>
          <li>Не хватает фото/текста/цены.</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <h3>SLA Operator</h3>
      <ul>
        <li>Draft → start photos: не более X часов после прихода.</li>
        <li>Failed статусы: разбор в течение Y часов.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Роль Admin</h3>
    <div class="grid-2">
      <div class="card gray">
        <h3>Задачи</h3>
        <ul>
          <li>Следить за глубиной очередей.</li>
          <li>Разбирать DLQ (retry/фикс/эскалация).</li>
          <li>Смотреть health интеграций и их latency.</li>
          <li>Управлять ролями и фичефлагами.</li>
        </ul>
      </div>
      <div class="card gray">
        <h3>Когда вмешиваться</h3>
        <ul>
          <li>Queue depth растёт без снижения.</li>
          <li>DLQ spikes или новые fatal коды.</li>
          <li>Health сервиса = fail.</li>
        </ul>
      </div>
    </div>

    <div class="card gray" style="margin-top:8px;">
      <h3>SLA Admin / On-call</h3>
      <ul>
        <li>Критичный алерт очередей/health: реакция ≤ 15 мин.</li>
        <li>DLQ фаталы: triage ≤ 2 часа.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Роль Owner (тех/продукт)</h3>
    <div class="card gray">
      <ul>
        <li>Утверждает изменения StateMachine.</li>
        <li>Подписывает major изменения контрактов.</li>
        <li>Определяет SLA и лимиты публикации.</li>
        <li>Решает, что уходит в Phase 2.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Критичные сценарии эскалации</h3>
    <div class="card gray">
      <ul>
        <li>Publish остановился из-за антибота → Admin → Owner → решение по аккаунтам/профилям.</li>
        <li>Parser сменил формат → Admin/Owner → bump schema → Adapter hotfix.</li>
        <li>Photo API не отвечает → Admin → fallback очередь/пауза → ремонт сервиса.</li>
      </ul>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Итог:</strong>
    Роли и ответственности зафиксированы: Operator ведёт карточки,
    Admin держит живым pipeline и интеграции, Owner утверждает изменения фундамента.
  </div>
</section>
<!-- ========================================================= -->
<!-- Final Block: Закрытие документа и фиксация версии          -->
<!-- Этот блок ставим в самый конец HTML                        -->
<!-- ========================================================= -->
<section id="final" class="section final-section">
  <h2 class="section-title">
    Завершающий блок — фиксация документа Autocontent
  </h2>
  <p class="subtitle">
    Этот документ — единый источник истины по архитектуре, структуре репозитория
    и правилам развития Autocontent.
  </p>

  <div class="card brand" style="margin-bottom:12px;">
    <h3>Статус</h3>
    <p>
      Архитектура и структура проекта <strong>утверждены и заморожены</strong>.
      Любые изменения фундаментальных частей возможны только через
      процедуру major-изменений (contracts-first → state machine → tests → release).
    </p>
  </div>

  <div class="content-block">
    <h3>Что считается “фундаментом” (не меняем без major)</h3>
    <div class="card gray">
      <ul>
        <li>Структура репозитория: <code>backend / external / frontend / infra / docs / tests</code>.</li>
        <li>Pipeline стадий и их границы: Parser → Photos → Export → Publish.</li>
        <li>State Machine статусов карточки.</li>
        <li>Contracts-first и версионирование схем.</li>
        <li>Adapters как единственный слой интеграций.</li>
        <li>Очереди/воркеры + DLQ + retry-policy.</li>
        <li>Слоистая архитектура фронта (design/shared/features/apps).</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Что можно расширять свободно (в рамках правил)</h3>
    <div class="card gray">
      <ul>
        <li>Новые домены: добавляем как <code>Modules/&lt;Domain&gt;</code> и <code>features/&lt;domain&gt;</code>.</li>
        <li>Новые интеграции: добавляем как <code>Adapters/*</code> + <code>external/*/contracts</code>.</li>
        <li>Новые экраны UI: собираем из design/shared и доменных features.</li>
        <li>Оптимизации и UX-улучшения без ломания контрактов/статусов.</li>
        <li>Feature flags для безопасного включения изменений.</li>
      </ul>
    </div>
  </div>

  <div class="content-block">
    <h3>Как работать с этим документом</h3>
    <ol class="steps">
      <li>
        Перед новой фичей: сверяемся с <strong>State Machine</strong> и <strong>Contracts</strong>.
      </li>
      <li>
        Любой новый формат данных: сначала схема + fixtures, потом код.
      </li>
      <li>
        Любой новый статус/стадия: обновляем StateMachine + docs + tests.
      </li>
      <li>
        Codex/агент работает <strong>строго по Appendix H</strong>.
      </li>
    </ol>
  </div>

  <div class="content-block">
    <h3>Версия документа</h3>
    <div class="card gray mono small" style="line-height:1.7;">
      Document: Autocontent Architecture & Repo Blueprint
      Version: 1.0 (Frozen)
      Date: 2025-12-08
      Owners: Product/Tech owner + Backend lead + Frontend lead
      Change policy: Minor additions allowed. Major changes require new version.
    </div>
  </div>

  <div class="content-block">
    <h3>Следующие шаги команды</h3>
    <div class="card gray">
      <ol>
        <li>Идём в реализацию по фазам A–F (см. Part 21–22).</li>
        <li>Сначала backend happy-path, затем UI и стабильность.</li>
        <li>После MVP — Phase 2 только через точки расширения.</li>
      </ol>
    </div>
  </div>

  <div class="callout accepted">
    <strong>Документ завершён.</strong>
    С этого момента он является опорой для разработки и работы Codex.
    Любые отклонения от утверждённого фундамента считаются архитектурным изменением
    и требуют отдельного согласования.
  </div>
</section>
<style>
  /* Лёгкое визуальное отличие финального блока */
  .final-section{
    border-top:2px dashed var(--border);
    padding-top:20px;
  }
</style>
</main>






<script>
(function(){
  const upBtn = document.getElementById('scrollTopBtn');
  if(!upBtn) return;

  function getScrollParent(){
    // prefer the main content scroll container if any
    const candidates = [document.querySelector('main'), document.querySelector('.wrap'), document.body];
    for(const el of candidates){
      if(!el) continue;
      const st = getComputedStyle(el);
      const oy = st.overflowY;
      if((oy==='auto'||oy==='scroll') && el.scrollHeight>el.clientHeight){
        return el;
      }
    }
    return window;
  }

  const sp = getScrollParent();
  const showAt = 200;

  function getPos(){
    return sp===window ? (window.scrollY||document.documentElement.scrollTop||0) : sp.scrollTop;
  }
  function scrollToTop(){
    if(sp===window) window.scrollTo({top:0,behavior:'smooth'});
    else sp.scrollTo({top:0,behavior:'smooth'});
  }
  function onScroll(){
    const y=getPos();
    upBtn.style.display = y>showAt ? 'block' : 'none';
  }

  if(sp===window) window.addEventListener('scroll', onScroll, {passive:true});
  else sp.addEventListener('scroll', onScroll, {passive:true});

  upBtn.addEventListener('click', scrollToTop);
  onScroll();
})();
</script>
</body>
</html>
