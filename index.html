<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ООО "ТМЫВ ДЕНЕГ" – Кабинет</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
:root {
  /* ======================================================================
     COLOR SYSTEM (утверждено)
  ====================================================================== */
  --c-black: #000000;
  --c-white: #F9F9F9;
  --c-gray-dark: #333333;
  --c-gray: #646464;
  --c-gray-light: #A7A7A7;

  /* ✅ акценты (кастомим только по команде) */
  --c-orange: #E85002;
  --g-1: #000000;
  --g-2: #C10801;
  --g-3: #F16001;
  --g-4: #D9C3AB;

  /* ======================================================================
     LAYOUT
  ====================================================================== */
  --radius-md: 12px;
  --sidebar-w: 260px;
  --sidebar-w-collapsed: 48px;
  --logo-area-h: 76px;

  /* ✅ общий верхний отступ (для collapsed SVG и кнопки) */
  --logo-top: 18px;

  /* ======================================================================
     FONTS
  ====================================================================== */
  --font-sans: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  --font-brand: "HandelGothic BT Rus By Me", var(--font-sans);

  /* font sizes */
  --fs-11: 11px;
  --fs-12: 12px;
  --fs-13: 13px;
  --fs-15: 15px;
  --fs-20: 20px;
  --fs-24: 24px;
  --fs-44: 44px;

  /* font weights */
  --fw-menu: 350;
  --fw-regular: 400;
  --fw-medium: 500;
  --fw-semibold: 600;
  --fw-bold: 700;

  /* line heights */
  --lh-tight: 1.1;
  --lh-snug: 1.25;
  --lh-normal: 1.45;
  --lh-ui: 1.0;

  /* letter spacing */
  --ls-ui: 0.02em;
  --ls-brand: 0.2px;

  /* collapsed logo svg */
  --collapsed-logo-data: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik0yIDd2OGEyIDIgMCAwIDAgMiAyaDFNMiA3VjVhMiAyIDAgMCAxIDItMmgyTTIgN2E0IDQgMCAwIDAgNC00bTAgMGgxM20tOS4yMzYgOUEzIDMgMCAwIDEgMTQgNy43NjRNMiAyMEwyMCAybTEuMjIgMTYuMDQ3bC41NDktNi4yNjFjLjA3NS0uODY1LS41OTgtMS42My0xLjUwNC0xLjcxbC0uODItLjA3MW0xLjc3NiA4LjA0MmwtLjEzNyAxLjU2NmMtLjA3Ni44NjQtLjg3MiAxLjUwMS0xLjc3OCAxLjQyMmwtMS42NC0uMTQ0bTMuNTU1LTIuODQ0Yy0xLjgxMy0uMTU4LTMuNDA1IDEuMTE1LTMuNTU2IDIuODQ0bTAgMEw3IDE5Ljk1OG00LjM0Ny0zLjQ3N2MuNDA5LjUyLjk0Ljc4NSAxLjY3Ljg0OWMxLjM1OS4xMTkgMi41NTMtLjgzNiAyLjY2Ni0yLjEzM2MuMDYxLS42OTYtLjA4NS0xLjI2OS0uNTUxLTEuNzQzIi8+PC9zdmc+");
}

    @font-face{
      font-family: "HandelGothic BT Rus By Me";
      src:
        local("HandelGothicBTRusbyme-Regular"),
        local("HandelGothic BT [Rus by me] Regular"),
        url("./fonts/HandelGothicBTRusbyme-Regular.woff2") format("woff2"),
        url("./fonts/HandelGothicBTRusbyme-Regular.woff") format("woff"),
        url("./fonts/HandelGothicBTRusbyme-Regular.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--font-sans);
      background: var(--c-white);
      color: var(--c-black);
      min-height: 100vh;
    }

    .layout { display:flex; width:100%; min-height:100vh; position:relative; }

    /* ======================================================================
       TYPOGRAPHY ROLES
    ====================================================================== */
    .ty-logo{
      font-family: var(--font-brand);
      font-size: calc(var(--fs-20) + 2px); /* +2px по задаче */
      font-weight: var(--fw-bold);
      line-height: var(--lh-snug);
      letter-spacing: var(--ls-brand);
    }
    .ty-pill{
      font-family: var(--font-sans);
      font-size: var(--fs-11);
      font-weight: var(--fw-bold);
      line-height: var(--lh-ui);
    }
    .ty-section{
      font-family: var(--font-sans);
      font-size: var(--fs-12);
      font-weight: var(--fw-medium);
      letter-spacing: var(--ls-ui);
      line-height: var(--lh-ui);
    }
    .ty-nav{
      font-family: var(--font-sans);
      font-size: var(--fs-13);
      font-weight: var(--fw-menu);
      line-height: var(--lh-normal);
    }
    .ty-body{
      font-family: var(--font-sans);
      font-size: var(--fs-15);
      font-weight: var(--fw-regular);
      line-height: var(--lh-normal);
    }
    .ty-title{
      font-family: var(--font-sans);
      font-size: var(--fs-24);
      font-weight: var(--fw-semibold);
      line-height: var(--lh-snug);
    }
    .ty-hero{
      font-family: var(--font-sans);
      font-size: var(--fs-44);
      font-weight: var(--fw-bold);
      line-height: var(--lh-tight);
    }

    /* ======================================================================
       MEME STYLE (кастом по запросу)
    ====================================================================== */
    .ban-big{
      color: var(--c-orange);
      font-family: var(--font-sans);
      font-size: var(--fs-24);
      font-weight: var(--fw-semibold);
      line-height: var(--lh-snug);
      letter-spacing: var(--ls-brand);
    }

    /* ======================================================================
       SIDEBAR LAYOUT
    ====================================================================== */
    .sidebar {
      width: var(--sidebar-w);
      background: var(--c-black);
      border-right: 1px solid var(--c-gray-dark);
      position: fixed;
      inset: 0 auto 0 0;
      padding: 16px 0 12px;
      display: flex;
      flex-direction: column;
      transition: width 160ms ease, padding 160ms ease;
      color: var(--c-white);
      z-index: 30;
    }
    .sidebar.is-collapsed { width: var(--sidebar-w-collapsed); }

    .main {
      margin-left: var(--sidebar-w);
      width: calc(100% - var(--sidebar-w));
      min-height: 100vh;
      background: var(--c-white);
      transition: margin-left 160ms ease, width 160ms ease;
      color: var(--c-black);
      position: relative;
    }
    .sidebar.is-collapsed ~ .main {
      margin-left: var(--sidebar-w-collapsed);
      width: calc(100% - var(--sidebar-w-collapsed));
    }

    #pageRoot{
      position: relative;
      min-height: 100vh;
      padding: 0;
    }

/* ======================================================================
   LOGO AREA
====================================================================== */
.logo-area{
  height: var(--logo-area-h);
  position: relative;
  display: flex;
  align-items: flex-start;   /* было center — теперь к верху */
  justify-content: center;
  margin: 0 0 10px;
}

.logo-wrap {
  position:absolute; inset:0;
  display:flex; flex-direction:column;
  justify-content:flex-start; /* было center — теперь лого сверху */
  gap:6px;
  width:100%;
  padding:6px 10px 8px;       /* top = 6px как у collapsed */
  border-radius: var(--radius-md);
  user-select:none; white-space:nowrap; overflow:hidden;
}

.logo-main {
  color: var(--c-white);
  width:100%;
  text-align:center;
  white-space:nowrap;
  overflow:hidden;
  min-height: 1.2em;
}

.logo-pill {
  color: var(--c-white);
  background: var(--c-black);
  border:1px solid var(--c-white);
  border-radius:9px;
  padding:3px 9px 2px;
  text-transform:lowercase;
  align-self:flex-end;
  display:inline-flex; align-items:center; justify-content:center;

  opacity:0; transform: translateY(-10px);
  transition: opacity 280ms ease-out, transform 280ms ease-out;
  pointer-events:none;
}
.logo-pill.is-revealed{ opacity:1; transform:translateY(0); pointer-events:auto; }
.logo-pill span{ display:block; transform: translateY(-1px); }

.logo-collapsed {
  position:absolute; inset:0;
  display:none;
  width:100%;
  background:transparent;
  color: var(--c-white);
  align-items:center;
  justify-content:center;
  user-select:none;
}
.logo-collapsed::before{
  content:"";
  width:20px;
  height:20px;
  background-color: currentColor;
  -webkit-mask-image: var(--collapsed-logo-data);
  mask-image: var(--collapsed-logo-data);
  -webkit-mask-repeat:no-repeat; mask-repeat:no-repeat;
  -webkit-mask-position:center; mask-position:center;
  -webkit-mask-size:contain; mask-size:contain;
}

.sidebar.is-collapsed .logo-wrap{ display:none; }
.sidebar.is-collapsed .logo-collapsed{
  display:flex; align-items:flex-start; padding-top:6px;
}

/* ======================================================================
   BOOKMARK BUTTON — состояния:
   disabled = gray, enabled = black, active = orange (TOKEN ONLY)
====================================================================== */
    .bookmark-btn{
      position: absolute;
      top: var(--logo-top);
      left: 8px;
      width: 28px;
      height: 28px;

      border: none;
      background: transparent;
      padding: 0;

      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;

      /* ✅ если можно использовать — черная */
      color: var(--c-black);
      opacity: .9;
      z-index: 40;

      transition:
        opacity 120ms ease,
        transform 80ms ease,
        color 120ms ease,
        left 160ms ease;
    }

.bookmark-btn:hover{
  opacity: 1;
}

.bookmark-btn:active{
  transform: translateY(1px);
}

.bookmark-btn svg{
  width:18px;
  height:18px;
  stroke: currentColor;
  fill: none;
}

    /* ✅ активная (страница в избранном) */
    .bookmark-btn.is-active{
      color: var(--c-orange);
      opacity: 1;
    }

    /* ✅ заблокирована */
    .bookmark-btn.is-disabled{
      cursor: default;
      color: var(--c-gray-light) !important;
      transform: none !important;
      pointer-events: none;
      opacity: 1;
    }

/* ======================================================================
   SECTIONS + NAV
====================================================================== */
.nav-section{ 
  display:flex; 
  flex-direction:column; 
  gap:6px; 
  padding: 0 0 6px; 
}

.nav-section-title{
  color: var(--c-white);
  opacity: .65;
  padding: 0 14px;
  margin-top: 6px;
  user-select:none;
  text-transform: none;

  /* чтобы высота была стабильной */
  height: 16px;
  display:flex;
  align-items:center;
}

/* ✅ при collapsed не убираем из потока, только прячем */
.sidebar.is-collapsed .nav-section-title{ 
  visibility: hidden;  /* место остаётся */
  opacity: 0;
  pointer-events: none;
}

.nav-section-divider{
  height: 1px;
  background: var(--c-gray-dark);
  margin: 10px 8px;
  border-radius:1px;
  opacity: 1;
}

.nav { 
  display:flex; 
  flex-direction:column; 
  gap:4px; 
  margin-top:-5px; 
}

.nav-item {
  display:flex; align-items:center; gap:8px;
  margin: 0 5px;
  padding:8px 10px;
  border-radius:12px;
  color: var(--c-white);
  text-decoration:none;
  transition: background 120ms ease, color 120ms ease, transform 40ms ease;
  white-space:nowrap; outline:none; overflow:hidden;
  cursor:pointer;
}
.nav-item .ico{
  width:19px; min-width:19px; height:19px;
  display:flex; align-items:center; justify-content:center;
  color: currentColor; flex:0 0 19px;
}
.nav-item .ico svg{ width:18px;height:18px; stroke:currentColor; fill:none; }

.sidebar.is-collapsed .nav-item .ico{ transform: translateX(-1px); }

.nav-item .text{
  display:inline-block;
  transition: opacity 140ms ease, transform 140ms ease, width 140ms ease;
  transform: translateX(0); opacity:1; width:auto; overflow:hidden;
}
.sidebar.is-collapsed .nav-item .text{
  opacity:0; transform:translateX(-6px); width:0; pointer-events:none;
}

.nav-item:hover{ background: var(--c-gray-dark); }
.nav-item:active{ transform: translateY(1px); }
.nav-item.is-active{ background: var(--c-gray); color: var(--c-white); }

.nav-item,
.nav-item:hover,
.nav-item:active,
.nav-item:visited,
.nav-item.is-active { color: var(--c-white) !important; }

    /* ======================================================================
       COLLAPSE BUTTON
    ====================================================================== */
    .collapse-row{
      margin-top:auto;
      width: fit-content;
      align-self: flex-end;
      margin-right: 8px;

      display:flex; align-items:center; gap:4px;
      padding:4px 6px;

      background:transparent; border:none;
      color: var(--c-white);
      opacity:.65;

      cursor:pointer;
      user-select:none;
      letter-spacing: var(--ls-ui);
      border-radius: 8px;
    }

    .collapse-row:hover{
      background: transparent;
      opacity: .9;
    }

    .collapse-row:focus,
    .collapse-row:focus-visible{
      outline:none;
      box-shadow:none;
    }

    .collapse-ico{
      width:18px;height:18px; color: currentColor;
      display:inline-flex; align-items:center; justify-content:center;
      flex:0 0 18px;

      opacity:0; transform: translateX(2px);
      transition: opacity 120ms ease, transform 120ms ease;
    }
    .collapse-row:hover .collapse-ico{ opacity:1; transform:translateX(0); }
    .sidebar.is-collapsed .collapse-ico{ opacity:1; transform:translateX(0); }

    .collapse-text{ white-space:nowrap; }

    .sidebar.is-collapsed .collapse-row{
      align-self:center;
      margin-right:0;
      padding:4px 6px;
      gap:0;
    }
    .sidebar.is-collapsed .collapse-text{ display:none; }

    /* ======================================================================
       LOADER
    ====================================================================== */
    .page-loader{
      position: fixed;
      top:0; bottom:0;
      left: var(--sidebar-w);
      right:0;
      display:grid;
      place-items:center;
      pointer-events:none;
      z-index:999;
      transition: left 160ms ease;
    }
    .sidebar.is-collapsed ~ .main .page-loader{ left: var(--sidebar-w-collapsed); }

    .page-loader .ind-line{
      width:420px; height:2px;
      position:relative; overflow:hidden;
      background: transparent;
    }
    .page-loader .bar{
      position:absolute; inset:0;
      width:100%;
      background: var(--c-black);
      transform: translateX(-100%);
      animation: slideOnce .55s linear forwards;
    }
    .page-loader .bar.b2{ animation-delay:.55s; }

    @keyframes slideOnce{
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* ======================================================================
       404
    ====================================================================== */
    .page-404{
      position: fixed;
      top:0; bottom:0;
      left: var(--sidebar-w);
      right:0;
      display:grid;
      place-items:center;
      padding:40px;
      z-index:998;
      background: transparent;
      transition: left 160ms ease;
    }
    .sidebar.is-collapsed ~ .main .page-404{ left: var(--sidebar-w-collapsed); }

    .page-404-card{
      width:520px; max-width:90%;
      border:1px solid var(--c-gray-light);
      border-radius:16px;
      padding:28px 26px;
      background: var(--c-white);
      box-shadow: 0 10px 30px color-mix(in srgb, var(--c-black) 8%, transparent);
      text-align:center;
      color: var(--c-black);
    }

    .page-404-sub{
      color: var(--c-gray);
      margin-top: 8px;
    }

    @media (prefers-reduced-motion: reduce){
      .logo-pill, .nav-item .text, .collapse-ico{ transition:none; }
      .page-loader, .page-404{ transition:none; }
    }
  </style>
</head>

<body>
  <div id="app" class="layout"></div>

  <script type="module">
    /* ======================================================================
       BLOCK 1) ICONS
    ====================================================================== */
    const Icons = (() => {
      const ICONS = {
        search: `
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
               viewBox="0 0 24 24" fill="none" stroke="currentColor"
               stroke-linecap="round" stroke-width="2" aria-hidden="true">
            <path d="m21 21l-4.486-4.49M19 10.5a8.5 8.5 0 1 1-17 0a8.5 8.5 0 0 1 17 0Z"/>
          </svg>
        `,
        folder: `
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
               viewBox="0 0 24 24" fill="none" stroke="currentColor"
               stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
            <path d="M22 19V9a2 2 0 0 0-2-2h-6.764a2 2 0 0 1-1.789-1.106l-.894-1.788A2 2 0 0 0 8.763 3H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2"/>
          </svg>
        `,
        chevronLeftSmall: `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
               stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M14.5 7.5L9.5 12l5 4.5"></path>
          </svg>
        `,
        chevronRightSmall: `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
               stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M9.5 7.5l5 4.5l-5 4.5"></path>
          </svg>
        `,
        bookmark: `
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
               viewBox="0 0 24 24" fill="none" stroke="currentColor"
               stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
            <path d="M4 5v14.586c0 .89 1.077 1.337 1.707.707L12 14l6.293 6.293c.63.63 1.707.184 1.707-.707V5a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2"/>
          </svg>
        `,
      };
      return { ICONS };
    })();

    const NON_BOOKMARKABLE_IDS = new Set(["cars", "content", "404"]);

    /* ======================================================================
       BLOCK 2) PAGES + INCLUDES + LOADER/404
    ====================================================================== */
    const Pages = (() => {
      const PAGE_PATHS = {
        cars: "./pages/cars.html",
        content: "./pages/content.html",
      };

      const pageCache = {};
      const inflight = new Map();
      let lastOk = true;

      async function fetchText(url){
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error(`Fetch failed: ${url}`);
        return r.text();
      }

      async function resolveIncludes(html, baseUrl){
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");

        const includeNodes = [...doc.querySelectorAll("[data-include]")];
        if (includeNodes.length === 0) return doc.body.innerHTML;

        await Promise.all(includeNodes.map(async (node) => {
          const rel = node.getAttribute("data-include");
          if (!rel) return;

          const abs = new URL(rel, baseUrl).toString();
          let partialHtml = await fetchText(abs);
          partialHtml = await resolveIncludes(partialHtml, abs);

          const wrap = doc.createElement("div");
          wrap.innerHTML = partialHtml;
          node.replaceWith(...wrap.childNodes);
        }));

        return doc.body.innerHTML;
      }

      async function loadPage(id){
        if (pageCache[id]) return pageCache[id];
        if (inflight.has(id)) return inflight.get(id);

        const path = PAGE_PATHS[id];
        if (!path) return null;

        const promise = (async () => {
          const abs = new URL(path, location.href).toString();
          let html = await fetchText(abs);
          html = await resolveIncludes(html, abs);
          pageCache[id] = html;
          inflight.delete(id);
          return html;
        })().catch((e)=>{
          inflight.delete(id);
          console.error(e);
          return null;
        });

        inflight.set(id, promise);
        return promise;
      }

      function restartInlineScripts(container){
        container.querySelectorAll("script").forEach(old => {
          const s = document.createElement("script");
          [...old.attributes].forEach(a => s.setAttribute(a.name, a.value));
          s.textContent = old.textContent;
          old.replaceWith(s);
        });
      }

      async function showPage(id){
        const root = document.getElementById("pageRoot");
        if (!root) return;

        if (pageCache[id]) {
          root.innerHTML = pageCache[id];
          lastOk = true;
          window.dispatchEvent(new CustomEvent("page:loaded", { detail: { id, ok: true } }));
          restartInlineScripts(root);
          return;
        }

        root.innerHTML = `
          <div class="page-loader">
            <div class="ind-line">
              <span class="bar b1"></span>
              <span class="bar b2"></span>
            </div>
          </div>
        `;

        const start = performance.now();
        const html = await loadPage(id);

        const elapsed = performance.now() - start;
        const remain = Math.max(0, 2000 - elapsed);
        if (remain) await new Promise(r => setTimeout(r, remain));

        const ok = Boolean(html);

        root.innerHTML = ok ? html : `
          <div class="page-404">
            <div class="page-404-card">
              <div class="ty-hero">404</div>
              <div class="ty-title" style="margin-top:4px;">Страница не найдена</div>
              <div class="ty-body page-404-sub">
                Файл не смог загрузиться или отсутствует.<br/>
                Проверь путь: <b>${PAGE_PATHS[id] ?? id}</b>
              </div>
            </div>
          </div>
        `;

        lastOk = ok;
        window.dispatchEvent(new CustomEvent("page:loaded", { detail: { id, ok } }));

        restartInlineScripts(root);
      }

      return { PAGE_PATHS, showPage, getLastOk: () => lastOk };
    })();

    /* ======================================================================
       BLOCK 3) SIDEBAR DOMAIN (чистая логика)
    ====================================================================== */
    const SidebarDomain = (() => {
      function normalizeBookmark(bm){
        if (!bm || !bm.id || NON_BOOKMARKABLE_IDS.has(bm.id)) return null;
        return {
          id: bm.id,
          label: bm.label || bm.id,
          iconKey: bm.iconKey || "bookmark",
          group: "bookmark",
        };
      }

      function mergeItems(mainItems = [], bookmarks = []){
        const baseMain = mainItems.map(i => ({ ...i, group: "main" }));
        const normalizedBookmarks = bookmarks
          .map(normalizeBookmark)
          .filter(Boolean);
        return [...baseMain, ...normalizedBookmarks];
      }

      function createState({ items, bookmarks = [], activeId, collapsed = false } = {}) {
        if (!Array.isArray(items) || items.length === 0) {
          throw new Error("SidebarState: items must be a non-empty array");
        }

        const mergedItems = mergeItems(items, bookmarks);
        const hasActive = mergedItems.some(i => i.id === activeId);
        const initialActiveId = hasActive ? activeId : mergedItems[0].id;

        return { items: mergedItems, activeId: initialActiveId, collapsed: Boolean(collapsed) };
      }

      function setActive(state, id) {
        if (!state.items.some(i => i.id === id)) return state;
        return { ...state, activeId: id };
      }

      function toggleCollapsed(state) { return { ...state, collapsed: !state.collapsed }; }

      function toggleBookmark(state, mainItems, bookmark){
        const normalized = normalizeBookmark(bookmark);
        if (!normalized) return state;

        const existingBookmarks = state.items.filter(i => i.group === "bookmark");
        const hasBookmark = existingBookmarks.some(i => i.id === normalized.id);
        const nextBookmarks = hasBookmark
          ? existingBookmarks.filter(i => i.id !== normalized.id)
          : [...existingBookmarks, normalized];

        return { ...state, items: mergeItems(mainItems, nextBookmarks) };
      }

      function replaceBookmarks(state, mainItems, bookmarks){
        return { ...state, items: mergeItems(mainItems, bookmarks) };
      }

      function updateBookmark(state, mainItems, bookmark){
        const normalized = normalizeBookmark(bookmark);
        if (!normalized) return state;

        const existingBookmarks = state.items.filter(i => i.group === "bookmark");
        const hasBookmark = existingBookmarks.some(i => i.id === normalized.id);
        if (!hasBookmark) return state;

        const nextBookmarks = existingBookmarks.map(i =>
          i.id === normalized.id ? { ...i, ...normalized } : i
        );

        return { ...state, items: mergeItems(mainItems, nextBookmarks) };
      }

      return {
        createState,
        setActive,
        toggleCollapsed,
        toggleBookmark,
        replaceBookmarks,
        updateBookmark,
      };
    })();

    /* ======================================================================
       BLOCK 4) SIDEBAR INFRA (storage)
    ====================================================================== */
    const SidebarInfra = (() => {
      const KEY = "ehala.sidebar.v1";
      function createLocalStorageAdapter() {
        return {
          load() {
            try { const raw = localStorage.getItem(KEY); return raw ? JSON.parse(raw) : null; }
            catch { return null; }
          },
          save(data) {
            try { localStorage.setItem(KEY, JSON.stringify(data)); } catch {}
          },
        };
      }
      return { createLocalStorageAdapter };
    })();

    /* ======================================================================
       BLOCK 5) SIDEBAR APP (use-cases)
    ====================================================================== */
    const SidebarApp = (() => {
      const {
        createState,
        setActive,
        toggleCollapsed,
        toggleBookmark,
        replaceBookmarks,
        updateBookmark,
      } = SidebarDomain;

      function createService({ storageAdapter } = {}) {
        let state = null;
        let mainItems = [];
        const listeners = new Set();
        const notify = () => listeners.forEach(fn => fn(state));

        function save(){
          storageAdapter?.save?.({
            activeId: state?.activeId,
            collapsed: state?.collapsed,
            bookmarks: state?.items
              ?.filter(i => i.group === "bookmark")
              .map(({ group, ...rest }) => rest),
          });
        }

        function init({ items, defaultActiveId }) {
          const saved = storageAdapter?.load?.() || null;

          const savedBookmarks = Array.isArray(saved?.bookmarks) ? saved.bookmarks : [];
          mainItems = items;

          state = createState({
            items,
            bookmarks: savedBookmarks,
            activeId: saved?.activeId ?? defaultActiveId,
            collapsed: true, // меню всегда свернуто на старте
          });

          save();
          notify();
        }

        function onChange(listener) { listeners.add(listener); return () => listeners.delete(listener); }

        function selectItem(id) {
          state = setActive(state, id);
          save();
          notify();
        }

        function toggle() {
          state = toggleCollapsed(state);
          save();
          notify();
        }

        function toggleBookmarkCurrent(bookmark){
          if (!bookmark?.id || NON_BOOKMARKABLE_IDS.has(bookmark.id)) return;

          state = toggleBookmark(state, mainItems, { ...bookmark, iconKey: "bookmark" });

          save();
          notify();
        }

        function syncBookmarkMeta(bookmark){
          if (!bookmark?.id || NON_BOOKMARKABLE_IDS.has(bookmark.id)) return;

          state = updateBookmark(state, mainItems, { ...bookmark, iconKey: "bookmark" });

          save();
          notify();
        }

        function hydrateBookmarks(bookmarks){
          state = replaceBookmarks(state, mainItems, bookmarks);
          save();
          notify();
        }

        function getState() { return state; }

        return {
          init,
          onChange,
          selectItem,
          toggle,
          toggleBookmarkCurrent,
          syncBookmarkMeta,
          hydrateBookmarks,
          getState,
        };
      }

      return { createService };
    })();

    /* ======================================================================
       BLOCK 6) LOGO TYPING ENGINE (полностью отдельно от View)
    ====================================================================== */
    const LogoTyping = (() => {

      function create({ rootEl, getIsCollapsed }) {
        let typingTimer = null;
        let isTyping = false;
        let lastScenarioIndex = -1;
        let tokens = [];
        let startDelayTimer = null;

        let expandCount = 0;
        let stopTriggered = false;
        let stopLock = false;

        function cancelStartDelay(){
          if (startDelayTimer){
            clearTimeout(startDelayTimer);
            startDelayTimer = null;
          }
        }

        function clearTokens(){ tokens = []; }

        function pushChar(char, className=null){
          const last = tokens[tokens.length - 1];
          if (last && last.className === className) last.text += char;
          else tokens.push({ text: char, className });
        }

        function popChar(){
          const last = tokens[tokens.length - 1];
          if (!last) return;
          last.text = last.text.slice(0, -1);
          if (!last.text) tokens.pop();
        }

        function escapeHtml(s){
          return s.replace(/[&<>"']/g, (c) => ({
            "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
          }[c]));
        }

        function renderTokens(){
          const logoMain = rootEl.querySelector("#logoMain");
          if (!logoMain) return;
          logoMain.innerHTML = tokens.map(t => {
            if (!t.className) return escapeHtml(t.text);
            return `<span class="${t.className}">${escapeHtml(t.text)}</span>`;
          }).join("");
          fitLogoToOneLine();
        }

        function resetLogoFontSize(){
          const logoMain = rootEl.querySelector("#logoMain");
          if (!logoMain) return;
          logoMain.style.fontSize = "";
        }

        function fitLogoToOneLine(){
          const logoMain = rootEl.querySelector("#logoMain");
          if (!logoMain) return;
          resetLogoFontSize();
          const base = parseFloat(getComputedStyle(logoMain).fontSize);
          let size = base;
          const minFont = 12;
          const step = 0.5;

          requestAnimationFrame(() => {
            while (logoMain.scrollWidth > logoMain.clientWidth && size > minFont) {
              size -= step;
              logoMain.style.fontSize = size + "px";
            }
          });
        }

        function stopTyping(){
          isTyping = false;
          if (typingTimer){ clearTimeout(typingTimer); typingTimer = null; }
        }

        function getScenario(index){
          const tailFull = [{ kind:"type", text:"ООО «ТМЫВ ДЕНЕГ»" }];

          const scenarios = [
            { steps:[
              { kind:"type", text:"ОАО" }, { kind:"wait", ms:220 },
              { kind:"backspace", count:2 }, { kind:"wait", ms:140 },
              { kind:"type", text:"ОО" }, { kind:"wait", ms:240 },
              { kind:"type", text:" «ТМЫВ ДЕНЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"АО" }, { kind:"wait", ms:260 },
              { kind:"backspace", count:2 }, { kind:"wait", ms:170 },
              { kind:"type", text:"ООО" }, { kind:"wait", ms:220 },
              { kind:"type", text:" «ТМЫВ ДЕНЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"ООО" }, { kind:"wait", ms:220 },
              { kind:"type", text:" «тмыв" }, { kind:"wait", ms:180 },
              { kind:"backspace", count:4 }, { kind:"wait", ms:260 },
              { kind:"type", text:"ТМЫВ" }, { kind:"wait", ms:200 },
              { kind:"type", text:" ДЕНЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"ООО" }, { kind:"wait", ms:220 },
              { kind:"type", text:" «тм" }, { kind:"wait", ms:160 },
              { kind:"backspace", count:2 }, { kind:"wait", ms:240 },
              { kind:"type", text:"ТМЫВ" }, { kind:"wait", ms:200 },
              { kind:"type", text:" ДЕНЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"ООО" }, { kind:"wait", ms:200 },
              { kind:"type", text:" «ТМЬ" }, { kind:"wait", ms:160 },
              { kind:"backspace", count:1 }, { kind:"wait", ms:120 },
              { kind:"type", text:"ЫВ" }, { kind:"wait", ms:220 },
              { kind:"type", text:" ДЕНЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"ООО" }, { kind:"wait", ms:220 },
              { kind:"type", text:" «ТМЫВ " }, { kind:"wait", ms:140 },
              { kind:"type", text:"ДЕБ" }, { kind:"wait", ms:120 },
              { kind:"backspace", count:1 }, { kind:"wait", ms:130 },
              { kind:"type", text:"НЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"ООО" }, { kind:"wait", ms:200 },
              { kind:"type", text:" «ТМЫВ ДЕНЕГ" }, { kind:"wait", ms:220 },
              { kind:"backspace", count:2 }, { kind:"wait", ms:140 },
              { kind:"type", text:"ЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"ООО«" }, { kind:"wait", ms:200 },
              { kind:"backspace", count:1 }, { kind:"wait", ms:140 },
              { kind:"type", text:" «ТМЫВ ДЕНЕГ»" }
            ]},
            { steps:[
              { kind:"type", text:"Артем красавчик" }, { kind:"wait", ms:320 },
              { kind:"backspace", count:9 }, { kind:"wait", ms:240 },
              { kind:"type", text:" хочу ЗП 200" }, { kind:"wait", ms:260 },
              { kind:"backspace", count:3 }, { kind:"wait", ms:160 },
              { kind:"type", text:"600 000" }, { kind:"wait", ms:260 },
              { kind:"backspace", count:7 }, { kind:"wait", ms:180 },
              { kind:"backspace", count:999 }, { kind:"wait", ms:320 },
              ...tailFull
            ]},
            { steps:[
              { kind:"typeStyled", text:"МИША БАН", className:"ban-big" },
              { kind:"wait", ms:420 },
              { kind:"backspace", count:8 },
              { kind:"wait", ms:240 },
              ...tailFull
            ]},
          ];

          return scenarios[index] || { steps: tailFull };
        }

        function pickScenarioIndex(){
          const total = 10;
          let idx = Math.floor(Math.random() * total);
          if (total > 1 && idx === lastScenarioIndex) idx = (idx + 1) % total;
          lastScenarioIndex = idx;
          return idx;
        }

        function startStopTyping(){
          const logoPill = rootEl.querySelector("#logoPill");
          if (!logoPill) return;

          cancelStartDelay();
          stopTyping();
          isTyping = true;
          stopLock = true;

          clearTokens();
          renderTokens();
          resetLogoFontSize();
          logoPill.classList.remove("is-revealed");

          const steps = [
            { kind: "type", text: "СТОП." },
            { kind: "wait", ms: 320 },
            { kind: "type", text: " Мне не приятно" },
            { kind: "wait", ms: 220 },
            { kind: "type", text: " (" },
          ];

          let idx = 0;
          const baseCharDelay = 60, jitter = 80;
          const longPauseChance = 0.1, longPauseExtra = 160;

          const runNext = () => {
            if (!isTyping) return;
            const step = steps[idx++];

            if (!step){
              isTyping = false;
              return;
            }
            if (step.kind === "wait"){
              typingTimer = setTimeout(runNext, step.ms);
              return;
            }
            if (step.kind === "type"){
              const chars = Array.from(step.text);
              let ci = 0;

              const typeChar = () => {
                if (!isTyping) return;
                if (ci >= chars.length){
                  typingTimer = setTimeout(runNext, 50);
                  return;
                }
                pushChar(chars[ci++], null);
                renderTokens();
                let d = baseCharDelay + Math.floor(Math.random() * jitter);
                if (Math.random() < longPauseChance) d += longPauseExtra;
                typingTimer = setTimeout(typeChar, d);
              };
              typeChar();
            }
          };

          runNext();
        }

        function startScenarioTyping(){
          const logoPill = rootEl.querySelector("#logoPill");
          if (!logoPill) return;

          cancelStartDelay();
          stopTyping();
          isTyping = true;

          clearTokens();
          renderTokens();
          resetLogoFontSize();
          logoPill.classList.remove("is-revealed");

          const { steps } = getScenario(pickScenarioIndex());
          let idx = 0;

          const baseCharDelay = 55, jitter = 85;
          const longPauseChance = 0.12, longPauseExtra = 170;
          const baseBackDelay = 45, backJitter = 65;
          const longBackChance = 0.08, longBackExtra = 140;

          const runNext = () => {
            if (!isTyping) return;
            const step = steps[idx++];

            if (!step){
              typingTimer = setTimeout(() => {
                logoPill.classList.add("is-revealed");
                isTyping = false;
              }, 300);
              return;
            }

            if (step.kind === "wait"){
              typingTimer = setTimeout(runNext, step.ms);
              return;
            }

            if (step.kind === "type" || step.kind === "typeStyled"){
              const className = step.kind === "typeStyled" ? step.className : null;
              const chars = Array.from(step.text);
              let ci = 0;

              const typeChar = () => {
                if (!isTyping) return;
                if (ci >= chars.length){
                  typingTimer = setTimeout(runNext, 50);
                  return;
                }

                pushChar(chars[ci++], className);
                renderTokens();

                let d = baseCharDelay + Math.floor(Math.random() * jitter);
                if (Math.random() < longPauseChance) d += longPauseExtra;

                typingTimer = setTimeout(typeChar, d);
              };
              typeChar();
              return;
            }

            if (step.kind === "backspace"){
              let toDelete = step.count;
              const currentLen = tokens.reduce((s,t)=>s+t.text.length,0);
              if (toDelete >= 999) toDelete = currentLen;

              const backOne = () => {
                if (!isTyping) return;
                if (toDelete <= 0 || tokens.length === 0){
                  typingTimer = setTimeout(runNext, 50);
                  return;
                }

                popChar();
                renderTokens();
                toDelete--;

                let d = baseBackDelay + Math.floor(Math.random() * backJitter);
                if (Math.random() < longBackChance) d += longBackExtra;

                typingTimer = setTimeout(backOne, d);
              };
              backOne();
              return;
            }
          };

          runNext();
        }

        function waitSidebarFullyOpen(sidebarEl, cb){
          const onEnd = (e) => {
            if (e.propertyName !== "width") return;
            sidebarEl.removeEventListener("transitionend", onEnd);
            cb();
          };
          sidebarEl.addEventListener("transitionend", onEnd);
        }

        function scheduleTypingStart(sidebarEl){
          cancelStartDelay();
          startDelayTimer = setTimeout(() => {
            startDelayTimer = null;
            if (!getIsCollapsed()) startScenarioTyping();
          }, 300);
        }

        function onSidebarStateChange(state, lastCollapsed){
          const sidebar = rootEl.querySelector("#sidebar");
          const logoPill = rootEl.querySelector("#logoPill");
          if (!sidebar || !logoPill) return;

          if (state.collapsed){
            cancelStartDelay();
            stopTyping();
            clearTokens();
            renderTokens();
            resetLogoFontSize();
            logoPill.classList.remove("is-revealed");
            stopLock = false;
            return;
          }

          if (lastCollapsed === true && state.collapsed === false){
            if (stopTriggered){
              cancelStartDelay();
              stopTyping();
              clearTokens();
              renderTokens();
              resetLogoFontSize();
              logoPill.classList.remove("is-revealed");
              waitSidebarFullyOpen(sidebar, () => scheduleTypingStart(sidebar));
              return;
            }

            expandCount += 1;
            if (expandCount >= 15){
              stopTriggered = true;
              cancelStartDelay();
              stopTyping();
              clearTokens();
              renderTokens();
              resetLogoFontSize();
              logoPill.classList.remove("is-revealed");
              waitSidebarFullyOpen(sidebar, () => startStopTyping());
              return;
            }

            cancelStartDelay();
            stopTyping();
            clearTokens();
            renderTokens();
            resetLogoFontSize();
            logoPill.classList.remove("is-revealed");
            waitSidebarFullyOpen(sidebar, () => scheduleTypingStart(sidebar));
          }

          if (stopLock) return;
        }

        return { onSidebarStateChange };
      }

      return { create };
    })();

    /* ======================================================================
   BLOCK 7) SIDEBAR VIEW (рендер + события)
====================================================================== */
const SidebarView = (() => {

  function create({ service }) {
    let rootEl = null;
    let lastCollapsed = null;
    let logoTyping = null;
    let lastPageOk = true;

    function mount(container) {
      rootEl = document.createElement("div");
      rootEl.innerHTML = `
        <aside class="sidebar" id="sidebar">
          <div class="logo-area">
            <div class="logo-wrap" id="logoWrap">
              <div class="logo-main ty-logo" id="logoMain"></div>
              <div class="logo-pill ty-pill" id="logoPill"><span>кабинет</span></div>
            </div>
            <div class="logo-collapsed" aria-hidden="true"></div>
          </div>

          <div class="nav-section">
            <div class="nav-section-title ty-section">Навигация</div>
            <nav class="nav" id="navMain"></nav>
          </div>

          <div class="nav-section-divider"></div>

          <div class="nav-section">
            <div class="nav-section-title ty-section">Закладки</div>
            <nav class="nav" id="navBookmarks"></nav>
          </div>

          <button class="collapse-row ty-section" id="collapseBtn" type="button" aria-expanded="true">
            <span class="collapse-ico" aria-hidden="true"></span>
            <span class="collapse-text">Свернуть</span>
          </button>
        </aside>

        <main class="main" id="main">
          <button class="bookmark-btn" id="bookmarkBtn" type="button" aria-label="Добавить в закладки"></button>
          <div id="pageRoot"></div>
        </main>
      `;
      container.appendChild(rootEl);

      logoTyping = LogoTyping.create({
        rootEl,
        getIsCollapsed: () => service.getState().collapsed
      });

      const bookmarkBtn = rootEl.querySelector("#bookmarkBtn");
      bookmarkBtn.innerHTML = Icons.ICONS.bookmark;

      window.addEventListener("page:loaded", (e)=>{
        lastPageOk = Boolean(e?.detail?.ok);

        const meta = getActivePageMeta(service.getState());
        if (lastPageOk) {
          service.syncBookmarkMeta(meta);
        }

        updateBookmarkState(service.getState());
      });

      wireDOMEvents();
      service.onChange(render);
      render(service.getState());
    }

    function updateBookmarkState(state){
      const btn = rootEl.querySelector("#bookmarkBtn");
      if (!btn) return;

      const isBookmarkable = state.activeId && !NON_BOOKMARKABLE_IDS.has(state.activeId);
      const isDisabled = !isBookmarkable || !lastPageOk;

      const isBookmarked = state.items.some(
        i => i.group === "bookmark" && i.id === state.activeId
      );

      const isActive = !isDisabled && isBookmarked;

      btn.classList.toggle("is-disabled", isDisabled);
      btn.classList.toggle("is-active", isActive);
      btn.setAttribute("aria-pressed", String(isActive));
      btn.setAttribute(
        "aria-label",
        isDisabled
          ? "Добавить в закладки"
          : isActive
            ? "Убрать из закладок"
            : "Добавить в закладки"
      );
    }

    function getActivePageMeta(state){
      const id = state?.activeId;
      const pageRoot = rootEl.querySelector("#pageRoot");
      const titleNode = pageRoot?.querySelector("[data-page-title], h1");
      const titleText = (titleNode?.textContent || "").trim();

      const navItem = state?.items?.find(i => i.id === id);

      return {
        id,
        label: titleText || navItem?.label || id || "",
      };
    }

    function render(state) {
      const sidebar = rootEl.querySelector("#sidebar");
      const navMain = rootEl.querySelector("#navMain");
      const navBookmarks = rootEl.querySelector("#navBookmarks");

      const collapseBtn = rootEl.querySelector("#collapseBtn");
      const collapseText = rootEl.querySelector(".collapse-text");
      const collapseIco = rootEl.querySelector(".collapse-ico");

      sidebar.classList.toggle("is-collapsed", state.collapsed);
      collapseBtn.setAttribute("aria-expanded", String(!state.collapsed));

      collapseIco.innerHTML = state.collapsed
        ? Icons.ICONS.chevronRightSmall
        : Icons.ICONS.chevronLeftSmall;

      collapseText.textContent = state.collapsed ? "Развернуть" : "Свернуть";

      const mainItems = state.items.filter(i => i.group === "main");
      navMain.innerHTML = mainItems.map(item => navItemHtml(item, item.id === state.activeId)).join("");

      const bookmarkItems = state.items.filter(i => i.group === "bookmark");
      navBookmarks.innerHTML = bookmarkItems.map(item => navItemHtml(item, item.id === state.activeId)).join("");

      logoTyping.onSidebarStateChange(state, lastCollapsed);
      lastCollapsed = state.collapsed;

      updateBookmarkState(state);
    }

    function navItemHtml(item, active){
      const svg = Icons.ICONS[item.iconKey] || "";
      return `
        <a class="nav-item ty-nav ${active ? "is-active" : ""}" href="#" data-id="${item.id}">
          <span class="ico" aria-hidden="true">${svg}</span>
          <span class="text">${item.label}</span>
        </a>
      `;
    }

    function wireDOMEvents() {
      rootEl.addEventListener("click", async (e) => {
        const navItem = e.target.closest(".nav-item");
        if (navItem) {
          e.preventDefault();
          const id = navItem.dataset.id;
          service.selectItem(id);
          await Pages.showPage(id);
          return;
        }

        const bookmarkBtn = e.target.closest("#bookmarkBtn");
        if (bookmarkBtn){
          e.preventDefault();
          if (bookmarkBtn.classList.contains("is-disabled") || !lastPageOk) return;
          const meta = getActivePageMeta(service.getState());
          if (!meta?.id || NON_BOOKMARKABLE_IDS.has(meta.id)) return;
          service.toggleBookmarkCurrent(meta);
          return;
        }

        const collapseBtn = e.target.closest("#collapseBtn");
        if (collapseBtn) service.toggle();
      });
    }

    return { mount };
  }

  return { create };
})();

    /* ======================================================================
       BLOCK 8) HOTKEYS (только Shift+Я)
    ====================================================================== */
    const Hotkeys = (() => {
      function bind(service){
        window.addEventListener("keydown", (e) => {
          const t = e.target;
          const isTypingField =
            t && (
              t.tagName === "INPUT" ||
              t.tagName === "TEXTAREA" ||
              t.tagName === "SELECT" ||
              t.isContentEditable
            );
          if (isTypingField) return;

          if (e.shiftKey) {
            const k = (e.key || "").toLowerCase();
            if (k === "я") {
              e.preventDefault();
              service.toggle();
            }
          }
        });
      }
      return { bind };
    })();

    /* ======================================================================
       BLOCK 9) MAIN
    ====================================================================== */
    async function main() {
      const items = [
        { id: "cars",    label: "Поиск автомобилей", iconKey: "search", group: "main" },
        { id: "content", label: "Контент",           iconKey: "folder", group: "main" },
      ];

      const storageAdapter = SidebarInfra.createLocalStorageAdapter();
      const service = SidebarApp.createService({ storageAdapter });

      service.init({ items, defaultActiveId: "cars" });

      const root = document.getElementById("app");
      const view = SidebarView.create({ service });
      view.mount(root);

      Hotkeys.bind(service);

      await Pages.showPage(service.getState().activeId);
    }

    main();
  </script>
</body>
</html>
